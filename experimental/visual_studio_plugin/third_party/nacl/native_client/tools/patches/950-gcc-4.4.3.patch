diff -uNr gcc-4.4.3.orig/gcc/config/i386/i386.h gcc-4.4.3/gcc/config/i386/i386.h
--- gcc-4.4.3.orig/gcc/config/i386/i386.c	2010-02-21 00:03:26.000000000 +0100
+++ gcc-4.4.3/gcc/config/i386/i386.c	2010-02-21 00:06:13.000000000 +0100
@@ -2705,7 +2705,7 @@
 	     prefix, suffix, prefix, suffix, prefix, suffix);
 
   if (!ix86_arch_string)
-    ix86_arch_string = TARGET_64BIT ? "x86-64" : "i386";
+    ix86_arch_string = TARGET_64BIT ? "x86-64" : "i686";
   else
     ix86_arch_specified = 1;
 
diff -uNr gcc-4.4.3.orig/gcc/config/i386/i386.h gcc-4.4.3/gcc/config/i386/i386.h
--- gcc-4.4.3.orig/gcc/config/i386/i386.h	2009-07-11 21:06:26.000000000 +0200
+++ gcc-4.4.3/gcc/config/i386/i386.h	2010-02-20 22:59:45.000000000 +0100
@@ -621,7 +621,22 @@
 #define LONG_TYPE_SIZE BITS_PER_WORD
 #define DOUBLE_TYPE_SIZE 64
 #define LONG_LONG_TYPE_SIZE 64
-#define LONG_DOUBLE_TYPE_SIZE 80
+#define LONG_DOUBLE_TYPE_SIZE (TARGET_80387 ? 80 : 64)
+
+/* With SSE2 but no 80387 we can not use 80bit long double but with 80387 we
+   must use 80bit long double in registers - hardware limitation in both cases */
+
+#undef GET_MODE_WIDER_MODE
+#define GET_MODE_WIDER_MODE(MODE) \
+	(TARGET_80387 ? mode_wider[MODE] : \
+	 ((MODE) != DFmode && (MODE) != XFmode && (MODE) != V4DFmode && \
+	  (MODE) != DCmode && (MODE) != XCmode) ? mode_wider[MODE] : \
+						  VOIDmode)
+#undef GET_MODE_2XWIDER_MODE
+#define GET_MODE_2XWIDER_MODE(MODE) \
+	(TARGET_80387 ? mode_2xwider[MODE] : \
+	 ((MODE) != DFmode && (MODE) != XFmode) ? mode_2xwider[MODE] : \
+						  VOIDmode)
 
 #define WIDEST_HARDWARE_FP_SIZE LONG_DOUBLE_TYPE_SIZE
 
diff -uNr gcc-4.4.3.orig/gcc/config/i386/nacl.h gcc-4.4.3/gcc/config/i386/nacl.h
--- gcc-4.4.3.orig/gcc/config/i386/nacl.h	2010-02-20 23:36:23.000000000 +0100
+++ gcc-4.4.3/gcc/config/i386/nacl.h	2010-02-20 22:19:11.000000000 +0100
@@ -80,6 +80,19 @@
 #define LONG_TYPE_SIZE 32
 #define POINTER_SIZE 32
 #define POINTERS_EXTEND_UNSIGNED 1
+#undef LONG_DOUBLE_TYPE_SIZE
+#define LONG_DOUBLE_TYPE_SIZE 64
+
+#undef TARGET_SUBTARGET_DEFAULT
+#define TARGET_SUBTARGET_DEFAULT	(MASK_IEEE_FP)
+
+#undef TARGET_SUBTARGET32_DEFAULT
+#define TARGET_SUBTARGET32_DEFAULT \
+	(MASK_80387 | MASK_FLOAT_RETURNS)
+
+#undef TARGET_SUBTARGET64_DEFAULT
+#define TARGET_SUBTARGET64_DEFAULT 0
+
 /* NaCl reserves R15 and makes RBP special in x86-64 mode */
 #undef FIXED_REGISTERS
 #define FIXED_REGISTERS						\
diff -uNr gcc-4.4.3.orig/gcc/machmode.h gcc-4.4.3/gcc/machmode.h
--- gcc-4.4.3.orig/gcc/machmode.h	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.3/gcc/machmode.h	2010-02-20 22:10:26.000000000 +0100
@@ -219,10 +219,14 @@
 /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */
 
 extern const unsigned char mode_wider[NUM_MACHINE_MODES];
+#ifndef GET_MODE_WIDER_MODE
 #define GET_MODE_WIDER_MODE(MODE) mode_wider[MODE]
+#endif
 
 extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];
+#ifndef GET_MODE_2XWIDER_MODE
 #define GET_MODE_2XWIDER_MODE(MODE) mode_2xwider[MODE]
+#endif
 
 /* Return the mode for data of a given size SIZE and mode class CLASS.
    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.
