diff -Naur ../PRISTINE/gdb-6.8/bfd/Makefile.am gdb-6.8/bfd/Makefile.am
--- ../PRISTINE/gdb-6.8/bfd/Makefile.am	2008-02-14 07:20:24.000000000 -0800
+++ gdb-6.8/bfd/Makefile.am	2009-04-21 00:34:47.000000000 -0700
@@ -279,6 +279,7 @@
 	elf32-mips.lo \
 	elf32-mt.lo \
 	elf32-msp430.lo \
+	elf32-nacl.lo \
 	elf32-openrisc.lo \
 	elf32-or32.lo \
 	elf32-pj.lo \
@@ -460,6 +461,7 @@
 	elf32-mips.c \
 	elf32-mt.c \
 	elf32-msp430.c \
+	elf32-nacl.c \
 	elf32-openrisc.c \
 	elf32-or32.c \
 	elf32-pj.c \
@@ -1492,6 +1494,10 @@
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(INCDIR)/elf/msp430.h $(INCDIR)/elf/reloc-macros.h \
   elf32-target.h
+elf32-nacl.lo: elf32-nacl.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elf-vxworks.h \
+  $(INCDIR)/elf/i386.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elf32-openrisc.lo: elf32-openrisc.c $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
diff -Naur ../PRISTINE/gdb-6.8/bfd/Makefile.in gdb-6.8/bfd/Makefile.in
--- ../PRISTINE/gdb-6.8/bfd/Makefile.in	2008-02-14 07:20:24.000000000 -0800
+++ gdb-6.8/bfd/Makefile.in	2009-04-21 00:34:47.000000000 -0700
@@ -530,6 +530,7 @@
 	elf32-mips.lo \
 	elf32-mt.lo \
 	elf32-msp430.lo \
+	elf32-nacl.lo \
 	elf32-openrisc.lo \
 	elf32-or32.lo \
 	elf32-pj.lo \
@@ -711,6 +712,7 @@
 	elf32-mips.c \
 	elf32-mt.c \
 	elf32-msp430.c \
+	elf32-nacl.c \
 	elf32-openrisc.c \
 	elf32-or32.c \
 	elf32-pj.c \
@@ -2073,6 +2075,10 @@
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(INCDIR)/elf/msp430.h $(INCDIR)/elf/reloc-macros.h \
   elf32-target.h
+elf32-nacl.lo: elf32-nacl.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
+  $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h elf-vxworks.h \
+  $(INCDIR)/elf/i386.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elf32-openrisc.lo: elf32-openrisc.c $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
diff -Naur ../PRISTINE/gdb-6.8/bfd/config.bfd gdb-6.8/bfd/config.bfd
--- ../PRISTINE/gdb-6.8/bfd/config.bfd	2008-02-14 07:20:24.000000000 -0800
+++ gdb-6.8/bfd/config.bfd	2009-04-21 00:34:47.000000000 -0700
@@ -584,6 +584,11 @@
     targ_selvecs="i386linux_vec bfd_efi_app_ia32_vec bfd_efi_bsdrv_ia32_vec bfd_efi_rtdrv_ia32_vec"
     targ64_selvecs=bfd_elf64_x86_64_vec
     ;;
+  i[3-7]86-*-nacl*)
+    targ_defvec=bfd_elf32_nacl_vec
+    targ_selvecs="bfd_elf32_i386_vec i386linux_vec bfd_efi_app_ia32_vec mach_o_le_vec mach_o_be_vec mach_o_fat_vec"
+    targ_archs="bfd_i386_arch bfd_powerpc_arch"
+    ;;
 #ifdef BFD64
   x86_64-*-elf*)
     targ_defvec=bfd_elf64_x86_64_vec
diff -Naur ../PRISTINE/gdb-6.8/bfd/configure gdb-6.8/bfd/configure
--- ../PRISTINE/gdb-6.8/bfd/configure	2008-02-14 07:20:25.000000000 -0800
+++ gdb-6.8/bfd/configure	2009-04-21 00:34:47.000000000 -0700
@@ -17395,7 +17395,17 @@
 COREFILE=
 COREFLAG=
 TRAD_HEADER=
+
+# NativeClient is pseudo-native.
+native=no
 if test "${target}" = "${host}"; then
+  native=yes
+fi
+if test "${target_cpu}" = "${host_cpu}" -a "${target_os}" = "nacl"; then
+  native=yes
+fi
+
+if test "${native}" = "yes"; then
   case "${host}" in
   alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)
 	COREFILE=''
@@ -19094,6 +19104,7 @@
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
     bfd_elf32_msp430_vec)	tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
+    bfd_elf32_nacl_vec)		tb="$tb elf32-nacl.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_nbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
diff -Naur ../PRISTINE/gdb-6.8/bfd/configure.in gdb-6.8/bfd/configure.in
--- ../PRISTINE/gdb-6.8/bfd/configure.in	2008-02-14 07:20:26.000000000 -0800
+++ gdb-6.8/bfd/configure.in	2009-04-21 00:34:47.000000000 -0700
@@ -202,7 +202,17 @@
 COREFILE=
 COREFLAG=
 TRAD_HEADER=
+
+# NativeClient is pseudo-native.
+native=no
 if test "${target}" = "${host}"; then
+  native=yes
+fi
+if test "${target_cpu}" = "${host_cpu}" -a "${target_os}" = "nacl"; then
+  native=yes
+fi
+
+if test "${native}" = "yes"; then
   case "${host}" in
   alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)
 	COREFILE=''
@@ -703,6 +713,7 @@
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
     bfd_elf32_msp430_vec)	tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
+    bfd_elf32_nacl_vec)		tb="$tb elf32-nacl.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_nbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_nlittlemips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradbigmips_vec)	tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
diff -Naur ../PRISTINE/gdb-6.8/bfd/elf32-nacl.c gdb-6.8/bfd/elf32-nacl.c
--- ../PRISTINE/gdb-6.8/bfd/elf32-nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/bfd/elf32-nacl.c	2009-04-21 00:34:47.000000000 -0700
@@ -0,0 +1,4115 @@
+/* Intel 80386/80486-specific support for 32-bit ELF Native Client
+   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf-vxworks.h"
+#include "bfd_stdint.h"
+#include "elf/nacl.h"
+
+/* NativeClient binary format description input. */
+/* NativeClient format is based on elf32. */
+
+/* 386 uses REL relocations instead of RELA.  */
+#define USE_REL	1
+
+#include "elf/i386.h"
+
+static reloc_howto_type elf_howto_table[]=
+{
+  HOWTO(R_386_NONE, 0, 0, 0, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_NONE",
+	TRUE, 0x00000000, 0x00000000, FALSE),
+  HOWTO(R_386_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_PC32, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PC32",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+  HOWTO(R_386_GOT32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOT32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_PLT32, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PLT32",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+  HOWTO(R_386_COPY, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_COPY",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GLOB_DAT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GLOB_DAT",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_JUMP_SLOT, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_JUMP_SLOT",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_RELATIVE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_RELATIVE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GOTOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOTOFF",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GOTPC, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOTPC",
+	TRUE, 0xffffffff, 0xffffffff, TRUE),
+
+  /* We have a gap in the reloc numbers here.
+     R_386_standard counts the number up to this point, and
+     R_386_ext_offset is the value to subtract from a reloc type of
+     R_386_16 thru R_386_PC8 to form an index into this table.  */
+#define R_386_standard (R_386_GOTPC + 1)
+#define R_386_ext_offset (R_386_TLS_TPOFF - R_386_standard)
+
+  /* These relocs are a GNU extension.  */
+  HOWTO(R_386_TLS_TPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_TPOFF",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_IE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_IE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_GOTIE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GOTIE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LE",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_GD, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GD",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LDM, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LDM",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_16",
+	TRUE, 0xffff, 0xffff, FALSE),
+  HOWTO(R_386_PC16, 0, 1, 16, TRUE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_PC16",
+	TRUE, 0xffff, 0xffff, TRUE),
+  HOWTO(R_386_8, 0, 0, 8, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_8",
+	TRUE, 0xff, 0xff, FALSE),
+  HOWTO(R_386_PC8, 0, 0, 8, TRUE, 0, complain_overflow_signed,
+	bfd_elf_generic_reloc, "R_386_PC8",
+	TRUE, 0xff, 0xff, TRUE),
+
+#define R_386_ext (R_386_PC8 + 1 - R_386_ext_offset)
+#define R_386_tls_offset (R_386_TLS_LDO_32 - R_386_ext)
+  /* These are common with Solaris TLS implementation.  */
+  HOWTO(R_386_TLS_LDO_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LDO_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_IE_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_IE_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_LE_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_LE_32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DTPMOD32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DTPMOD32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DTPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DTPOFF32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_TPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_TPOFF32",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  EMPTY_HOWTO (38),
+  HOWTO(R_386_TLS_GOTDESC, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_GOTDESC",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_TLS_DESC_CALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
+	bfd_elf_generic_reloc, "R_386_TLS_DESC_CALL",
+	FALSE, 0, 0, FALSE),
+  HOWTO(R_386_TLS_DESC, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_TLS_DESC",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
+
+  /* Another gap.  */
+#define R_386_tls (R_386_TLS_DESC + 1 - R_386_tls_offset)
+#define R_386_vt_offset (R_386_GNU_VTINHERIT - R_386_tls)
+
+/* GNU extension to record C++ vtable hierarchy.  */
+  HOWTO (R_386_GNU_VTINHERIT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_386_GNU_VTINHERIT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+/* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_386_GNU_VTENTRY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_386_GNU_VTENTRY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE)			/* pcrel_offset */
+
+#define R_386_vt (R_386_GNU_VTENTRY + 1 - R_386_vt_offset)
+
+};
+
+#ifdef DEBUG_GEN_RELOC
+#define TRACE(str) \
+  fprintf (stderr, "i386 bfd reloc lookup %d (%s)\n", code, str)
+#else
+#define TRACE(str)
+#endif
+
+static reloc_howto_type *
+elf_i386_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    bfd_reloc_code_real_type code)
+{
+  switch (code)
+    {
+    case BFD_RELOC_NONE:
+      TRACE ("BFD_RELOC_NONE");
+      return &elf_howto_table[R_386_NONE];
+
+    case BFD_RELOC_32:
+      TRACE ("BFD_RELOC_32");
+      return &elf_howto_table[R_386_32];
+
+    case BFD_RELOC_CTOR:
+      TRACE ("BFD_RELOC_CTOR");
+      return &elf_howto_table[R_386_32];
+
+    case BFD_RELOC_32_PCREL:
+      TRACE ("BFD_RELOC_PC32");
+      return &elf_howto_table[R_386_PC32];
+
+    case BFD_RELOC_386_GOT32:
+      TRACE ("BFD_RELOC_386_GOT32");
+      return &elf_howto_table[R_386_GOT32];
+
+    case BFD_RELOC_386_PLT32:
+      TRACE ("BFD_RELOC_386_PLT32");
+      return &elf_howto_table[R_386_PLT32];
+
+    case BFD_RELOC_386_COPY:
+      TRACE ("BFD_RELOC_386_COPY");
+      return &elf_howto_table[R_386_COPY];
+
+    case BFD_RELOC_386_GLOB_DAT:
+      TRACE ("BFD_RELOC_386_GLOB_DAT");
+      return &elf_howto_table[R_386_GLOB_DAT];
+
+    case BFD_RELOC_386_JUMP_SLOT:
+      TRACE ("BFD_RELOC_386_JUMP_SLOT");
+      return &elf_howto_table[R_386_JUMP_SLOT];
+
+    case BFD_RELOC_386_RELATIVE:
+      TRACE ("BFD_RELOC_386_RELATIVE");
+      return &elf_howto_table[R_386_RELATIVE];
+
+    case BFD_RELOC_386_GOTOFF:
+      TRACE ("BFD_RELOC_386_GOTOFF");
+      return &elf_howto_table[R_386_GOTOFF];
+
+    case BFD_RELOC_386_GOTPC:
+      TRACE ("BFD_RELOC_386_GOTPC");
+      return &elf_howto_table[R_386_GOTPC];
+
+      /* These relocs are a GNU extension.  */
+    case BFD_RELOC_386_TLS_TPOFF:
+      TRACE ("BFD_RELOC_386_TLS_TPOFF");
+      return &elf_howto_table[R_386_TLS_TPOFF - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_IE:
+      TRACE ("BFD_RELOC_386_TLS_IE");
+      return &elf_howto_table[R_386_TLS_IE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_GOTIE:
+      TRACE ("BFD_RELOC_386_TLS_GOTIE");
+      return &elf_howto_table[R_386_TLS_GOTIE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_LE:
+      TRACE ("BFD_RELOC_386_TLS_LE");
+      return &elf_howto_table[R_386_TLS_LE - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_GD:
+      TRACE ("BFD_RELOC_386_TLS_GD");
+      return &elf_howto_table[R_386_TLS_GD - R_386_ext_offset];
+
+    case BFD_RELOC_386_TLS_LDM:
+      TRACE ("BFD_RELOC_386_TLS_LDM");
+      return &elf_howto_table[R_386_TLS_LDM - R_386_ext_offset];
+
+    case BFD_RELOC_16:
+      TRACE ("BFD_RELOC_16");
+      return &elf_howto_table[R_386_16 - R_386_ext_offset];
+
+    case BFD_RELOC_16_PCREL:
+      TRACE ("BFD_RELOC_16_PCREL");
+      return &elf_howto_table[R_386_PC16 - R_386_ext_offset];
+
+    case BFD_RELOC_8:
+      TRACE ("BFD_RELOC_8");
+      return &elf_howto_table[R_386_8 - R_386_ext_offset];
+
+    case BFD_RELOC_8_PCREL:
+      TRACE ("BFD_RELOC_8_PCREL");
+      return &elf_howto_table[R_386_PC8 - R_386_ext_offset];
+
+    /* Common with Sun TLS implementation.  */
+    case BFD_RELOC_386_TLS_LDO_32:
+      TRACE ("BFD_RELOC_386_TLS_LDO_32");
+      return &elf_howto_table[R_386_TLS_LDO_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_IE_32:
+      TRACE ("BFD_RELOC_386_TLS_IE_32");
+      return &elf_howto_table[R_386_TLS_IE_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_LE_32:
+      TRACE ("BFD_RELOC_386_TLS_LE_32");
+      return &elf_howto_table[R_386_TLS_LE_32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DTPMOD32:
+      TRACE ("BFD_RELOC_386_TLS_DTPMOD32");
+      return &elf_howto_table[R_386_TLS_DTPMOD32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DTPOFF32:
+      TRACE ("BFD_RELOC_386_TLS_DTPOFF32");
+      return &elf_howto_table[R_386_TLS_DTPOFF32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_TPOFF32:
+      TRACE ("BFD_RELOC_386_TLS_TPOFF32");
+      return &elf_howto_table[R_386_TLS_TPOFF32 - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_GOTDESC:
+      TRACE ("BFD_RELOC_386_TLS_GOTDESC");
+      return &elf_howto_table[R_386_TLS_GOTDESC - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DESC_CALL:
+      TRACE ("BFD_RELOC_386_TLS_DESC_CALL");
+      return &elf_howto_table[R_386_TLS_DESC_CALL - R_386_tls_offset];
+
+    case BFD_RELOC_386_TLS_DESC:
+      TRACE ("BFD_RELOC_386_TLS_DESC");
+      return &elf_howto_table[R_386_TLS_DESC - R_386_tls_offset];
+
+    case BFD_RELOC_VTABLE_INHERIT:
+      TRACE ("BFD_RELOC_VTABLE_INHERIT");
+      return &elf_howto_table[R_386_GNU_VTINHERIT - R_386_vt_offset];
+
+    case BFD_RELOC_VTABLE_ENTRY:
+      TRACE ("BFD_RELOC_VTABLE_ENTRY");
+      return &elf_howto_table[R_386_GNU_VTENTRY - R_386_vt_offset];
+
+    default:
+      break;
+    }
+
+  TRACE ("Unknown");
+  return 0;
+}
+
+static reloc_howto_type *
+elf_i386_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]); i++)
+    if (elf_howto_table[i].name != NULL
+	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
+      return &elf_howto_table[i];
+
+  return NULL;
+}
+
+static reloc_howto_type *
+elf_i386_rtype_to_howto (bfd *abfd, unsigned r_type)
+{
+  unsigned int indx;
+
+  if ((indx = r_type) >= R_386_standard
+      && ((indx = r_type - R_386_ext_offset) - R_386_standard
+	  >= R_386_ext - R_386_standard)
+      && ((indx = r_type - R_386_tls_offset) - R_386_ext
+	  >= R_386_tls - R_386_ext)
+      && ((indx = r_type - R_386_vt_offset) - R_386_tls
+	  >= R_386_vt - R_386_tls))
+    {
+      (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
+			     abfd, (int) r_type);
+      indx = R_386_NONE;
+    }
+  BFD_ASSERT (elf_howto_table [indx].type == r_type);
+  return &elf_howto_table[indx];
+}
+
+static void
+elf_i386_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
+			    arelent *cache_ptr,
+			    Elf_Internal_Rela *dst)
+{
+  unsigned int r_type = ELF32_R_TYPE (dst->r_info);
+  cache_ptr->howto = elf_i386_rtype_to_howto (abfd, r_type);
+}
+
+/* Return whether a symbol name implies a local label.  The UnixWare
+   2.1 cc generates temporary symbols that start with .X, so we
+   recognize them here.  FIXME: do other SVR4 compilers also use .X?.
+   If so, we should move the .X recognition into
+   _bfd_elf_is_local_label_name.  */
+
+static bfd_boolean
+elf_i386_is_local_label_name (bfd *abfd, const char *name)
+{
+  if (name[0] == '.' && name[1] == 'X')
+    return TRUE;
+
+  return _bfd_elf_is_local_label_name (abfd, name);
+}
+
+/* Support for core dump NOTE sections.  */
+
+static bfd_boolean
+elf_i386_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  int offset;
+  size_t size;
+
+  if (note->namesz == 8 && strcmp (note->namedata, "FreeBSD") == 0)
+    {
+      int pr_version = bfd_get_32 (abfd, note->descdata);
+
+      if (pr_version != 1)
+ 	return FALSE;
+
+      /* pr_cursig */
+      elf_tdata (abfd)->core_signal = bfd_get_32 (abfd, note->descdata + 20);
+
+      /* pr_pid */
+      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
+
+      /* pr_reg */
+      offset = 28;
+      size = bfd_get_32 (abfd, note->descdata + 8);
+    }
+  else
+    {
+      switch (note->descsz)
+	{
+	default:
+	  return FALSE;
+
+	case 144:		/* Linux/i386 */
+	  /* pr_cursig */
+	  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
+
+	  /* pr_pid */
+	  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
+
+	  /* pr_reg */
+	  offset = 72;
+	  size = 68;
+
+	  break;
+	}
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
+					  size, note->descpos + offset);
+}
+
+static bfd_boolean
+elf_i386_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  if (note->namesz == 8 && strcmp (note->namedata, "FreeBSD") == 0)
+    {
+      int pr_version = bfd_get_32 (abfd, note->descdata);
+
+      if (pr_version != 1)
+	return FALSE;
+
+      elf_tdata (abfd)->core_program
+	= _bfd_elfcore_strndup (abfd, note->descdata + 8, 17);
+      elf_tdata (abfd)->core_command
+	= _bfd_elfcore_strndup (abfd, note->descdata + 25, 81);
+    }
+  else
+    {
+      switch (note->descsz)
+	{
+	default:
+	  return FALSE;
+
+	case 124:		/* Linux/i386 elf_prpsinfo.  */
+	  elf_tdata (abfd)->core_program
+	    = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
+	  elf_tdata (abfd)->core_command
+	    = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
+	}
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+  {
+    char *command = elf_tdata (abfd)->core_command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return TRUE;
+}
+
+/* Functions for the i386 ELF linker.
+
+   In order to gain some understanding of code in this file without
+   knowing all the intricate details of the linker, note the
+   following:
+
+   Functions named elf_i386_* are called by external routines, other
+   functions are only called locally.  elf_i386_* functions appear
+   in this file more or less in the order in which they are called
+   from external routines.  eg. elf_i386_check_relocs is called
+   early in the link process, elf_i386_finish_dynamic_sections is
+   one of the last functions.  */
+
+
+/* The name of the dynamic interpreter.  This is put in the .interp
+   section.  */
+
+#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
+
+/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
+   copying dynamic variables from a shared lib into an app's dynbss
+   section, and instead use a dynamic relocation to point into the
+   shared lib.  */
+#define ELIMINATE_COPY_RELOCS 1
+
+/* The size in bytes of an entry in the procedure linkage table.  */
+
+#define PLT_ENTRY_SIZE 32
+
+/* The first entry in an absolute procedure linkage table looks like
+   this.  See the SVR4 ABI i386 supplement to see how this works.
+   Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
+
+static const bfd_byte elf_i386_plt0_entry[13] =
+{
+  0xff, 0x35,	/* pushl contents of address */
+  0, 0, 0, 0,	/* replaced with address of .got + 4.  */
+  0xb9,         /* movl address, %ecx */
+  0, 0, 0, 0,   /* replaced with address of .got + 8.  */
+  0xff, 0xe1	/* jmp *%ecx */
+};
+
+/* Subsequent entries in an absolute procedure linkage table look like
+   this.  */
+
+static const bfd_byte elf_i386_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0xb9,	                    /* movl address, %ecx */
+  0, 0, 0, 0,	            /* replaced with address of this symbol in .got.  */
+  0x83, 0xe1, 0xe0,         /* andl %ecx, NACLMASK */
+  0xff, 0xe1,	            /* jmp *%ecx */
+  0x90,                     /* nop, aligns pic/non-pic entries for relocation */
+  0x68,		            /* pushl immediate */
+  0, 0, 0, 0,	            /* replaced with offset into relocation table.  */
+  0xe9,		            /* jmp relative */
+  0, 0, 0, 0,	            /* replaced with offset to start of .plt.  */
+  0xf4, 0xf4, 0xf4,         /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4    /* fill with hlt instructions. */
+};
+
+/* The first entry in a PIC procedure linkage table look like this.
+   Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
+
+static const bfd_byte elf_i386_pic_plt0_entry[12] =
+{
+  0xff, 0xb3, 4, 0, 0, 0,	/* pushl 4(%ebx) */
+  0xff, 0xa3, 8, 0, 0, 0	/* jmp *8(%ebx) */
+};
+
+/* Subsequent entries in a PIC procedure linkage table look like this.  */
+
+static const bfd_byte elf_i386_pic_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0x8b, 0x8b,               /* movl offset(%ebx), %ecx */
+  0, 0, 0, 0,	            /* replaced with offset of this symbol in .got.  */
+  0x83, 0xe1, 0xe0,         /* andl %ecx, NACLMASK */
+  0xff, 0xe1,	            /* jmp *%ecx */
+  0x68,		            /* pushl immediate */
+  0, 0, 0, 0,	            /* replaced with offset into relocation table.  */
+  0xe9,		            /* jmp relative */
+  0, 0, 0, 0,	            /* replaced with offset to start of .plt.  */
+  0xf4, 0xf4, 0xf4,         /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4,   /* fill with hlt instructions. */
+  0xf4, 0xf4, 0xf4, 0xf4    /* fill with hlt instructions. */
+};
+
+/* On VxWorks, the .rel.plt.unloaded section has absolute relocations
+   for the PLTResolve stub and then for each PLT entry.  */
+#define PLTRESOLVE_RELOCS_SHLIB 0
+#define PLTRESOLVE_RELOCS 2
+#define PLT_NON_JUMP_SLOT_RELOCS 2
+
+/* The i386 linker needs to keep track of the number of relocs that it
+   decides to copy as dynamic relocs in check_relocs for each symbol.
+   This is so that it can later discard them if they are found to be
+   unnecessary.  We store the information in a field extending the
+   regular ELF linker hash table.  */
+
+struct elf_i386_dyn_relocs
+{
+  struct elf_i386_dyn_relocs *next;
+
+  /* The input section of the reloc.  */
+  asection *sec;
+
+  /* Total number of relocs copied for the input section.  */
+  bfd_size_type count;
+
+  /* Number of pc-relative relocs copied for the input section.  */
+  bfd_size_type pc_count;
+};
+
+/* i386 ELF linker hash entry.  */
+
+struct elf_i386_link_hash_entry
+{
+  struct elf_link_hash_entry elf;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_i386_dyn_relocs *dyn_relocs;
+
+#define GOT_UNKNOWN	0
+#define GOT_NORMAL	1
+#define GOT_TLS_GD	2
+#define GOT_TLS_IE	4
+#define GOT_TLS_IE_POS	5
+#define GOT_TLS_IE_NEG	6
+#define GOT_TLS_IE_BOTH 7
+#define GOT_TLS_GDESC	8
+#define GOT_TLS_GD_BOTH_P(type)						\
+  ((type) == (GOT_TLS_GD | GOT_TLS_GDESC))
+#define GOT_TLS_GD_P(type)						\
+  ((type) == GOT_TLS_GD || GOT_TLS_GD_BOTH_P (type))
+#define GOT_TLS_GDESC_P(type)						\
+  ((type) == GOT_TLS_GDESC || GOT_TLS_GD_BOTH_P (type))
+#define GOT_TLS_GD_ANY_P(type)						\
+  (GOT_TLS_GD_P (type) || GOT_TLS_GDESC_P (type))
+  unsigned char tls_type;
+
+  /* Offset of the GOTPLT entry reserved for the TLS descriptor,
+     starting at the end of the jump table.  */
+  bfd_vma tlsdesc_got;
+};
+
+#define elf_i386_hash_entry(ent) ((struct elf_i386_link_hash_entry *)(ent))
+
+struct elf_i386_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  char *local_got_tls_type;
+
+  /* GOTPLT entries for TLS descriptors.  */
+  bfd_vma *local_tlsdesc_gotent;
+};
+
+#define elf_i386_tdata(abfd) \
+  ((struct elf_i386_obj_tdata *) (abfd)->tdata.any)
+
+#define elf_i386_local_got_tls_type(abfd) \
+  (elf_i386_tdata (abfd)->local_got_tls_type)
+
+#define elf_i386_local_tlsdesc_gotent(abfd) \
+  (elf_i386_tdata (abfd)->local_tlsdesc_gotent)
+
+#define is_i386_elf(bfd)				\
+  (bfd_get_flavour (bfd) == bfd_target_elf_flavour	\
+   && elf_tdata (bfd) != NULL				\
+   && elf_object_id (bfd) == I386_ELF_TDATA)
+
+static bfd_boolean
+elf_i386_mkobject (bfd *abfd)
+{
+  return bfd_elf_allocate_object (abfd, sizeof (struct elf_i386_obj_tdata),
+				  I386_ELF_TDATA);
+}
+
+/* i386 ELF linker hash table.  */
+
+struct elf_i386_link_hash_table
+{
+  struct elf_link_hash_table elf;
+
+  /* Short-cuts to get to dynamic linker sections.  */
+  asection *sgot;
+  asection *sgotplt;
+  asection *srelgot;
+  asection *splt;
+  asection *srelplt;
+  asection *sdynbss;
+  asection *srelbss;
+
+  /* The (unloaded but important) .rel.plt.unloaded section on VxWorks.  */
+  asection *srelplt2;
+
+  /* True if the target system is VxWorks.  */
+  int is_vxworks;
+
+  /* Value used to fill the last word of the first plt entry.  */
+  bfd_byte plt0_pad_byte;
+
+  /* The index of the next unused R_386_TLS_DESC slot in .rel.plt.  */
+  bfd_vma next_tls_desc_index;
+
+  union {
+    bfd_signed_vma refcount;
+    bfd_vma offset;
+  } tls_ldm_got;
+
+  /* The amount of space used by the reserved portion of the sgotplt
+     section, plus whatever space is used by the jump slots.  */
+  bfd_vma sgotplt_jump_table_size;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_sec_cache sym_sec;
+};
+
+/* Get the i386 ELF linker hash table from a link_info structure.  */
+
+#define elf_i386_hash_table(p) \
+  ((struct elf_i386_link_hash_table *) ((p)->hash))
+
+#define elf_i386_compute_jump_table_size(htab) \
+  ((htab)->next_tls_desc_index * 4)
+
+/* Create an entry in an i386 ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+link_hash_newfunc (struct bfd_hash_entry *entry,
+		   struct bfd_hash_table *table,
+		   const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (table,
+				 sizeof (struct elf_i386_link_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct elf_i386_link_hash_entry *eh;
+
+      eh = (struct elf_i386_link_hash_entry *) entry;
+      eh->dyn_relocs = NULL;
+      eh->tls_type = GOT_UNKNOWN;
+      eh->tlsdesc_got = (bfd_vma) -1;
+    }
+
+  return entry;
+}
+
+/* Create an i386 ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+elf_i386_link_hash_table_create (bfd *abfd)
+{
+  struct elf_i386_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct elf_i386_link_hash_table);
+
+  ret = bfd_malloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
+				      sizeof (struct elf_i386_link_hash_entry)))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  ret->sgot = NULL;
+  ret->sgotplt = NULL;
+  ret->srelgot = NULL;
+  ret->splt = NULL;
+  ret->srelplt = NULL;
+  ret->sdynbss = NULL;
+  ret->srelbss = NULL;
+  ret->tls_ldm_got.refcount = 0;
+  ret->next_tls_desc_index = 0;
+  ret->sgotplt_jump_table_size = 0;
+  ret->sym_sec.abfd = NULL;
+  ret->is_vxworks = 0;
+  ret->srelplt2 = NULL;
+  ret->plt0_pad_byte = 0xf4;
+
+  return &ret->elf.root;
+}
+
+/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
+   shortcuts to them in our hash table.  */
+
+static bfd_boolean
+create_got_section (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+
+  if (! _bfd_elf_create_got_section (dynobj, info))
+    return FALSE;
+
+  htab = elf_i386_hash_table (info);
+  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
+  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
+  if (!htab->sgot || !htab->sgotplt)
+    abort ();
+
+  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rel.got",
+					       (SEC_ALLOC | SEC_LOAD
+						| SEC_HAS_CONTENTS
+						| SEC_IN_MEMORY
+						| SEC_LINKER_CREATED
+						| SEC_READONLY));
+  if (htab->srelgot == NULL
+      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
+    return FALSE;
+  return TRUE;
+}
+
+/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
+   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
+   hash table.  */
+
+static bfd_boolean
+elf_i386_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+
+  htab = elf_i386_hash_table (info);
+  if (!htab->sgot && !create_got_section (dynobj, info))
+    return FALSE;
+
+  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
+    return FALSE;
+
+  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
+  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
+  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
+  if (!info->shared)
+    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");
+
+  if (!htab->splt || !htab->srelplt || !htab->sdynbss
+      || (!info->shared && !htab->srelbss))
+    abort ();
+
+  if (htab->is_vxworks
+      && !elf_vxworks_create_dynamic_sections (dynobj, info, &htab->srelplt2))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+elf_i386_copy_indirect_symbol (struct bfd_link_info *info,
+			       struct elf_link_hash_entry *dir,
+			       struct elf_link_hash_entry *ind)
+{
+  struct elf_i386_link_hash_entry *edir, *eind;
+
+  edir = (struct elf_i386_link_hash_entry *) dir;
+  eind = (struct elf_i386_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+	{
+	  struct elf_i386_dyn_relocs **pp;
+	  struct elf_i386_dyn_relocs *p;
+
+	  /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
+	    {
+	      struct elf_i386_dyn_relocs *q;
+
+	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
+		if (q->sec == p->sec)
+		  {
+		    q->pc_count += p->pc_count;
+		    q->count += p->count;
+		    *pp = p->next;
+		    break;
+		  }
+	      if (q == NULL)
+		pp = &p->next;
+	    }
+	  *pp = edir->dyn_relocs;
+	}
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  if (ind->root.type == bfd_link_hash_indirect
+      && dir->got.refcount <= 0)
+    {
+      edir->tls_type = eind->tls_type;
+      eind->tls_type = GOT_UNKNOWN;
+    }
+
+  if (ELIMINATE_COPY_RELOCS
+      && ind->root.type != bfd_link_hash_indirect
+      && dir->dynamic_adjusted)
+    {
+      /* If called to transfer flags for a weakdef during processing
+	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
+	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
+      dir->ref_dynamic |= ind->ref_dynamic;
+      dir->ref_regular |= ind->ref_regular;
+      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
+      dir->needs_plt |= ind->needs_plt;
+      dir->pointer_equality_needed |= ind->pointer_equality_needed;
+    }
+  else
+    _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+typedef union 
+  {
+    unsigned char c[2];
+    uint16_t i;
+  }
+i386_opcode16;
+
+/* Return TRUE if the TLS access code sequence support transition
+   from R_TYPE.  */
+
+static bfd_boolean
+elf_i386_check_tls_transition (bfd *abfd, asection *sec,
+			       bfd_byte *contents,
+			       Elf_Internal_Shdr *symtab_hdr,
+			       struct elf_link_hash_entry **sym_hashes,
+			       unsigned int r_type,
+			       const Elf_Internal_Rela *rel,
+			       const Elf_Internal_Rela *relend)
+{
+  unsigned int val, type;
+  unsigned long r_symndx;
+  struct elf_link_hash_entry *h;
+  bfd_vma offset;
+
+  /* Get the section contents.  */
+  if (contents == NULL)
+    {
+      if (elf_section_data (sec)->this_hdr.contents != NULL)
+	contents = elf_section_data (sec)->this_hdr.contents;
+      else
+	{
+	  /* FIXME: How to better handle error condition?  */
+	  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
+	    return FALSE;
+
+	  /* Cache the section contents for elf_link_input_bfd.  */
+	  elf_section_data (sec)->this_hdr.contents = contents;
+	}
+    }
+
+  offset = rel->r_offset;
+  switch (r_type)
+    {
+    case R_386_TLS_GD:
+    case R_386_TLS_LDM:
+      if (offset < 2 || (rel + 1) >= relend)
+	return FALSE;
+
+      type = bfd_get_8 (abfd, contents + offset - 2);
+      if (r_type == R_386_TLS_GD)
+	{
+	  /* Check transition from LD access model.  Only
+		leal foo@tlsgd(,%reg,1), %eax; call ___tls_get_addr
+		leal foo@tlsgd(%reg), %eax; call ___tls_get_addr; nop
+	     can transit to different access model.  */
+	  if ((offset + 10) > sec->size ||
+	      (type != 0x8d && type != 0x04))
+	    return FALSE;
+
+	  val = bfd_get_8 (abfd, contents + offset - 1);
+	  if (type == 0x04)
+	    {
+	      /* leal foo@tlsgd(,%reg,1), %eax; call ___tls_get_addr */
+	      if (offset < 3)
+		return FALSE;
+
+	      if (bfd_get_8 (abfd, contents + offset - 3) != 0x8d)
+		return FALSE;
+
+	      if ((val & 0xc7) != 0x05 || val == (4 << 3))
+		return FALSE;
+	    }
+	  else
+	    {
+	      /* leal foo@tlsgd(%reg), %eax; call ___tls_get_addr; nop  */
+	      if ((val & 0xf8) != 0x80 || (val & 7) == 4)
+		return FALSE;
+
+	      if (bfd_get_8 (abfd, contents + offset + 9) != 0x90)
+		return FALSE;
+	    }
+	}
+      else
+	{
+	  /* Check transition from LD access model.  Only
+		leal foo@tlsgd(%reg), %eax; call ___tls_get_addr
+	     can transit to different access model.  */
+	  if (type != 0x8d || (offset + 9) > sec->size)
+	    return FALSE;
+
+	  val = bfd_get_8 (abfd, contents + offset - 1);
+	  if ((val & 0xf8) != 0x80 || (val & 7) == 4)
+	    return FALSE;
+	}
+
+      if (bfd_get_8 (abfd, contents + offset + 4) != 0xe8)
+	return FALSE;
+
+      r_symndx = ELF32_R_SYM (rel[1].r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+	return FALSE;
+
+      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+      return (h != NULL
+	      && h->root.root.string != NULL
+	      && (ELF32_R_TYPE (rel[1].r_info) == R_386_PC32
+		  || ELF32_R_TYPE (rel[1].r_info) == R_386_PLT32)
+	      && (strcmp (h->root.root.string, "___tls_get_addr") == 0));
+
+    case R_386_TLS_IE:
+      /* Check transition from IE access model:
+		movl foo@indntpoff(%rip), %eax
+		movl foo@indntpoff(%rip), %reg
+		addl foo@indntpoff(%rip), %reg
+       */
+
+      if (offset < 1 || (offset + 4) > sec->size)
+	return FALSE;
+
+      /* Check "movl foo@tpoff(%rip), %eax" first.  */
+      val = bfd_get_8 (abfd, contents + offset - 1);
+      if (val == 0xa1)
+	return TRUE;
+
+      if (offset < 2)
+	return FALSE;
+
+      /* Check movl|addl foo@tpoff(%rip), %reg.   */
+      type = bfd_get_8 (abfd, contents + offset - 2);
+      return ((type == 0x8b || type == 0x03)
+	      && (val & 0xc7) == 0x05);
+
+    case R_386_TLS_GOTIE:
+    case R_386_TLS_IE_32:
+      /* Check transition from {IE_32,GOTIE} access model:
+		subl foo@{tpoff,gontoff}(%reg1), %reg2
+		movl foo@{tpoff,gontoff}(%reg1), %reg2
+		addl foo@{tpoff,gontoff}(%reg1), %reg2
+       */
+
+      if (offset < 2 || (offset + 4) > sec->size)
+	return FALSE;
+
+      val = bfd_get_8 (abfd, contents + offset - 1);
+      if ((val & 0xc0) != 0x80 || (val & 7) == 4)
+	return FALSE;
+
+      type = bfd_get_8 (abfd, contents + offset - 2);
+      return type == 0x8b || type == 0x2b || type == 0x03;
+
+    case R_386_TLS_GOTDESC:
+      /* Check transition from GDesc access model:
+		leal x@tlsdesc(%ebx), %eax
+
+	 Make sure it's a leal adding ebx to a 32-bit offset
+	 into any register, although it's probably almost always
+	 going to be eax.  */
+
+      if (offset < 2 || (offset + 4) > sec->size)
+	return FALSE;
+
+      if (bfd_get_8 (abfd, contents + offset - 2) != 0x8d)
+	return FALSE;
+
+      val = bfd_get_8 (abfd, contents + offset - 1);
+      return (val & 0xc7) == 0x83;
+
+    case R_386_TLS_DESC_CALL:
+      /* Check transition from GDesc access model:
+		call *x@tlsdesc(%rax)
+       */
+      if (offset + 2 <= sec->size)
+	{
+	  /* Make sure that it's a call *x@tlsdesc(%rax).  */
+	  static i386_opcode16 call = { { 0xff, 0x10 } };
+	  return bfd_get_16 (abfd, contents + offset) == call.i;
+	}
+
+      return FALSE;
+
+    default:
+      abort ();
+    }
+}
+
+/* Return TRUE if the TLS access transition is OK or no transition
+   will be performed.  Update R_TYPE if there is a transition.  */
+
+static bfd_boolean
+elf_i386_tls_transition (struct bfd_link_info *info, bfd *abfd,
+			 asection *sec, bfd_byte *contents,
+			 Elf_Internal_Shdr *symtab_hdr,
+			 struct elf_link_hash_entry **sym_hashes,
+			 unsigned int *r_type, int tls_type,
+			 const Elf_Internal_Rela *rel,
+			 const Elf_Internal_Rela *relend,
+			 struct elf_link_hash_entry *h)
+{
+  unsigned int from_type = *r_type;
+  unsigned int to_type = from_type;
+  bfd_boolean check = TRUE;
+
+  switch (from_type)
+    {
+    case R_386_TLS_GD:
+    case R_386_TLS_GOTDESC:
+    case R_386_TLS_DESC_CALL:
+    case R_386_TLS_IE_32:
+    case R_386_TLS_IE:
+    case R_386_TLS_GOTIE:
+      if (!info->shared)
+	{
+	  if (h == NULL)
+	    to_type = R_386_TLS_LE_32;
+	  else if (from_type != R_386_TLS_IE
+		   && from_type != R_386_TLS_GOTIE)
+	    to_type = R_386_TLS_IE_32;
+	}
+
+      /* When we are called from elf_i386_relocate_section, CONTENTS
+	 isn't NULL and there may be additional transitions based on
+	 TLS_TYPE.  */
+      if (contents != NULL)
+	{
+	  unsigned int new_to_type = to_type;
+
+	  if (!info->shared
+	      && h != NULL
+	      && h->dynindx == -1
+	      && (tls_type & GOT_TLS_IE))
+	    new_to_type = R_386_TLS_LE_32;
+
+	  if (to_type == R_386_TLS_GD
+	      || to_type == R_386_TLS_GOTDESC
+	      || to_type == R_386_TLS_DESC_CALL)
+	    {
+	      if (tls_type == GOT_TLS_IE_POS)
+		new_to_type = R_386_TLS_GOTIE;
+	      else if (tls_type & GOT_TLS_IE)
+		new_to_type = R_386_TLS_IE_32;
+	    }
+
+	  /* We checked the transition before when we were called from
+	     elf_i386_check_relocs.  We only want to check the new
+	     transition which hasn't been checked before.  */
+	  check = new_to_type != to_type && from_type == to_type;
+	  to_type = new_to_type;
+	}
+
+      break;
+
+    case R_386_TLS_LDM:
+      if (!info->shared)
+	to_type = R_386_TLS_LE_32;
+      break;
+
+    default:
+      return TRUE;
+    }
+
+  /* Return TRUE if there is no transition.  */
+  if (from_type == to_type)
+    return TRUE;
+
+  /* Check if the transition can be performed.  */
+  if (check
+      && ! elf_i386_check_tls_transition (abfd, sec, contents,
+					  symtab_hdr, sym_hashes,
+					  from_type, rel, relend))
+    {
+      reloc_howto_type *from, *to;
+
+      from = elf_i386_rtype_to_howto (abfd, from_type);
+      to = elf_i386_rtype_to_howto (abfd, to_type);
+
+      (*_bfd_error_handler)
+	(_("%B: TLS transition from %s to %s against `%s' at 0x%lx "
+	   "in section `%A' failed"),
+	 abfd, sec, from->name, to->name,
+	 h ? h->root.root.string : "a local symbol",
+	 (unsigned long) rel->r_offset);
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+
+  *r_type = to_type;
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   calculate needed space in the global offset table, procedure linkage
+   table, and dynamic reloc sections.  */
+
+static bfd_boolean
+elf_i386_check_relocs (bfd *abfd,
+		       struct bfd_link_info *info,
+		       asection *sec,
+		       const Elf_Internal_Rela *relocs)
+{
+  struct elf_i386_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  asection *sreloc;
+
+  if (info->relocatable)
+    return TRUE;
+
+  BFD_ASSERT (is_i386_elf (abfd));
+
+  htab = elf_i386_hash_table (info);
+  symtab_hdr = &elf_symtab_hdr (abfd);
+  sym_hashes = elf_sym_hashes (abfd);
+
+  sreloc = NULL;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned int r_type;
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type = ELF32_R_TYPE (rel->r_info);
+
+      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
+	{
+	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
+				 abfd,
+				 r_symndx);
+	  return FALSE;
+	}
+
+      if (r_symndx < symtab_hdr->sh_info)
+	h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      if (! elf_i386_tls_transition (info, abfd, sec, NULL,
+				     symtab_hdr, sym_hashes,
+				     &r_type, GOT_UNKNOWN,
+				     rel, rel_end, h)) 
+	return FALSE;
+
+      switch (r_type)
+	{
+	case R_386_TLS_LDM:
+	  htab->tls_ldm_got.refcount += 1;
+	  goto create_got;
+
+	case R_386_PLT32:
+	  /* This symbol requires a procedure linkage table entry.  We
+	     actually build the entry in adjust_dynamic_symbol,
+	     because this might be a case of linking PIC code which is
+	     never referenced by a dynamic object, in which case we
+	     don't need to generate a procedure linkage table entry
+	     after all.  */
+
+	  /* If this is a local symbol, we resolve it directly without
+	     creating a procedure linkage table entry.  */
+	  if (h == NULL)
+	    continue;
+
+	  h->needs_plt = 1;
+	  h->plt.refcount += 1;
+	  break;
+
+	case R_386_TLS_IE_32:
+	case R_386_TLS_IE:
+	case R_386_TLS_GOTIE:
+	  if (info->shared)
+	    info->flags |= DF_STATIC_TLS;
+	  /* Fall through */
+
+	case R_386_GOT32:
+	case R_386_TLS_GD:
+	case R_386_TLS_GOTDESC:
+	case R_386_TLS_DESC_CALL:
+	  /* This symbol requires a global offset table entry.  */
+	  {
+	    int tls_type, old_tls_type;
+
+	    switch (r_type)
+	      {
+	      default:
+	      case R_386_GOT32: tls_type = GOT_NORMAL; break;
+	      case R_386_TLS_GD: tls_type = GOT_TLS_GD; break;
+	      case R_386_TLS_GOTDESC:
+	      case R_386_TLS_DESC_CALL:
+		tls_type = GOT_TLS_GDESC; break;
+	      case R_386_TLS_IE_32:
+		if (ELF32_R_TYPE (rel->r_info) == r_type)
+		  tls_type = GOT_TLS_IE_NEG;
+		else
+		  /* If this is a GD->IE transition, we may use either of
+		     R_386_TLS_TPOFF and R_386_TLS_TPOFF32.  */
+		  tls_type = GOT_TLS_IE;
+		break;
+	      case R_386_TLS_IE:
+	      case R_386_TLS_GOTIE:
+		tls_type = GOT_TLS_IE_POS; break;
+	      }
+
+	    if (h != NULL)
+	      {
+		h->got.refcount += 1;
+		old_tls_type = elf_i386_hash_entry(h)->tls_type;
+	      }
+	    else
+	      {
+		bfd_signed_vma *local_got_refcounts;
+
+		/* This is a global offset table entry for a local symbol.  */
+		local_got_refcounts = elf_local_got_refcounts (abfd);
+		if (local_got_refcounts == NULL)
+		  {
+		    bfd_size_type size;
+
+		    size = symtab_hdr->sh_info;
+		    size *= (sizeof (bfd_signed_vma)
+			     + sizeof (bfd_vma) + sizeof(char));
+		    local_got_refcounts = bfd_zalloc (abfd, size);
+		    if (local_got_refcounts == NULL)
+		      return FALSE;
+		    elf_local_got_refcounts (abfd) = local_got_refcounts;
+		    elf_i386_local_tlsdesc_gotent (abfd)
+		      = (bfd_vma *) (local_got_refcounts + symtab_hdr->sh_info);
+		    elf_i386_local_got_tls_type (abfd)
+		      = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);
+		  }
+		local_got_refcounts[r_symndx] += 1;
+		old_tls_type = elf_i386_local_got_tls_type (abfd) [r_symndx];
+	      }
+
+	    if ((old_tls_type & GOT_TLS_IE) && (tls_type & GOT_TLS_IE))
+	      tls_type |= old_tls_type;
+	    /* If a TLS symbol is accessed using IE at least once,
+	       there is no point to use dynamic model for it.  */
+	    else if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
+		     && (! GOT_TLS_GD_ANY_P (old_tls_type)
+			 || (tls_type & GOT_TLS_IE) == 0))
+	      {
+		if ((old_tls_type & GOT_TLS_IE) && GOT_TLS_GD_ANY_P (tls_type))
+		  tls_type = old_tls_type;
+		else if (GOT_TLS_GD_ANY_P (old_tls_type)
+			 && GOT_TLS_GD_ANY_P (tls_type))
+		  tls_type |= old_tls_type;
+		else
+		  {
+		    (*_bfd_error_handler)
+		      (_("%B: `%s' accessed both as normal and "
+			 "thread local symbol"),
+		       abfd,
+		       h ? h->root.root.string : "<local>");
+		    return FALSE;
+		  }
+	      }
+
+	    if (old_tls_type != tls_type)
+	      {
+		if (h != NULL)
+		  elf_i386_hash_entry (h)->tls_type = tls_type;
+		else
+		  elf_i386_local_got_tls_type (abfd) [r_symndx] = tls_type;
+	      }
+	  }
+	  /* Fall through */
+
+	case R_386_GOTOFF:
+	case R_386_GOTPC:
+	create_got:
+	  if (htab->sgot == NULL)
+	    {
+	      if (htab->elf.dynobj == NULL)
+		htab->elf.dynobj = abfd;
+	      if (!create_got_section (htab->elf.dynobj, info))
+		return FALSE;
+	    }
+	  if (r_type != R_386_TLS_IE)
+	    break;
+	  /* Fall through */
+
+	case R_386_TLS_LE_32:
+	case R_386_TLS_LE:
+	  if (!info->shared)
+	    break;
+	  info->flags |= DF_STATIC_TLS;
+	  /* Fall through */
+
+	case R_386_32:
+	case R_386_PC32:
+	  if (h != NULL && !info->shared)
+	    {
+	      /* If this reloc is in a read-only section, we might
+		 need a copy reloc.  We can't check reliably at this
+		 stage whether the section is read-only, as input
+		 sections have not yet been mapped to output sections.
+		 Tentatively set the flag for now, and correct in
+		 adjust_dynamic_symbol.  */
+	      h->non_got_ref = 1;
+
+	      /* We may need a .plt entry if the function this reloc
+		 refers to is in a shared lib.  */
+	      h->plt.refcount += 1;
+	      if (r_type != R_386_PC32)
+		h->pointer_equality_needed = 1;
+	    }
+
+	  /* If we are creating a shared library, and this is a reloc
+	     against a global symbol, or a non PC relative reloc
+	     against a local symbol, then we need to copy the reloc
+	     into the shared library.  However, if we are linking with
+	     -Bsymbolic, we do not need to copy a reloc against a
+	     global symbol which is defined in an object we are
+	     including in the link (i.e., DEF_REGULAR is set).  At
+	     this point we have not seen all the input files, so it is
+	     possible that DEF_REGULAR is not set now but will be set
+	     later (it is never cleared).  In case of a weak definition,
+	     DEF_REGULAR may be cleared later by a strong definition in
+	     a shared library.  We account for that possibility below by
+	     storing information in the relocs_copied field of the hash
+	     table entry.  A similar situation occurs when creating
+	     shared libraries and symbol visibility changes render the
+	     symbol local.
+
+	     If on the other hand, we are creating an executable, we
+	     may need to keep relocations for symbols satisfied by a
+	     dynamic library if we manage to avoid copy relocs for the
+	     symbol.  */
+	  if ((info->shared
+	       && (sec->flags & SEC_ALLOC) != 0
+	       && (r_type != R_386_PC32
+		   || (h != NULL
+		       && (! SYMBOLIC_BIND (info, h)
+			   || h->root.type == bfd_link_hash_defweak
+			   || !h->def_regular))))
+	      || (ELIMINATE_COPY_RELOCS
+		  && !info->shared
+		  && (sec->flags & SEC_ALLOC) != 0
+		  && h != NULL
+		  && (h->root.type == bfd_link_hash_defweak
+		      || !h->def_regular)))
+	    {
+	      struct elf_i386_dyn_relocs *p;
+	      struct elf_i386_dyn_relocs **head;
+
+	      /* We must copy these reloc types into the output file.
+		 Create a reloc section in dynobj and make room for
+		 this reloc.  */
+	      if (sreloc == NULL)
+		{
+		  const char *name;
+		  bfd *dynobj;
+		  unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
+		  unsigned int shnam = elf_section_data (sec)->rel_hdr.sh_name;
+
+		  name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
+		  if (name == NULL)
+		    return FALSE;
+
+		  if (! CONST_STRNEQ (name, ".rel")
+		      || strcmp (bfd_get_section_name (abfd, sec),
+				 name + 4) != 0)
+		    {
+		      (*_bfd_error_handler)
+			(_("%B: bad relocation section name `%s\'"),
+			 abfd, name);
+		    }
+
+		  if (htab->elf.dynobj == NULL)
+		    htab->elf.dynobj = abfd;
+
+		  dynobj = htab->elf.dynobj;
+		  sreloc = bfd_get_section_by_name (dynobj, name);
+		  if (sreloc == NULL)
+		    {
+		      flagword flags;
+
+		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
+			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
+		      if ((sec->flags & SEC_ALLOC) != 0)
+			flags |= SEC_ALLOC | SEC_LOAD;
+		      sreloc = bfd_make_section_with_flags (dynobj,
+							    name,
+							    flags);
+		      if (sreloc == NULL
+			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
+			return FALSE;
+		    }
+		  elf_section_data (sec)->sreloc = sreloc;
+		}
+
+	      /* If this is a global symbol, we count the number of
+		 relocations we need for this symbol.  */
+	      if (h != NULL)
+		{
+		  head = &((struct elf_i386_link_hash_entry *) h)->dyn_relocs;
+		}
+	      else
+		{
+		  void **vpp;
+		  /* Track dynamic relocs needed for local syms too.
+		     We really need local syms available to do this
+		     easily.  Oh well.  */
+
+		  asection *s;
+		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
+						 sec, r_symndx);
+		  if (s == NULL)
+		    return FALSE;
+
+		  vpp = &elf_section_data (s)->local_dynrel;
+		  head = (struct elf_i386_dyn_relocs **)vpp;
+		}
+
+	      p = *head;
+	      if (p == NULL || p->sec != sec)
+		{
+		  bfd_size_type amt = sizeof *p;
+		  p = bfd_alloc (htab->elf.dynobj, amt);
+		  if (p == NULL)
+		    return FALSE;
+		  p->next = *head;
+		  *head = p;
+		  p->sec = sec;
+		  p->count = 0;
+		  p->pc_count = 0;
+		}
+
+	      p->count += 1;
+	      if (r_type == R_386_PC32)
+		p->pc_count += 1;
+	    }
+	  break;
+
+	  /* This relocation describes the C++ object vtable hierarchy.
+	     Reconstruct it for later use during GC.  */
+	case R_386_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	  /* This relocation describes which C++ vtable entries are actually
+	     used.  Record for later use during GC.  */
+	case R_386_GNU_VTENTRY:
+	  BFD_ASSERT (h != NULL);
+	  if (h != NULL
+	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+static asection *
+elf_i386_gc_mark_hook (asection *sec,
+		       struct bfd_link_info *info,
+		       Elf_Internal_Rela *rel,
+		       struct elf_link_hash_entry *h,
+		       Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_386_GNU_VTINHERIT:
+      case R_386_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+/* Update the got entry reference counts for the section being removed.  */
+
+static bfd_boolean
+elf_i386_gc_sweep_hook (bfd *abfd,
+			struct bfd_link_info *info,
+			asection *sec,
+			const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  bfd_signed_vma *local_got_refcounts;
+  const Elf_Internal_Rela *rel, *relend;
+
+  if (info->relocatable)
+    return TRUE;
+
+  elf_section_data (sec)->local_dynrel = NULL;
+
+  symtab_hdr = &elf_symtab_hdr (abfd);
+  sym_hashes = elf_sym_hashes (abfd);
+  local_got_refcounts = elf_local_got_refcounts (abfd);
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      unsigned int r_type;
+      struct elf_link_hash_entry *h = NULL;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  struct elf_i386_link_hash_entry *eh;
+	  struct elf_i386_dyn_relocs **pp;
+	  struct elf_i386_dyn_relocs *p;
+
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	  eh = (struct elf_i386_link_hash_entry *) h;
+
+	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
+	    if (p->sec == sec)
+	      {
+		/* Everything must go for SEC.  */
+		*pp = p->next;
+		break;
+	      }
+	}
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      if (! elf_i386_tls_transition (info, abfd, sec, NULL,
+				     symtab_hdr, sym_hashes,
+				     &r_type, GOT_UNKNOWN,
+				     rel, relend, h)) 
+	return FALSE;
+
+      switch (r_type)
+	{
+	case R_386_TLS_LDM:
+	  if (elf_i386_hash_table (info)->tls_ldm_got.refcount > 0)
+	    elf_i386_hash_table (info)->tls_ldm_got.refcount -= 1;
+	  break;
+
+	case R_386_TLS_GD:
+	case R_386_TLS_GOTDESC:
+	case R_386_TLS_DESC_CALL:
+	case R_386_TLS_IE_32:
+	case R_386_TLS_IE:
+	case R_386_TLS_GOTIE:
+	case R_386_GOT32:
+	  if (h != NULL)
+	    {
+	      if (h->got.refcount > 0)
+		h->got.refcount -= 1;
+	    }
+	  else if (local_got_refcounts != NULL)
+	    {
+	      if (local_got_refcounts[r_symndx] > 0)
+		local_got_refcounts[r_symndx] -= 1;
+	    }
+	  break;
+
+	case R_386_32:
+	case R_386_PC32:
+	  if (info->shared)
+	    break;
+	  /* Fall through */
+
+	case R_386_PLT32:
+	  if (h != NULL)
+	    {
+	      if (h->plt.refcount > 0)
+		h->plt.refcount -= 1;
+	    }
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+elf_i386_adjust_dynamic_symbol (struct bfd_link_info *info,
+				struct elf_link_hash_entry *h)
+{
+  struct elf_i386_link_hash_table *htab;
+  asection *s;
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (h->plt.refcount <= 0
+	  || SYMBOL_CALLS_LOCAL (info, h)
+	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
+	      && h->root.type == bfd_link_hash_undefweak))
+	{
+	  /* This case can occur if we saw a PLT32 reloc in an input
+	     file, but the symbol was never referred to by a dynamic
+	     object, or if all references were garbage collected.  In
+	     such a case, we don't actually need to build a procedure
+	     linkage table, and we can just do a PC32 reloc instead.  */
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+
+      return TRUE;
+    }
+  else
+    /* It's possible that we incorrectly decided a .plt reloc was
+       needed for an R_386_PC32 reloc to a non-function sym in
+       check_relocs.  We can't decide accurately between function and
+       non-function syms in check-relocs;  Objects loaded later in
+       the link may change h->type.  So fix it now.  */
+    h->plt.offset = (bfd_vma) -1;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
+		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
+	h->non_got_ref = h->u.weakdef->non_got_ref;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  htab = elf_i386_hash_table (info);
+
+  /* If there aren't any dynamic relocs in read-only sections, then
+     we can keep the dynamic relocs and avoid the copy reloc.  This
+     doesn't work on VxWorks, where we can not have dynamic relocations
+     (other than copy and jump slot relocations) in an executable.  */
+  if (ELIMINATE_COPY_RELOCS && !htab->is_vxworks)
+    {
+      struct elf_i386_link_hash_entry * eh;
+      struct elf_i386_dyn_relocs *p;
+
+      eh = (struct elf_i386_link_hash_entry *) h;
+      for (p = eh->dyn_relocs; p != NULL; p = p->next)
+	{
+	  s = p->sec->output_section;
+	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	    break;
+	}
+
+      if (p == NULL)
+	{
+	  h->non_got_ref = 0;
+	  return TRUE;
+	}
+    }
+
+  if (h->size == 0)
+    {
+      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
+			     h->root.root.string);
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  /* We must generate a R_386_COPY reloc to tell the dynamic linker to
+     copy the initial value out of the dynamic object and into the
+     runtime process image.  */
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      htab->srelbss->size += sizeof (Elf32_External_Rel);
+      h->needs_copy = 1;
+    }
+
+  s = htab->sdynbss;
+
+  return _bfd_elf_adjust_dynamic_copy (h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bfd_boolean
+allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+{
+  struct bfd_link_info *info;
+  struct elf_i386_link_hash_table *htab;
+  struct elf_i386_link_hash_entry *eh;
+  struct elf_i386_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  if (h->root.type == bfd_link_hash_warning)
+    /* When warning symbols are created, they **replace** the "real"
+       entry in the hash table, thus we never get to see the real
+       symbol in a hash traversal.  So look at it now.  */
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  info = (struct bfd_link_info *) inf;
+  htab = elf_i386_hash_table (info);
+
+  if (htab->elf.dynamic_sections_created
+      && h->plt.refcount > 0)
+    {
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      if (info->shared
+	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
+	{
+	  asection *s = htab->splt;
+
+	  /* If this is the first .plt entry, make room for the special
+	     first entry.  */
+	  if (s->size == 0)
+	    s->size += PLT_ENTRY_SIZE;
+
+	  h->plt.offset = s->size;
+
+	  /* If this symbol is not defined in a regular file, and we are
+	     not generating a shared library, then set the symbol to this
+	     location in the .plt.  This is required to make function
+	     pointers compare as equal between the normal executable and
+	     the shared library.  */
+	  if (! info->shared
+	      && !h->def_regular)
+	    {
+	      h->root.u.def.section = s;
+	      h->root.u.def.value = h->plt.offset;
+	    }
+
+	  /* Make room for this entry.  */
+	  s->size += PLT_ENTRY_SIZE;
+
+	  /* We also need to make an entry in the .got.plt section, which
+	     will be placed in the .got section by the linker script.  */
+	  htab->sgotplt->size += 4;
+
+	  /* We also need to make an entry in the .rel.plt section.  */
+	  htab->srelplt->size += sizeof (Elf32_External_Rel);
+	  htab->next_tls_desc_index++;
+
+	  if (htab->is_vxworks && !info->shared)
+	    {
+	      /* VxWorks has a second set of relocations for each PLT entry
+		 in executables.  They go in a separate relocation section,
+		 which is processed by the kernel loader.  */
+
+	      /* There are two relocations for the initial PLT entry: an
+		 R_386_32 relocation for _GLOBAL_OFFSET_TABLE_ + 4 and an
+		 R_386_32 relocation for _GLOBAL_OFFSET_TABLE_ + 8.  */
+
+	      if (h->plt.offset == PLT_ENTRY_SIZE)
+		htab->srelplt2->size += (sizeof (Elf32_External_Rel) * 2);
+
+	      /* There are two extra relocations for each subsequent PLT entry:
+		 an R_386_32 relocation for the GOT entry, and an R_386_32
+		 relocation for the PLT entry.  */
+
+	      htab->srelplt2->size += (sizeof (Elf32_External_Rel) * 2);
+	    }
+	}
+      else
+	{
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+    }
+  else
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->needs_plt = 0;
+    }
+
+  eh = (struct elf_i386_link_hash_entry *) h;
+  eh->tlsdesc_got = (bfd_vma) -1;
+
+  /* If R_386_TLS_{IE_32,IE,GOTIE} symbol is now local to the binary,
+     make it a R_386_TLS_LE_32 requiring no TLS entry.  */
+  if (h->got.refcount > 0
+      && !info->shared
+      && h->dynindx == -1
+      && (elf_i386_hash_entry(h)->tls_type & GOT_TLS_IE))
+    h->got.offset = (bfd_vma) -1;
+  else if (h->got.refcount > 0)
+    {
+      asection *s;
+      bfd_boolean dyn;
+      int tls_type = elf_i386_hash_entry(h)->tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      s = htab->sgot;
+      if (GOT_TLS_GDESC_P (tls_type))
+	{
+	  eh->tlsdesc_got = htab->sgotplt->size
+	    - elf_i386_compute_jump_table_size (htab);
+	  htab->sgotplt->size += 8;
+	  h->got.offset = (bfd_vma) -2;
+	}
+      if (! GOT_TLS_GDESC_P (tls_type)
+	  || GOT_TLS_GD_P (tls_type))
+	{
+	  h->got.offset = s->size;
+	  s->size += 4;
+	  /* R_386_TLS_GD needs 2 consecutive GOT slots.  */
+	  if (GOT_TLS_GD_P (tls_type) || tls_type == GOT_TLS_IE_BOTH)
+	    s->size += 4;
+	}
+      dyn = htab->elf.dynamic_sections_created;
+      /* R_386_TLS_IE_32 needs one dynamic relocation,
+	 R_386_TLS_IE resp. R_386_TLS_GOTIE needs one dynamic relocation,
+	 (but if both R_386_TLS_IE_32 and R_386_TLS_IE is present, we
+	 need two), R_386_TLS_GD needs one if local symbol and two if
+	 global.  */
+      if (tls_type == GOT_TLS_IE_BOTH)
+	htab->srelgot->size += 2 * sizeof (Elf32_External_Rel);
+      else if ((GOT_TLS_GD_P (tls_type) && h->dynindx == -1)
+	       || (tls_type & GOT_TLS_IE))
+	htab->srelgot->size += sizeof (Elf32_External_Rel);
+      else if (GOT_TLS_GD_P (tls_type))
+	htab->srelgot->size += 2 * sizeof (Elf32_External_Rel);
+      else if (! GOT_TLS_GDESC_P (tls_type)
+	       && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+		   || h->root.type != bfd_link_hash_undefweak)
+	       && (info->shared
+		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
+	htab->srelgot->size += sizeof (Elf32_External_Rel);
+      if (GOT_TLS_GDESC_P (tls_type))
+	htab->srelplt->size += sizeof (Elf32_External_Rel);
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  if (eh->dyn_relocs == NULL)
+    return TRUE;
+
+  /* In the shared -Bsymbolic case, discard space allocated for
+     dynamic pc-relative relocs against symbols which turn out to be
+     defined in regular objects.  For the normal shared case, discard
+     space for pc-relative relocs that have become local due to symbol
+     visibility changes.  */
+
+  if (info->shared)
+    {
+      /* The only reloc that uses pc_count is R_386_PC32, which will
+	 appear on a call or on something like ".long foo - .".  We
+	 want calls to protected symbols to resolve directly to the
+	 function rather than going via the plt.  If people want
+	 function pointer comparisons to work as expected then they
+	 should avoid writing assembly like ".long foo - .".  */
+      if (SYMBOL_CALLS_LOCAL (info, h))
+	{
+	  struct elf_i386_dyn_relocs **pp;
+
+	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
+	    {
+	      p->count -= p->pc_count;
+	      p->pc_count = 0;
+	      if (p->count == 0)
+		*pp = p->next;
+	      else
+		pp = &p->next;
+	    }
+	}
+
+      /* Also discard relocs on undefined weak syms with non-default
+	 visibility.  */
+      if (eh->dyn_relocs != NULL
+	  && h->root.type == bfd_link_hash_undefweak)
+	{
+	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
+	    eh->dyn_relocs = NULL;
+
+	  /* Make sure undefined weak symbols are output as a dynamic
+	     symbol in PIEs.  */
+	  else if (h->dynindx == -1
+		   && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+	}
+    }
+  else if (ELIMINATE_COPY_RELOCS)
+    {
+      /* For the non-shared case, discard space for relocs against
+	 symbols which turn out to need copy relocs or are not
+	 dynamic.  */
+
+      if (!h->non_got_ref
+	  && ((h->def_dynamic
+	       && !h->def_regular)
+	      || (htab->elf.dynamic_sections_created
+		  && (h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined))))
+	{
+	  /* Make sure this symbol is output as a dynamic symbol.
+	     Undefined weak syms won't yet be marked as dynamic.  */
+	  if (h->dynindx == -1
+	      && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+
+	  /* If that succeeded, we know we'll be keeping all the
+	     relocs.  */
+	  if (h->dynindx != -1)
+	    goto keep;
+	}
+
+      eh->dyn_relocs = NULL;
+
+    keep: ;
+    }
+
+  /* Finally, allocate space.  */
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (Elf32_External_Rel);
+    }
+
+  return TRUE;
+}
+
+/* Find any dynamic relocs that apply to read-only sections.  */
+
+static bfd_boolean
+readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+{
+  struct elf_i386_link_hash_entry *eh;
+  struct elf_i386_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  eh = (struct elf_i386_link_hash_entry *) h;
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	{
+	  struct bfd_link_info *info = (struct bfd_link_info *) inf;
+
+	  info->flags |= DF_TEXTREL;
+
+	  /* Not an error, just cut short the traversal.  */
+	  return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+/* Set the sizes of the dynamic sections.  */
+
+static bfd_boolean
+elf_i386_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
+				struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean relocs;
+  bfd *ibfd;
+
+  htab = elf_i386_hash_table (info);
+  dynobj = htab->elf.dynobj;
+  if (dynobj == NULL)
+    abort ();
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (info->executable)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  if (s == NULL)
+	    abort ();
+	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
+	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      char *local_tls_type;
+      bfd_vma *local_tlsdesc_gotent;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      asection *srel;
+
+      if (! is_i386_elf (ibfd))
+	continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+	{
+	  struct elf_i386_dyn_relocs *p;
+
+	  for (p = ((struct elf_i386_dyn_relocs *)
+		     elf_section_data (s)->local_dynrel);
+	       p != NULL;
+	       p = p->next)
+	    {
+	      if (!bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (p->count != 0)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (Elf32_External_Rel);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_symtab_hdr (ibfd);
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      local_tls_type = elf_i386_local_got_tls_type (ibfd);
+      local_tlsdesc_gotent = elf_i386_local_tlsdesc_gotent (ibfd);
+      s = htab->sgot;
+      srel = htab->srelgot;
+      for (; local_got < end_local_got;
+	   ++local_got, ++local_tls_type, ++local_tlsdesc_gotent)
+	{
+	  *local_tlsdesc_gotent = (bfd_vma) -1;
+	  if (*local_got > 0)
+	    {
+	      if (GOT_TLS_GDESC_P (*local_tls_type))
+		{
+		  *local_tlsdesc_gotent = htab->sgotplt->size
+		    - elf_i386_compute_jump_table_size (htab);
+		  htab->sgotplt->size += 8;
+		  *local_got = (bfd_vma) -2;
+		}
+	      if (! GOT_TLS_GDESC_P (*local_tls_type)
+		  || GOT_TLS_GD_P (*local_tls_type))
+		{
+		  *local_got = s->size;
+		  s->size += 4;
+		  if (GOT_TLS_GD_P (*local_tls_type)
+		      || *local_tls_type == GOT_TLS_IE_BOTH)
+		    s->size += 4;
+		}
+	      if (info->shared
+		  || GOT_TLS_GD_ANY_P (*local_tls_type)
+		  || (*local_tls_type & GOT_TLS_IE))
+		{
+		  if (*local_tls_type == GOT_TLS_IE_BOTH)
+		    srel->size += 2 * sizeof (Elf32_External_Rel);
+		  else if (GOT_TLS_GD_P (*local_tls_type)
+			   || ! GOT_TLS_GDESC_P (*local_tls_type))
+		    srel->size += sizeof (Elf32_External_Rel);
+		  if (GOT_TLS_GDESC_P (*local_tls_type))
+		    htab->srelplt->size += sizeof (Elf32_External_Rel);
+		}
+	    }
+	  else
+	    *local_got = (bfd_vma) -1;
+	}
+    }
+
+  if (htab->tls_ldm_got.refcount > 0)
+    {
+      /* Allocate 2 got entries and 1 dynamic reloc for R_386_TLS_LDM
+	 relocs.  */
+      htab->tls_ldm_got.offset = htab->sgot->size;
+      htab->sgot->size += 8;
+      htab->srelgot->size += sizeof (Elf32_External_Rel);
+    }
+  else
+    htab->tls_ldm_got.offset = -1;
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
+
+  /* For every jump slot reserved in the sgotplt, reloc_count is
+     incremented.  However, when we reserve space for TLS descriptors,
+     it's not incremented, so in order to compute the space reserved
+     for them, it suffices to multiply the reloc count by the jump
+     slot size.  */
+  if (htab->srelplt)
+    htab->sgotplt_jump_table_size = htab->next_tls_desc_index * 4;
+
+  /* We now have determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  relocs = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      bfd_boolean strip_section = TRUE;
+
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->splt
+	  || s == htab->sgot
+	  || s == htab->sgotplt
+	  || s == htab->sdynbss)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	  /* We'd like to strip these sections if they aren't needed, but if
+	     we've exported dynamic symbols from them we must leave them.
+	     It's too late to tell BFD to get rid of the symbols.  */
+
+	  if (htab->elf.hplt != NULL)
+	    strip_section = FALSE;
+	}
+      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rel"))
+	{
+	  if (s->size != 0 && s != htab->srelplt && s != htab->srelplt2)
+	    relocs = TRUE;
+
+	  /* We use the reloc_count field as a counter if we need
+	     to copy relocs into the output file.  */
+	  s->reloc_count = 0;
+	}
+      else
+	{
+	  /* It's not one of our sections, so don't allocate space.  */
+	  continue;
+	}
+
+      if (s->size == 0)
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rel.bss and
+	     .rel.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  if (strip_section)
+	    s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  We use bfd_zalloc
+	 here in case unused entries are not reclaimed before the
+	 section's contents are written out.  This should not happen,
+	 but this way if it does, we get a R_386_NONE reloc instead
+	 of garbage.  */
+      s->contents = bfd_zalloc (dynobj, s->size);
+      if (s->contents == NULL)
+	return FALSE;
+    }
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in elf_i386_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+      if (info->executable)
+	{
+	  if (!add_dynamic_entry (DT_DEBUG, 0))
+	    return FALSE;
+	}
+
+      if (htab->splt->size != 0)
+	{
+	  if (!add_dynamic_entry (DT_PLTGOT, 0)
+	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
+	      || !add_dynamic_entry (DT_PLTREL, DT_REL)
+	      || !add_dynamic_entry (DT_JMPREL, 0))
+	    return FALSE;
+	}
+
+      if (relocs)
+	{
+	  if (!add_dynamic_entry (DT_REL, 0)
+	      || !add_dynamic_entry (DT_RELSZ, 0)
+	      || !add_dynamic_entry (DT_RELENT, sizeof (Elf32_External_Rel)))
+	    return FALSE;
+
+	  /* If any dynamic relocs apply to a read-only section,
+	     then we need a DT_TEXTREL entry.  */
+	  if ((info->flags & DF_TEXTREL) == 0)
+	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
+				    (PTR) info);
+
+	  if ((info->flags & DF_TEXTREL) != 0)
+	    {
+	      if (!add_dynamic_entry (DT_TEXTREL, 0))
+		return FALSE;
+	    }
+	}
+      if (htab->is_vxworks
+	  && !elf_vxworks_add_dynamic_entries (output_bfd, info))
+	return FALSE;
+    }
+#undef add_dynamic_entry
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf_i386_always_size_sections (bfd *output_bfd,
+			       struct bfd_link_info *info)
+{
+  asection *tls_sec = elf_hash_table (info)->tls_sec;
+
+  if (tls_sec)
+    {
+      struct elf_link_hash_entry *tlsbase;
+
+      tlsbase = elf_link_hash_lookup (elf_hash_table (info),
+				      "_TLS_MODULE_BASE_",
+				      FALSE, FALSE, FALSE);
+
+      if (tlsbase && tlsbase->type == STT_TLS)
+	{
+	  struct bfd_link_hash_entry *bh = NULL;
+	  const struct elf_backend_data *bed
+	    = get_elf_backend_data (output_bfd);
+
+	  if (!(_bfd_generic_link_add_one_symbol
+		(info, output_bfd, "_TLS_MODULE_BASE_", BSF_LOCAL,
+		 tls_sec, 0, NULL, FALSE,
+		 bed->collect, &bh)))
+	    return FALSE;
+	  tlsbase = (struct elf_link_hash_entry *)bh;
+	  tlsbase->def_regular = 1;
+	  tlsbase->other = STV_HIDDEN;
+	  (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
+	}
+    }
+
+  return TRUE;
+}
+
+/* Set the correct type for an x86 ELF section.  We do this by the
+   section name, which is a hack, but ought to work.  */
+
+static bfd_boolean
+elf_i386_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
+			Elf_Internal_Shdr *hdr,
+			asection *sec)
+{
+  register const char *name;
+
+  name = bfd_get_section_name (abfd, sec);
+
+  /* This is an ugly, but unfortunately necessary hack that is
+     needed when producing EFI binaries on x86. It tells
+     elf.c:elf_fake_sections() not to consider ".reloc" as a section
+     containing ELF relocation info.  We need this hack in order to
+     be able to generate ELF binaries that can be translated into
+     EFI applications (which are essentially COFF objects).  Those
+     files contain a COFF ".reloc" section inside an ELFNN object,
+     which would normally cause BFD to segfault because it would
+     attempt to interpret this section as containing relocation
+     entries for section "oc".  With this hack enabled, ".reloc"
+     will be treated as a normal data section, which will avoid the
+     segfault.  However, you won't be able to create an ELFNN binary
+     with a section named "oc" that needs relocations, but that's
+     the kind of ugly side-effects you get when detecting section
+     types based on their names...  In practice, this limitation is
+     unlikely to bite.  */
+  if (strcmp (name, ".reloc") == 0)
+    hdr->sh_type = SHT_PROGBITS;
+
+  return TRUE;
+}
+
+/* Return the base VMA address which should be subtracted from real addresses
+   when resolving @dtpoff relocation.
+   This is PT_TLS segment p_vaddr.  */
+
+static bfd_vma
+dtpoff_base (struct bfd_link_info *info)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return elf_hash_table (info)->tls_sec->vma;
+}
+
+/* Return the relocation value for @tpoff relocation
+   if STT_TLS virtual address is ADDRESS.  */
+
+static bfd_vma
+tpoff (struct bfd_link_info *info, bfd_vma address)
+{
+  struct elf_link_hash_table *htab = elf_hash_table (info);
+
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (htab->tls_sec == NULL)
+    return 0;
+  return htab->tls_size + htab->tls_sec->vma - address;
+}
+
+/* Relocate an i386 ELF section.  */
+
+static bfd_boolean
+elf_i386_relocate_section (bfd *output_bfd,
+			   struct bfd_link_info *info,
+			   bfd *input_bfd,
+			   asection *input_section,
+			   bfd_byte *contents,
+			   Elf_Internal_Rela *relocs,
+			   Elf_Internal_Sym *local_syms,
+			   asection **local_sections)
+{
+  struct elf_i386_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  bfd_vma *local_got_offsets;
+  bfd_vma *local_tlsdesc_gotents;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+
+  BFD_ASSERT (is_i386_elf (input_bfd));
+  
+  htab = elf_i386_hash_table (info);
+  symtab_hdr = &elf_symtab_hdr (input_bfd);
+  sym_hashes = elf_sym_hashes (input_bfd);
+  local_got_offsets = elf_local_got_offsets (input_bfd);
+  local_tlsdesc_gotents = elf_i386_local_tlsdesc_gotent (input_bfd);
+
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      unsigned int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      bfd_vma off, offplt;
+      bfd_vma relocation;
+      bfd_boolean unresolved_reloc;
+      bfd_reloc_status_type r;
+      unsigned int indx;
+      int tls_type;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      if (r_type == R_386_GNU_VTINHERIT
+	  || r_type == R_386_GNU_VTENTRY)
+	continue;
+
+      if ((indx = r_type) >= R_386_standard
+	  && ((indx = r_type - R_386_ext_offset) - R_386_standard
+	      >= R_386_ext - R_386_standard)
+	  && ((indx = r_type - R_386_tls_offset) - R_386_ext
+	      >= R_386_tls - R_386_ext))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: unrecognized relocation (0x%x) in section `%A'"),
+	     input_bfd, input_section, r_type);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+      howto = elf_howto_table + indx;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      unresolved_reloc = FALSE;
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = (sec->output_section->vma
+			+ sec->output_offset
+			+ sym->st_value);
+
+	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION
+	      && ((sec->flags & SEC_MERGE) != 0
+		  || (info->relocatable
+		      && sec->output_offset != 0)))
+	    {
+	      bfd_vma addend;
+	      bfd_byte *where = contents + rel->r_offset;
+
+	      switch (howto->size)
+		{
+		case 0:
+		  addend = bfd_get_8 (input_bfd, where);
+		  if (howto->pc_relative)
+		    {
+		      addend = (addend ^ 0x80) - 0x80;
+		      addend += 1;
+		    }
+		  break;
+		case 1:
+		  addend = bfd_get_16 (input_bfd, where);
+		  if (howto->pc_relative)
+		    {
+		      addend = (addend ^ 0x8000) - 0x8000;
+		      addend += 2;
+		    }
+		  break;
+		case 2:
+		  addend = bfd_get_32 (input_bfd, where);
+		  if (howto->pc_relative)
+		    {
+		      addend = (addend ^ 0x80000000) - 0x80000000;
+		      addend += 4;
+		    }
+		  break;
+		default:
+		  abort ();
+		}
+
+	      if (info->relocatable)
+		addend += sec->output_offset;
+	      else
+		{
+		  asection *msec = sec;
+		  addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec,
+						   addend);
+		  addend -= relocation;
+		  addend += msec->output_section->vma + msec->output_offset;
+		}
+
+	      switch (howto->size)
+		{
+		case 0:
+		  /* FIXME: overflow checks.  */
+		  if (howto->pc_relative)
+		    addend -= 1;
+		  bfd_put_8 (input_bfd, addend, where);
+		  break;
+		case 1:
+		  if (howto->pc_relative)
+		    addend -= 2;
+		  bfd_put_16 (input_bfd, addend, where);
+		  break;
+		case 2:
+		  if (howto->pc_relative)
+		    addend -= 4;
+		  bfd_put_32 (input_bfd, addend, where);
+		  break;
+		}
+	    }
+	}
+      else
+	{
+	  bfd_boolean warned;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned);
+	}
+
+      if (sec != NULL && elf_discarded_section (sec))
+	{
+	  /* For relocs against symbols from removed linkonce sections,
+	     or sections discarded by a linker script, we just want the
+	     section contents zeroed.  Avoid any special processing.  */
+	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
+	  rel->r_info = 0;
+	  rel->r_addend = 0;
+	  continue;
+	}
+
+      if (info->relocatable)
+	continue;
+
+      switch (r_type)
+	{
+	case R_386_GOT32:
+	  /* Relocation is to the entry for this symbol in the global
+	     offset table.  */
+	  if (htab->sgot == NULL)
+	    abort ();
+
+	  if (h != NULL)
+	    {
+	      bfd_boolean dyn;
+
+	      off = h->got.offset;
+	      dyn = htab->elf.dynamic_sections_created;
+	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
+		  || (info->shared
+		      && SYMBOL_REFERENCES_LOCAL (info, h))
+		  || (ELF_ST_VISIBILITY (h->other)
+		      && h->root.type == bfd_link_hash_undefweak))
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local
+		     because of a version file.  We must initialize
+		     this entry in the global offset table.  Since the
+		     offset must always be a multiple of 4, we use the
+		     least significant bit to record whether we have
+		     initialized it already.
+
+		     When doing a dynamic link, we create a .rel.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      bfd_put_32 (output_bfd, relocation,
+				  htab->sgot->contents + off);
+		      h->got.offset |= 1;
+		    }
+		}
+	      else
+		unresolved_reloc = FALSE;
+	    }
+	  else
+	    {
+	      if (local_got_offsets == NULL)
+		abort ();
+
+	      off = local_got_offsets[r_symndx];
+
+	      /* The offset must always be a multiple of 4.  We use
+		 the least significant bit to record whether we have
+		 already generated the necessary reloc.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  bfd_put_32 (output_bfd, relocation,
+			      htab->sgot->contents + off);
+
+		  if (info->shared)
+		    {
+		      asection *s;
+		      Elf_Internal_Rela outrel;
+		      bfd_byte *loc;
+
+		      s = htab->srelgot;
+		      if (s == NULL)
+			abort ();
+
+		      outrel.r_offset = (htab->sgot->output_section->vma
+					 + htab->sgot->output_offset
+					 + off);
+		      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+		      loc = s->contents;
+		      loc += s->reloc_count++ * sizeof (Elf32_External_Rel);
+		      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		    }
+
+		  local_got_offsets[r_symndx] |= 1;
+		}
+	    }
+
+	  if (off >= (bfd_vma) -2)
+	    abort ();
+
+	  relocation = htab->sgot->output_section->vma
+		       + htab->sgot->output_offset + off
+		       - htab->sgotplt->output_section->vma
+		       - htab->sgotplt->output_offset;
+	  break;
+
+	case R_386_GOTOFF:
+	  /* Relocation is relative to the start of the global offset
+	     table.  */
+
+	  /* Check to make sure it isn't a protected function symbol
+	     for shared library since it may not be local when used
+	     as function address.  */
+	  if (info->shared
+	      && !info->executable
+	      && h
+	      && h->def_regular
+	      && h->type == STT_FUNC
+	      && ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: relocation R_386_GOTOFF against protected function `%s' can not be used when making a shared object"),
+		 input_bfd, h->root.root.string);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
+
+	  /* Note that sgot is not involved in this
+	     calculation.  We always want the start of .got.plt.  If we
+	     defined _GLOBAL_OFFSET_TABLE_ in a different way, as is
+	     permitted by the ABI, we might have to change this
+	     calculation.  */
+	  relocation -= htab->sgotplt->output_section->vma
+			+ htab->sgotplt->output_offset;
+	  break;
+
+	case R_386_GOTPC:
+	  /* Use global offset table as symbol value.  */
+	  relocation = htab->sgotplt->output_section->vma
+		       + htab->sgotplt->output_offset;
+	  unresolved_reloc = FALSE;
+	  break;
+
+	case R_386_PLT32:
+	  /* Relocation is to the entry for this symbol in the
+	     procedure linkage table.  */
+
+	  /* Resolve a PLT32 reloc against a local symbol directly,
+	     without using the procedure linkage table.  */
+	  if (h == NULL)
+	    break;
+
+	  if (h->plt.offset == (bfd_vma) -1
+	      || htab->splt == NULL)
+	    {
+	      /* We didn't make a PLT entry for this symbol.  This
+		 happens when statically linking PIC code, or when
+		 using -Bsymbolic.  */
+	      break;
+	    }
+
+	  relocation = (htab->splt->output_section->vma
+			+ htab->splt->output_offset
+			+ h->plt.offset);
+	  unresolved_reloc = FALSE;
+	  break;
+
+	case R_386_32:
+	case R_386_PC32:
+	  if ((input_section->flags & SEC_ALLOC) == 0)
+	    break;
+
+	  if ((info->shared
+	       && (h == NULL
+		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+		   || h->root.type != bfd_link_hash_undefweak)
+	       && (r_type != R_386_PC32
+		   || !SYMBOL_CALLS_LOCAL (info, h)))
+	      || (ELIMINATE_COPY_RELOCS
+		  && !info->shared
+		  && h != NULL
+		  && h->dynindx != -1
+		  && !h->non_got_ref
+		  && ((h->def_dynamic
+		       && !h->def_regular)
+		      || h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined)))
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+	      bfd_boolean skip, relocate;
+	      asection *sreloc;
+
+	      /* When generating a shared object, these relocations
+		 are copied into the output file to be resolved at run
+		 time.  */
+
+	      skip = FALSE;
+	      relocate = FALSE;
+
+	      outrel.r_offset =
+		_bfd_elf_section_offset (output_bfd, info, input_section,
+					 rel->r_offset);
+	      if (outrel.r_offset == (bfd_vma) -1)
+		skip = TRUE;
+	      else if (outrel.r_offset == (bfd_vma) -2)
+		skip = TRUE, relocate = TRUE;
+	      outrel.r_offset += (input_section->output_section->vma
+				  + input_section->output_offset);
+
+	      if (skip)
+		memset (&outrel, 0, sizeof outrel);
+	      else if (h != NULL
+		       && h->dynindx != -1
+		       && (r_type == R_386_PC32
+			   || !info->shared
+			   || !SYMBOLIC_BIND (info, h)
+			   || !h->def_regular))
+		outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+	      else
+		{
+		  /* This symbol is local, or marked to become local.  */
+		  relocate = TRUE;
+		  outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+		}
+
+	      sreloc = elf_section_data (input_section)->sreloc;
+	      if (sreloc == NULL)
+		abort ();
+
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+
+	      /* If this reloc is against an external symbol, we do
+		 not want to fiddle with the addend.  Otherwise, we
+		 need to include the symbol value so that it becomes
+		 an addend for the dynamic reloc.  */
+	      if (! relocate)
+		continue;
+	    }
+	  break;
+
+	case R_386_TLS_IE:
+	  if (info->shared)
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+	      asection *sreloc;
+
+	      outrel.r_offset = rel->r_offset
+				+ input_section->output_section->vma
+				+ input_section->output_offset;
+	      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+	      sreloc = elf_section_data (input_section)->sreloc;
+	      if (sreloc == NULL)
+		abort ();
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+	    }
+	  /* Fall through */
+
+	case R_386_TLS_GD:
+	case R_386_TLS_GOTDESC:
+	case R_386_TLS_DESC_CALL:
+	case R_386_TLS_IE_32:
+	case R_386_TLS_GOTIE:
+	  tls_type = GOT_UNKNOWN;
+	  if (h == NULL && local_got_offsets)
+	    tls_type = elf_i386_local_got_tls_type (input_bfd) [r_symndx];
+	  else if (h != NULL)
+	    tls_type = elf_i386_hash_entry(h)->tls_type;
+	  if (tls_type == GOT_TLS_IE)
+	    tls_type = GOT_TLS_IE_NEG;
+
+	  if (! elf_i386_tls_transition (info, input_bfd,
+					 input_section, contents,
+					 symtab_hdr, sym_hashes,
+					 &r_type, tls_type, rel,
+					 relend, h))
+	    return FALSE;
+
+	  if (r_type == R_386_TLS_LE_32)
+	    {
+	      BFD_ASSERT (! unresolved_reloc);
+	      if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GD)
+		{
+		  unsigned int type;
+		  bfd_vma roff;
+
+		  /* GD->LE transition.  */
+		  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
+		  if (type == 0x04)
+		    {
+		      /* leal foo(,%reg,1), %eax; call ___tls_get_addr
+			 Change it into:
+			 movl %gs:0, %eax; subl $foo@tpoff, %eax
+			 (6 byte form of subl).  */
+		      memcpy (contents + rel->r_offset - 3,
+			      "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
+		      roff = rel->r_offset + 5;
+		    }
+		  else
+		    {
+		      /* leal foo(%reg), %eax; call ___tls_get_addr; nop
+			 Change it into:
+			 movl %gs:0, %eax; subl $foo@tpoff, %eax
+			 (6 byte form of subl).  */
+		      memcpy (contents + rel->r_offset - 2,
+			      "\x65\xa1\0\0\0\0\x81\xe8\0\0\0", 12);
+		      roff = rel->r_offset + 6;
+		    }
+		  bfd_put_32 (output_bfd, tpoff (info, relocation),
+			      contents + roff);
+		  /* Skip R_386_PC32/R_386_PLT32.  */
+		  rel++;
+		  continue;
+		}
+	      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTDESC)
+		{
+		  /* GDesc -> LE transition.
+		     It's originally something like:
+		     leal x@tlsdesc(%ebx), %eax
+
+		     leal x@ntpoff, %eax
+
+		     Registers other than %eax may be set up here.  */
+
+		  unsigned int val;
+		  bfd_vma roff;
+
+		  roff = rel->r_offset;
+		  val = bfd_get_8 (input_bfd, contents + roff - 1);
+
+		  /* Now modify the instruction as appropriate.  */
+		  /* aoliva FIXME: remove the above and xor the byte
+		     below with 0x86.  */
+		  bfd_put_8 (output_bfd, val ^ 0x86,
+			     contents + roff - 1);
+		  bfd_put_32 (output_bfd, -tpoff (info, relocation),
+			      contents + roff);
+		  continue;
+		}
+	      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_DESC_CALL)
+		{
+		  /* GDesc -> LE transition.
+		     It's originally:
+		     call *(%eax)
+		     Turn it into:
+		     xchg %ax,%ax  */
+
+		  bfd_vma roff;
+		  
+		  roff = rel->r_offset;
+		  bfd_put_8 (output_bfd, 0x66, contents + roff);
+		  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);
+		  continue;
+		}
+	      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_IE)
+		{
+		  unsigned int val;
+
+		  /* IE->LE transition:
+		     Originally it can be one of:
+		     movl foo, %eax
+		     movl foo, %reg
+		     addl foo, %reg
+		     We change it into:
+		     movl $foo, %eax
+		     movl $foo, %reg
+		     addl $foo, %reg.  */
+		  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
+		  if (val == 0xa1)
+		    {
+		      /* movl foo, %eax.  */
+		      bfd_put_8 (output_bfd, 0xb8,
+				 contents + rel->r_offset - 1);
+		    }
+		  else
+		    {
+		      unsigned int type;
+
+		      type = bfd_get_8 (input_bfd,
+					contents + rel->r_offset - 2);
+		      switch (type)
+			{
+			case 0x8b:
+			  /* movl */
+			  bfd_put_8 (output_bfd, 0xc7,
+				     contents + rel->r_offset - 2);
+			  bfd_put_8 (output_bfd,
+				     0xc0 | ((val >> 3) & 7),
+				     contents + rel->r_offset - 1);
+			  break;
+			case 0x03:
+			  /* addl */
+			  bfd_put_8 (output_bfd, 0x81,
+				     contents + rel->r_offset - 2);
+			  bfd_put_8 (output_bfd,
+				     0xc0 | ((val >> 3) & 7),
+				     contents + rel->r_offset - 1);
+			  break;
+			default:
+			  BFD_FAIL ();
+			  break;
+			}
+		    }
+		  bfd_put_32 (output_bfd, -tpoff (info, relocation),
+			      contents + rel->r_offset);
+		  continue;
+		}
+	      else
+		{
+		  unsigned int val, type;
+
+		  /* {IE_32,GOTIE}->LE transition:
+		     Originally it can be one of:
+		     subl foo(%reg1), %reg2
+		     movl foo(%reg1), %reg2
+		     addl foo(%reg1), %reg2
+		     We change it into:
+		     subl $foo, %reg2
+		     movl $foo, %reg2 (6 byte form)
+		     addl $foo, %reg2.  */
+		  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
+		  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
+		  if (type == 0x8b)
+		    {
+		      /* movl */
+		      bfd_put_8 (output_bfd, 0xc7,
+				 contents + rel->r_offset - 2);
+		      bfd_put_8 (output_bfd, 0xc0 | ((val >> 3) & 7),
+				 contents + rel->r_offset - 1);
+		    }
+		  else if (type == 0x2b)
+		    {
+		      /* subl */
+		      bfd_put_8 (output_bfd, 0x81,
+				 contents + rel->r_offset - 2);
+		      bfd_put_8 (output_bfd, 0xe8 | ((val >> 3) & 7),
+				 contents + rel->r_offset - 1);
+		    }
+		  else if (type == 0x03)
+		    {
+		      /* addl */
+		      bfd_put_8 (output_bfd, 0x81,
+				 contents + rel->r_offset - 2);
+		      bfd_put_8 (output_bfd, 0xc0 | ((val >> 3) & 7),
+				 contents + rel->r_offset - 1);
+		    }
+		  else
+		    BFD_FAIL ();
+		  if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTIE)
+		    bfd_put_32 (output_bfd, -tpoff (info, relocation),
+				contents + rel->r_offset);
+		  else
+		    bfd_put_32 (output_bfd, tpoff (info, relocation),
+				contents + rel->r_offset);
+		  continue;
+		}
+	    }
+
+	  if (htab->sgot == NULL)
+	    abort ();
+
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+	      offplt = elf_i386_hash_entry (h)->tlsdesc_got;
+	    }
+	  else
+	    {
+	      if (local_got_offsets == NULL)
+		abort ();
+
+	      off = local_got_offsets[r_symndx];
+	      offplt = local_tlsdesc_gotents[r_symndx];
+	    }
+
+	  if ((off & 1) != 0)
+	    off &= ~1;
+	  else
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+	      int dr_type, indx;
+	      asection *sreloc;
+
+	      if (htab->srelgot == NULL)
+		abort ();
+
+	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
+
+	      if (GOT_TLS_GDESC_P (tls_type))
+		{
+		  outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_DESC);
+		  BFD_ASSERT (htab->sgotplt_jump_table_size + offplt + 8
+			      <= htab->sgotplt->size);
+		  outrel.r_offset = (htab->sgotplt->output_section->vma
+				     + htab->sgotplt->output_offset
+				     + offplt
+				     + htab->sgotplt_jump_table_size);
+		  sreloc = htab->srelplt;
+		  loc = sreloc->contents;
+		  loc += (htab->next_tls_desc_index++
+			  * sizeof (Elf32_External_Rel));
+		  BFD_ASSERT (loc + sizeof (Elf32_External_Rel)
+			      <= sreloc->contents + sreloc->size);
+		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		  if (indx == 0)
+		    {
+		      BFD_ASSERT (! unresolved_reloc);
+		      bfd_put_32 (output_bfd,
+				  relocation - dtpoff_base (info),
+				  htab->sgotplt->contents + offplt
+				  + htab->sgotplt_jump_table_size + 4);
+		    }
+		  else
+		    {
+		      bfd_put_32 (output_bfd, 0,
+				  htab->sgotplt->contents + offplt
+				  + htab->sgotplt_jump_table_size + 4);
+		    }
+		}
+
+	      sreloc = htab->srelgot;
+
+	      outrel.r_offset = (htab->sgot->output_section->vma
+				 + htab->sgot->output_offset + off);
+
+	      if (GOT_TLS_GD_P (tls_type))
+		dr_type = R_386_TLS_DTPMOD32;
+	      else if (GOT_TLS_GDESC_P (tls_type))
+		goto dr_done;
+	      else if (tls_type == GOT_TLS_IE_POS)
+		dr_type = R_386_TLS_TPOFF;
+	      else
+		dr_type = R_386_TLS_TPOFF32;
+
+	      if (dr_type == R_386_TLS_TPOFF && indx == 0)
+		bfd_put_32 (output_bfd, relocation - dtpoff_base (info),
+			    htab->sgot->contents + off);
+	      else if (dr_type == R_386_TLS_TPOFF32 && indx == 0)
+		bfd_put_32 (output_bfd, dtpoff_base (info) - relocation,
+			    htab->sgot->contents + off);
+	      else if (dr_type != R_386_TLS_DESC)
+		bfd_put_32 (output_bfd, 0,
+			    htab->sgot->contents + off);
+	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
+
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      BFD_ASSERT (loc + sizeof (Elf32_External_Rel)
+			  <= sreloc->contents + sreloc->size);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+
+	      if (GOT_TLS_GD_P (tls_type))
+		{
+		  if (indx == 0)
+		    {
+	    	      BFD_ASSERT (! unresolved_reloc);
+		      bfd_put_32 (output_bfd,
+				  relocation - dtpoff_base (info),
+				  htab->sgot->contents + off + 4);
+		    }
+		  else
+		    {
+		      bfd_put_32 (output_bfd, 0,
+				  htab->sgot->contents + off + 4);
+		      outrel.r_info = ELF32_R_INFO (indx,
+						    R_386_TLS_DTPOFF32);
+		      outrel.r_offset += 4;
+		      sreloc->reloc_count++;
+		      loc += sizeof (Elf32_External_Rel);
+		      BFD_ASSERT (loc + sizeof (Elf32_External_Rel)
+				  <= sreloc->contents + sreloc->size);
+		      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		    }
+		}
+	      else if (tls_type == GOT_TLS_IE_BOTH)
+		{
+		  bfd_put_32 (output_bfd,
+			      indx == 0 ? relocation - dtpoff_base (info) : 0,
+			      htab->sgot->contents + off + 4);
+		  outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_TPOFF);
+		  outrel.r_offset += 4;
+		  sreloc->reloc_count++;
+		  loc += sizeof (Elf32_External_Rel);
+		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+		}
+
+	    dr_done:
+	      if (h != NULL)
+		h->got.offset |= 1;
+	      else
+		local_got_offsets[r_symndx] |= 1;
+	    }
+
+	  if (off >= (bfd_vma) -2
+	      && ! GOT_TLS_GDESC_P (tls_type))
+	    abort ();
+	  if (r_type == R_386_TLS_GOTDESC
+	      || r_type == R_386_TLS_DESC_CALL)
+	    {
+	      relocation = htab->sgotplt_jump_table_size + offplt;
+	      unresolved_reloc = FALSE;
+	    }
+	  else if (r_type == ELF32_R_TYPE (rel->r_info))
+	    {
+	      bfd_vma g_o_t = htab->sgotplt->output_section->vma
+			      + htab->sgotplt->output_offset;
+	      relocation = htab->sgot->output_section->vma
+		+ htab->sgot->output_offset + off - g_o_t;
+	      if ((r_type == R_386_TLS_IE || r_type == R_386_TLS_GOTIE)
+		  && tls_type == GOT_TLS_IE_BOTH)
+		relocation += 4;
+	      if (r_type == R_386_TLS_IE)
+		relocation += g_o_t;
+	      unresolved_reloc = FALSE;
+	    }
+	  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GD)
+	    {
+	      unsigned int val, type;
+	      bfd_vma roff;
+
+	      /* GD->IE transition.  */
+	      type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
+	      val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
+	      if (type == 0x04)
+		{
+		  /* leal foo(,%reg,1), %eax; call ___tls_get_addr
+		     Change it into:
+		     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */
+		  val >>= 3;
+		  roff = rel->r_offset - 3;
+		}
+	      else
+		{
+		  /* leal foo(%reg), %eax; call ___tls_get_addr; nop
+		     Change it into:
+		     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */
+		  roff = rel->r_offset - 2;
+		}
+	      memcpy (contents + roff,
+		      "\x65\xa1\0\0\0\0\x2b\x80\0\0\0", 12);
+	      contents[roff + 7] = 0x80 | (val & 7);
+	      /* If foo is used only with foo@gotntpoff(%reg) and
+		 foo@indntpoff, but not with foo@gottpoff(%reg), change
+		 subl $foo@gottpoff(%reg), %eax
+		 into:
+		 addl $foo@gotntpoff(%reg), %eax.  */
+	      if (tls_type == GOT_TLS_IE_POS)
+		contents[roff + 6] = 0x03;
+	      bfd_put_32 (output_bfd,
+			  htab->sgot->output_section->vma
+			  + htab->sgot->output_offset + off
+			  - htab->sgotplt->output_section->vma
+			  - htab->sgotplt->output_offset,
+			  contents + roff + 8);
+	      /* Skip R_386_PLT32.  */
+	      rel++;
+	      continue;
+	    }
+	  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTDESC)
+	    {
+	      /* GDesc -> IE transition.
+		 It's originally something like:
+		 leal x@tlsdesc(%ebx), %eax
+
+		 Change it to:
+		 movl x@gotntpoff(%ebx), %eax # before xchg %ax,%ax
+		 or:
+		 movl x@gottpoff(%ebx), %eax # before negl %eax
+
+		 Registers other than %eax may be set up here.  */
+
+	      bfd_vma roff;
+
+	      /* First, make sure it's a leal adding ebx to a 32-bit
+		 offset into any register, although it's probably
+		 almost always going to be eax.  */
+	      roff = rel->r_offset;
+
+	      /* Now modify the instruction as appropriate.  */
+	      /* To turn a leal into a movl in the form we use it, it
+		 suffices to change the first byte from 0x8d to 0x8b.
+		 aoliva FIXME: should we decide to keep the leal, all
+		 we have to do is remove the statement below, and
+		 adjust the relaxation of R_386_TLS_DESC_CALL.  */
+	      bfd_put_8 (output_bfd, 0x8b, contents + roff - 2);
+
+	      if (tls_type == GOT_TLS_IE_BOTH)
+		off += 4;
+
+	      bfd_put_32 (output_bfd,
+			  htab->sgot->output_section->vma
+			  + htab->sgot->output_offset + off
+			  - htab->sgotplt->output_section->vma
+			  - htab->sgotplt->output_offset,
+			  contents + roff);
+	      continue;
+	    }
+	  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_DESC_CALL)
+	    {
+	      /* GDesc -> IE transition.
+		 It's originally:
+		 call *(%eax)
+
+		 Change it to:
+		 xchg %ax,%ax
+		 or
+		 negl %eax
+		 depending on how we transformed the TLS_GOTDESC above.
+	      */
+
+	      bfd_vma roff;
+
+	      roff = rel->r_offset;
+
+	      /* Now modify the instruction as appropriate.  */
+	      if (tls_type != GOT_TLS_IE_NEG)
+		{
+		  /* xchg %ax,%ax */
+		  bfd_put_8 (output_bfd, 0x66, contents + roff);
+		  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);
+		}
+	      else
+		{
+		  /* negl %eax */
+		  bfd_put_8 (output_bfd, 0xf7, contents + roff);
+		  bfd_put_8 (output_bfd, 0xd8, contents + roff + 1);
+		}
+
+	      continue;
+	    }
+	  else
+	    BFD_ASSERT (FALSE);
+	  break;
+
+	case R_386_TLS_LDM:
+	  if (! elf_i386_tls_transition (info, input_bfd,
+					 input_section, contents,
+					 symtab_hdr, sym_hashes,
+					 &r_type, GOT_UNKNOWN, rel,
+					 relend, h))
+	    return FALSE;
+
+	  if (r_type != R_386_TLS_LDM)
+	    {
+	      /* LD->LE transition:
+		 leal foo(%reg), %eax; call ___tls_get_addr.
+		 We change it into:
+		 movl %gs:0, %eax; nop; leal 0(%esi,1), %esi.  */
+	      BFD_ASSERT (r_type == R_386_TLS_LE_32);
+	      memcpy (contents + rel->r_offset - 2,
+		      "\x65\xa1\0\0\0\0\x90\x8d\x74\x26", 11);
+	      /* Skip R_386_PC32/R_386_PLT32.  */
+	      rel++;
+	      continue;
+	    }
+
+	  if (htab->sgot == NULL)
+	    abort ();
+
+	  off = htab->tls_ldm_got.offset;
+	  if (off & 1)
+	    off &= ~1;
+	  else
+	    {
+	      Elf_Internal_Rela outrel;
+	      bfd_byte *loc;
+
+	      if (htab->srelgot == NULL)
+		abort ();
+
+	      outrel.r_offset = (htab->sgot->output_section->vma
+				 + htab->sgot->output_offset + off);
+
+	      bfd_put_32 (output_bfd, 0,
+			  htab->sgot->contents + off);
+	      bfd_put_32 (output_bfd, 0,
+			  htab->sgot->contents + off + 4);
+	      outrel.r_info = ELF32_R_INFO (0, R_386_TLS_DTPMOD32);
+	      loc = htab->srelgot->contents;
+	      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+	      htab->tls_ldm_got.offset |= 1;
+	    }
+	  relocation = htab->sgot->output_section->vma
+		       + htab->sgot->output_offset + off
+		       - htab->sgotplt->output_section->vma
+		       - htab->sgotplt->output_offset;
+	  unresolved_reloc = FALSE;
+	  break;
+
+	case R_386_TLS_LDO_32:
+	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
+	    relocation -= dtpoff_base (info);
+	  else
+	    /* When converting LDO to LE, we must negate.  */
+	    relocation = -tpoff (info, relocation);
+	  break;
+
+	case R_386_TLS_LE_32:
+	case R_386_TLS_LE:
+	  if (info->shared)
+	    {
+	      Elf_Internal_Rela outrel;
+	      asection *sreloc;
+	      bfd_byte *loc;
+	      int indx;
+
+	      outrel.r_offset = rel->r_offset
+				+ input_section->output_section->vma
+				+ input_section->output_offset;
+	      if (h != NULL && h->dynindx != -1)
+		indx = h->dynindx;
+	      else
+		indx = 0;
+	      if (r_type == R_386_TLS_LE_32)
+		outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_TPOFF32);
+	      else
+		outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_TPOFF);
+	      sreloc = elf_section_data (input_section)->sreloc;
+	      if (sreloc == NULL)
+		abort ();
+	      loc = sreloc->contents;
+	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
+	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
+	      if (indx)
+		continue;
+	      else if (r_type == R_386_TLS_LE_32)
+		relocation = dtpoff_base (info) - relocation;
+	      else
+		relocation -= dtpoff_base (info);
+	    }
+	  else if (r_type == R_386_TLS_LE_32)
+	    relocation = tpoff (info, relocation);
+	  else
+	    relocation = -tpoff (info, relocation);
+	  break;
+
+	default:
+	  break;
+	}
+
+      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
+	 because such sections are not SEC_ALLOC and thus ld.so will
+	 not process them.  */
+      if (unresolved_reloc
+	  && !((input_section->flags & SEC_DEBUGGING) != 0
+	       && h->def_dynamic))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
+	     input_bfd,
+	     input_section,
+	     (long) rel->r_offset,
+	     howto->name,
+	     h->root.root.string);
+	  return FALSE;
+	}
+
+      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+				    contents, rel->r_offset,
+				    relocation, 0);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char *name;
+
+	  if (h != NULL)
+	    name = h->root.root.string;
+	  else
+	    {
+	      name = bfd_elf_string_from_elf_section (input_bfd,
+						      symtab_hdr->sh_link,
+						      sym->st_name);
+	      if (name == NULL)
+		return FALSE;
+	      if (*name == '\0')
+		name = bfd_section_name (input_bfd, sec);
+	    }
+
+	  if (r == bfd_reloc_overflow)
+	    {
+	      if (! ((*info->callbacks->reloc_overflow)
+		     (info, (h ? &h->root : NULL), name, howto->name,
+		      (bfd_vma) 0, input_bfd, input_section,
+		      rel->r_offset)))
+		return FALSE;
+	    }
+	  else
+	    {
+	      (*_bfd_error_handler)
+		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
+		 input_bfd, input_section,
+		 (long) rel->r_offset, name, (int) r);
+	      return FALSE;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+elf_i386_finish_dynamic_symbol (bfd *output_bfd,
+				struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym)
+{
+  struct elf_i386_link_hash_table *htab;
+
+  htab = elf_i386_hash_table (info);
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      bfd_vma plt_index;
+      bfd_vma got_offset;
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+	 it up.  */
+
+      if (h->dynindx == -1
+	  || htab->splt == NULL
+	  || htab->sgotplt == NULL
+	  || htab->srelplt == NULL)
+	abort ();
+
+      /* Get the index in the procedure linkage table which
+	 corresponds to this symbol.  This is the index of this symbol
+	 in all the symbols for which we are making plt entries.  The
+	 first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
+
+      /* Get the offset into the .got table of the entry that
+	 corresponds to this function.  Each .got entry is 4 bytes.
+	 The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+
+      /* Fill in the entry in the procedure linkage table.  */
+      if (! info->shared)
+	{
+	  memcpy (htab->splt->contents + h->plt.offset, elf_i386_plt_entry,
+		  PLT_ENTRY_SIZE);
+	  bfd_put_32 (output_bfd,
+		      (htab->sgotplt->output_section->vma
+		       + htab->sgotplt->output_offset
+		       + got_offset),
+		      htab->splt->contents + h->plt.offset + 1);
+
+	  if (htab->is_vxworks)
+	    {
+	      int s, k, reloc_index;
+
+	      /* Create the R_386_32 relocation referencing the GOT
+		 for this PLT entry.  */
+
+	      /* S: Current slot number (zero-based).  */
+	      s = (h->plt.offset - PLT_ENTRY_SIZE) / PLT_ENTRY_SIZE;
+	      /* K: Number of relocations for PLTResolve. */
+	      if (info->shared)
+		k = PLTRESOLVE_RELOCS_SHLIB;
+	      else
+		k = PLTRESOLVE_RELOCS;
+	      /* Skip the PLTresolve relocations, and the relocations for
+		 the other PLT slots. */
+	      reloc_index = k + s * PLT_NON_JUMP_SLOT_RELOCS;
+	      loc = (htab->srelplt2->contents + reloc_index
+		     * sizeof (Elf32_External_Rel));
+
+	      rel.r_offset = (htab->splt->output_section->vma
+			      + htab->splt->output_offset
+			      + h->plt.offset + 2),
+	      rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+	      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+
+	      /* Create the R_386_32 relocation referencing the beginning of
+		 the PLT for this GOT entry.  */
+	      rel.r_offset = (htab->sgotplt->output_section->vma
+			      + htab->sgotplt->output_offset
+			      + got_offset);
+	      rel.r_info = ELF32_R_INFO (htab->elf.hplt->indx, R_386_32);
+	      bfd_elf32_swap_reloc_out (output_bfd, &rel,
+	      loc + sizeof (Elf32_External_Rel));
+	    }
+	}
+      else
+	{
+	  memcpy (htab->splt->contents + h->plt.offset, elf_i386_pic_plt_entry,
+		  PLT_ENTRY_SIZE);
+	  bfd_put_32 (output_bfd, got_offset,
+		      htab->splt->contents + h->plt.offset + 2);
+	}
+
+      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rel),
+		  htab->splt->contents + h->plt.offset + 12);
+      /*
+       * The previous code assumed that the jump entry ended a PLT entry.
+       * Forcing alignment to 0mod32 adds some hlt bytes at the end (11).
+       * We therefore need to subtract those bytes from the jump offset.
+       */
+      bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE - 11),
+		  htab->splt->contents + h->plt.offset + 17);
+
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd,
+		  (htab->splt->output_section->vma
+		   + htab->splt->output_offset
+		   + h->plt.offset
+		   + 11),
+		  htab->sgotplt->contents + got_offset);
+
+      /* Fill in the entry in the .rel.plt section.  */
+      rel.r_offset = (htab->sgotplt->output_section->vma
+		      + htab->sgotplt->output_offset
+		      + got_offset);
+      rel.r_info = ELF32_R_INFO (h->dynindx, R_386_JUMP_SLOT);
+      loc = htab->srelplt->contents + plt_index * sizeof (Elf32_External_Rel);
+      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+
+      if (!h->def_regular)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value if there were any
+	     relocations where pointer equality matters (this is a clue
+	     for the dynamic linker, to make function pointer
+	     comparisons work between an application and shared
+	     library), otherwise set it to zero.  If a function is only
+	     called from a binary, there is no need to slow down
+	     shared libraries because of that.  */
+	  sym->st_shndx = SHN_UNDEF;
+	  if (!h->pointer_equality_needed)
+	    sym->st_value = 0;
+	}
+    }
+
+  if (h->got.offset != (bfd_vma) -1
+      && ! GOT_TLS_GD_ANY_P (elf_i386_hash_entry(h)->tls_type)
+      && (elf_i386_hash_entry(h)->tls_type & GOT_TLS_IE) == 0)
+    {
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol has an entry in the global offset table.  Set it
+	 up.  */
+
+      if (htab->sgot == NULL || htab->srelgot == NULL)
+	abort ();
+
+      rel.r_offset = (htab->sgot->output_section->vma
+		      + htab->sgot->output_offset
+		      + (h->got.offset & ~(bfd_vma) 1));
+
+      /* If this is a static link, or it is a -Bsymbolic link and the
+	 symbol is defined locally or was forced to be local because
+	 of a version file, we just want to emit a RELATIVE reloc.
+	 The entry in the global offset table will already have been
+	 initialized in the relocate_section function.  */
+      if (info->shared
+	  && SYMBOL_REFERENCES_LOCAL (info, h))
+	{
+	  BFD_ASSERT((h->got.offset & 1) != 0);
+	  rel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
+	}
+      else
+	{
+	  BFD_ASSERT((h->got.offset & 1) == 0);
+	  bfd_put_32 (output_bfd, (bfd_vma) 0,
+		      htab->sgot->contents + h->got.offset);
+	  rel.r_info = ELF32_R_INFO (h->dynindx, R_386_GLOB_DAT);
+	}
+
+      loc = htab->srelgot->contents;
+      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
+      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+    }
+
+  if (h->needs_copy)
+    {
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol needs a copy reloc.  Set it up.  */
+
+      if (h->dynindx == -1
+	  || (h->root.type != bfd_link_hash_defined
+	      && h->root.type != bfd_link_hash_defweak)
+	  || htab->srelbss == NULL)
+	abort ();
+
+      rel.r_offset = (h->root.u.def.value
+		      + h->root.u.def.section->output_section->vma
+		      + h->root.u.def.section->output_offset);
+      rel.r_info = ELF32_R_INFO (h->dynindx, R_386_COPY);
+      loc = htab->srelbss->contents;
+      loc += htab->srelbss->reloc_count++ * sizeof (Elf32_External_Rel);
+      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+    }
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.
+     On VxWorks, the _GLOBAL_OFFSET_TABLE_ symbol is not absolute: it
+     is relative to the ".got" section.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || (!htab->is_vxworks && h == htab->elf.hgot))
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+/* Used to decide how to sort relocs in an optimal manner for the
+   dynamic linker, before writing them out.  */
+
+static enum elf_reloc_type_class
+elf_i386_reloc_type_class (const Elf_Internal_Rela *rela)
+{
+  switch (ELF32_R_TYPE (rela->r_info))
+    {
+    case R_386_RELATIVE:
+      return reloc_class_relative;
+    case R_386_JUMP_SLOT:
+      return reloc_class_plt;
+    case R_386_COPY:
+      return reloc_class_copy;
+    default:
+      return reloc_class_normal;
+    }
+}
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+elf_i386_finish_dynamic_sections (bfd *output_bfd,
+				  struct bfd_link_info *info)
+{
+  struct elf_i386_link_hash_table *htab;
+  bfd *dynobj;
+  asection *sdyn;
+
+  htab = elf_i386_hash_table (info);
+  dynobj = htab->elf.dynobj;
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  if (htab->elf.dynamic_sections_created)
+    {
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      if (sdyn == NULL || htab->sgot == NULL)
+	abort ();
+
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  asection *s;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      if (htab->is_vxworks
+		  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))
+		break;
+	      continue;
+
+	    case DT_PLTGOT:
+	      s = htab->sgotplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_JMPREL:
+	      s = htab->srelplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_PLTRELSZ:
+	      s = htab->srelplt;
+	      dyn.d_un.d_val = s->size;
+	      break;
+
+	    case DT_RELSZ:
+	      /* My reading of the SVR4 ABI indicates that the
+		 procedure linkage table relocs (DT_JMPREL) should be
+		 included in the overall relocs (DT_REL).  This is
+		 what Solaris does.  However, UnixWare can not handle
+		 that case.  Therefore, we override the DT_RELSZ entry
+		 here to make it not include the JMPREL relocs.  */
+	      s = htab->srelplt;
+	      if (s == NULL)
+		continue;
+	      dyn.d_un.d_val -= s->size;
+	      break;
+
+	    case DT_REL:
+	      /* We may not be using the standard ELF linker script.
+		 If .rel.plt is the first .rel section, we adjust
+		 DT_REL to not include it.  */
+	      s = htab->srelplt;
+	      if (s == NULL)
+		continue;
+	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
+		continue;
+	      dyn.d_un.d_ptr += s->size;
+	      break;
+	    }
+
+	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	}
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      if (htab->splt && htab->splt->size > 0)
+	{
+	  if (info->shared)
+	    {
+	      memcpy (htab->splt->contents, elf_i386_pic_plt0_entry,
+		      sizeof (elf_i386_pic_plt0_entry));
+	      memset (htab->splt->contents + sizeof (elf_i386_pic_plt0_entry),
+		      htab->plt0_pad_byte,
+		      PLT_ENTRY_SIZE - sizeof (elf_i386_pic_plt0_entry));
+	    }
+	  else
+	    {
+	      memcpy (htab->splt->contents, elf_i386_plt0_entry,
+		      sizeof(elf_i386_plt0_entry));
+	      memset (htab->splt->contents + sizeof (elf_i386_plt0_entry),
+		      htab->plt0_pad_byte,
+		      PLT_ENTRY_SIZE - sizeof (elf_i386_plt0_entry));
+	      bfd_put_32 (output_bfd,
+			  (htab->sgotplt->output_section->vma
+			   + htab->sgotplt->output_offset
+			   + 4),
+			  htab->splt->contents + 2);
+	      bfd_put_32 (output_bfd,
+			  (htab->sgotplt->output_section->vma
+			   + htab->sgotplt->output_offset
+			   + 8),
+			  htab->splt->contents + 7);
+
+	      if (htab->is_vxworks)
+		{
+		  Elf_Internal_Rela rel;
+
+		  /* Generate a relocation for _GLOBAL_OFFSET_TABLE_ + 4.
+		     On IA32 we use REL relocations so the addend goes in
+		     the PLT directly.  */
+		  rel.r_offset = (htab->splt->output_section->vma
+				  + htab->splt->output_offset
+				  + 2);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel,
+					    htab->srelplt2->contents);
+		  /* Generate a relocation for _GLOBAL_OFFSET_TABLE_ + 8.  */
+		  rel.r_offset = (htab->splt->output_section->vma
+				  + htab->splt->output_offset
+				  + 8);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel,
+					    htab->srelplt2->contents +
+					    sizeof (Elf32_External_Rel));
+		}
+	    }
+
+	  /* UnixWare sets the entsize of .plt to 4, although that doesn't
+	     really seem like the right value.  */
+	  elf_section_data (htab->splt->output_section)
+	    ->this_hdr.sh_entsize = 4;
+
+	  /* Correct the .rel.plt.unloaded relocations.  */
+	  if (htab->is_vxworks && !info->shared)
+	    {
+	      int num_plts = (htab->splt->size / PLT_ENTRY_SIZE) - 1;
+	      unsigned char *p;
+
+	      p = htab->srelplt2->contents;
+	      if (info->shared)
+		p += PLTRESOLVE_RELOCS_SHLIB * sizeof (Elf32_External_Rel);
+	      else
+		p += PLTRESOLVE_RELOCS * sizeof (Elf32_External_Rel);
+
+	      for (; num_plts; num_plts--)
+		{
+		  Elf_Internal_Rela rel;
+		  bfd_elf32_swap_reloc_in (output_bfd, p, &rel);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel, p);
+		  p += sizeof (Elf32_External_Rel);
+
+		  bfd_elf32_swap_reloc_in (output_bfd, p, &rel);
+		  rel.r_info = ELF32_R_INFO (htab->elf.hplt->indx, R_386_32);
+		  bfd_elf32_swap_reloc_out (output_bfd, &rel, p);
+		  p += sizeof (Elf32_External_Rel);
+		}
+	    }
+	}
+    }
+
+  if (htab->sgotplt)
+    {
+      /* Fill in the first three entries in the global offset table.  */
+      if (htab->sgotplt->size > 0)
+	{
+	  bfd_put_32 (output_bfd,
+		      (sdyn == NULL ? 0
+		       : sdyn->output_section->vma + sdyn->output_offset),
+		      htab->sgotplt->contents);
+	  bfd_put_32 (output_bfd, 0, htab->sgotplt->contents + 4);
+	  bfd_put_32 (output_bfd, 0, htab->sgotplt->contents + 8);
+	}
+
+      elf_section_data (htab->sgotplt->output_section)->this_hdr.sh_entsize = 4;
+    }
+
+  if (htab->sgot && htab->sgot->size > 0)
+    elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return TRUE;
+}
+
+/* Return address for Ith PLT stub in section PLT, for relocation REL
+   or (bfd_vma) -1 if it should not be included.  */
+
+static bfd_vma
+elf_i386_plt_sym_val (bfd_vma i, const asection *plt,
+		      const arelent *rel ATTRIBUTE_UNUSED)
+{
+  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
+}
+
+/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */
+
+static bfd_boolean
+elf_i386_hash_symbol (struct elf_link_hash_entry *h)
+{
+  if (h->plt.offset != (bfd_vma) -1
+      && !h->def_regular
+      && !h->pointer_equality_needed)
+    return FALSE;
+
+  return _bfd_elf_hash_symbol (h);
+}
+
+#define TARGET_LITTLE_SYM		bfd_elf32_nacl_vec
+#define TARGET_LITTLE_NAME		"elf32-nacl"
+
+/* NativeClient defines its own ABI.*/
+#undef	ELF_OSABI
+#define ELF_OSABI			ELFOSABI_NACL
+
+#define ELF_ARCH			bfd_arch_i386
+#define ELF_MACHINE_CODE		EM_386
+#define ELF_MAXPAGESIZE			0x1000
+
+#define elf_backend_can_gc_sections	1
+#define elf_backend_can_refcount	1
+#define elf_backend_want_got_plt	1
+#define elf_backend_plt_readonly	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_got_header_size	12
+
+/* Support RELA for objdump of prelink objects.  */
+#define elf_info_to_howto		      elf_i386_info_to_howto_rel
+#define elf_info_to_howto_rel		      elf_i386_info_to_howto_rel
+
+#define bfd_elf32_mkobject		      elf_i386_mkobject
+
+#define bfd_elf32_bfd_is_local_label_name     elf_i386_is_local_label_name
+#define bfd_elf32_bfd_link_hash_table_create  elf_i386_link_hash_table_create
+#define bfd_elf32_bfd_reloc_type_lookup	      elf_i386_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	      elf_i386_reloc_name_lookup
+
+#define elf_backend_adjust_dynamic_symbol     elf_i386_adjust_dynamic_symbol
+#define elf_backend_relocs_compatible	      _bfd_elf_relocs_compatible
+#define elf_backend_check_relocs	      elf_i386_check_relocs
+#define elf_backend_copy_indirect_symbol      elf_i386_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections   elf_i386_create_dynamic_sections
+#define elf_backend_fake_sections	      elf_i386_fake_sections
+#define elf_backend_finish_dynamic_sections   elf_i386_finish_dynamic_sections
+#define elf_backend_finish_dynamic_symbol     elf_i386_finish_dynamic_symbol
+#define elf_backend_gc_mark_hook	      elf_i386_gc_mark_hook
+#define elf_backend_gc_sweep_hook	      elf_i386_gc_sweep_hook
+#define elf_backend_grok_prstatus	      elf_i386_grok_prstatus
+#define elf_backend_grok_psinfo		      elf_i386_grok_psinfo
+#define elf_backend_reloc_type_class	      elf_i386_reloc_type_class
+#define elf_backend_relocate_section	      elf_i386_relocate_section
+#define elf_backend_size_dynamic_sections     elf_i386_size_dynamic_sections
+#define elf_backend_always_size_sections      elf_i386_always_size_sections
+#define elf_backend_omit_section_dynsym \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
+#define elf_backend_plt_sym_val		      elf_i386_plt_sym_val
+#define elf_backend_hash_symbol		      elf_i386_hash_symbol
+
+#define bfd_elf32_bfd_merge_private_bfd_data \
+  elf32_nacl_merge_private_bfd_data
+
+static unsigned long previous_ibfd_e_flags = (unsigned long) EF_NACL_ALIGN_LIB;
+static unsigned char previous_ibfd_abiversion = 0;
+
+static bfd_boolean
+elf32_nacl_merge_private_bfd_data (bfd *ibfd,
+                                   bfd *obfd)
+{
+  unsigned long ibfd_e_flags;
+  unsigned char ibfd_abiversion;
+
+  ibfd_e_flags = elf_elfheader (ibfd)->e_flags & EF_NACL_ALIGN_MASK;
+  if ((ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (previous_ibfd_e_flags != EF_NACL_ALIGN_LIB) &&
+      (ibfd_e_flags != previous_ibfd_e_flags)) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible alignments"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  ibfd_abiversion = elf_elfheader (ibfd)->e_ident[EI_ABIVERSION];
+  if (ibfd_abiversion != 0 &&
+      previous_ibfd_abiversion != 0 &&
+      ibfd_abiversion != previous_ibfd_abiversion) {
+    (*_bfd_error_handler)
+    (_("%B: linking files with incompatible abi version"), ibfd);
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+  }
+
+  previous_ibfd_e_flags = ibfd_e_flags;
+  elf_elfheader (obfd)->e_flags |= previous_ibfd_e_flags;
+
+  previous_ibfd_abiversion = ibfd_abiversion;
+  elf_elfheader (obfd)->e_ident[EI_ABIVERSION] = previous_ibfd_abiversion;
+
+  return TRUE;
+}
+
+#undef elf_backend_final_write_processing
+#define elf_backend_final_write_processing \
+  elf32_nacl_backend_final_write_processing
+
+static void
+elf32_nacl_backend_final_write_processing (bfd *abfd,
+                                           bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  elf_elfheader (abfd)->e_ident[EI_OSABI] = ELFOSABI_NACL;
+  elf_elfheader (abfd)->e_ident[EI_ABIVERSION] = EF_NACL_ABIVERSION;
+  elf_elfheader (abfd)->e_flags |= previous_ibfd_e_flags;
+}
+
+#include "elf32-target.h"
diff -Naur ../PRISTINE/gdb-6.8/bfd/targets.c gdb-6.8/bfd/targets.c
--- ../PRISTINE/gdb-6.8/bfd/targets.c	2008-02-14 07:20:26.000000000 -0800
+++ gdb-6.8/bfd/targets.c	2009-04-21 00:34:47.000000000 -0700
@@ -628,6 +628,7 @@
 extern const bfd_target bfd_elf32_mn10300_vec;
 extern const bfd_target bfd_elf32_mt_vec;
 extern const bfd_target bfd_elf32_msp430_vec;
+extern const bfd_target bfd_elf32_nacl_vec;
 extern const bfd_target bfd_elf32_nbigmips_vec;
 extern const bfd_target bfd_elf32_nlittlemips_vec;
 extern const bfd_target bfd_elf32_ntradbigmips_vec;
diff -Naur ../PRISTINE/gdb-6.8/config.sub gdb-6.8/config.sub
--- ../PRISTINE/gdb-6.8/config.sub	2008-01-22 18:43:51.000000000 -0800
+++ gdb-6.8/config.sub	2009-04-21 00:34:47.000000000 -0700
@@ -306,6 +306,10 @@
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
+	nacl*)
+	  basic_machine=i686-pc
+	  os=-nacl
+	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
@@ -1270,6 +1274,9 @@
 			;;
 		esac
 		;;
+	-nacl*)
+		os=-nacl
+		;;
 	-nto-qnx*)
 		;;
 	-nto*)
diff -Naur ../PRISTINE/gdb-6.8/gdb/ChangeLog gdb-6.8/gdb/ChangeLog
--- ../PRISTINE/gdb-6.8/gdb/ChangeLog	2008-03-27 11:14:10.000000000 -0700
+++ gdb-6.8/gdb/ChangeLog	2009-04-21 00:34:47.000000000 -0700
@@ -1,3 +1,11 @@
+2008-08-09  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* target.c: Include "solib.h".
+	(target_pre_inferior): Call no_shared_libraries.
+	* infcmd.c (run_command_1): Do not call objfile_purge_solibs
+	or clear_solib.
+	(attach_command): Do not call clear_solib.
+
 2008-03-27  Joel Brobecker  <brobecker@adacore.com>
 
 	* NEWS: Replace "Changes since GDB 6.7" into changes in GDB 6.8".
diff -Naur ../PRISTINE/gdb-6.8/gdb/Makefile.in gdb-6.8/gdb/Makefile.in
--- ../PRISTINE/gdb-6.8/gdb/Makefile.in	2008-03-17 05:15:08.000000000 -0700
+++ gdb-6.8/gdb/Makefile.in	2009-04-21 00:34:47.000000000 -0700
@@ -3347,4 +3347,30 @@
 	$(gdb_curses_h) $(gdb_assert_h)
 	$(CC) -c $(INTERNAL_CFLAGS) $(srcdir)/tui/tui-winsource.c
 
+# It's easier to handle local mods if they're isolated pure additions.
+# It's obviously intended that an FSF-submitted patch would rework this.
+breakpoint.o: i386-nacl-tdep.h
+exec.o: i386-nacl-tdep.h
+infrun.o: i386-nacl-tdep.h
+linux-thread-db.o: i386-nacl-tdep.h
+main.o: i386-nacl-tdep.h
+proc-service.o: i386-nacl-tdep.h
+symfile.o: i386-nacl-tdep.h
+thread.o: i386-nacl-tdep.h
+top.o: i386-nacl-tdep.h
+i386-linux-nat.o: i386-linux-nat.h
+
+i386-nacl-tdep.o: i386-nacl-tdep.c $(defs_h) $(gdbcore_h) $(frame_h) \
+	$(value_h) $(regcache_h) $(inferior_h) $(osabi_h) $(reggroups_h) \
+	$(dwarf2_frame_h) $(gdb_string_h) $(gdbcmd_h) $(symfile_h) \
+	$(completer_h) $(objfiles_h) $(exec_h) $(event_top_h) $(exceptions_h) \
+	$(gdb_proc_service_h) $(symtab_h) $(linux_nat_h) \
+	$(readline_tilde_h) $(elf_external_h) $(elf_common_h) $(i386_tdep_h) \
+	$(i386_linux_tdep_h) i386-nacl-tdep.h
+i386-nacl-nat.o: i386-nacl-nat.c $(defs_h) $(inferior_h) $(regcache_h) \
+	$(inf_ptrace_h) $(linux_nat_h) $(i386_tdep_h) \
+	$(i386_linux_tdep_h) i386-nacl-tdep.h i386-linux-nat.h
+i386-nacl-thread.o: i386-nacl-thread.c $(defs_h) $(target_h) \
+	$(i386_linux_tdep_h) i386-nacl-tdep.h
+
 ### end of the gdb Makefile.in.
diff -Naur ../PRISTINE/gdb-6.8/gdb/breakpoint.c gdb-6.8/gdb/breakpoint.c
--- ../PRISTINE/gdb-6.8/gdb/breakpoint.c	2008-02-26 00:14:11.000000000 -0800
+++ gdb-6.8/gdb/breakpoint.c	2009-04-21 00:34:47.000000000 -0700
@@ -59,6 +59,10 @@
 #include "gdb-events.h"
 #include "mi/mi-common.h"
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 /* Prototypes for local functions. */
 
 static void until_break_command_continuation (struct continuation_arg *arg);
@@ -1084,6 +1088,26 @@
 	  else
 	    val = target_insert_breakpoint (&bpt->target_info);
 	}
+#ifdef NATIVE_CLIENT
+      /* Native client breakpoints are always set at their LMA.
+	 Whether the code is "mapped" or not depends on whether we're in
+	 nacl mode.  We don't bother to track switching into and out of
+	 nacl mode, but ptrace always accesses via the LMA so we don't
+	 have to.  */
+      else if (1)
+	{
+	  CORE_ADDR addr = overlay_unmapped_address (bpt->address,
+						     bpt->section);
+	  /* Set a software (trap) breakpoint at the LMA.  */
+	  bpt->overlay_target_info = bpt->target_info;
+	  bpt->overlay_target_info.placed_address = addr;
+	  val = target_insert_breakpoint (&bpt->overlay_target_info);
+	  if (val != 0)
+	    fprintf_unfiltered (tmp_error_stream,
+				"Overlay breakpoint %d failed: in ROM?\n",
+				bpt->owner->number);
+	}
+#endif
       else
 	{
 	  /* This breakpoint is in an overlay section.  
@@ -1530,6 +1554,16 @@
 	  else
 	    val = target_remove_breakpoint (&b->target_info);
 	}
+#ifdef NATIVE_CLIENT
+      /* See corresponding code in insert_bp_location.  */
+      else if (1)
+	{
+	  if (b->loc_type == bp_loc_hardware_breakpoint)
+	    val = target_remove_hw_breakpoint (&b->overlay_target_info);
+	  else
+	    val = target_remove_breakpoint (&b->overlay_target_info);
+	}
+#endif
       else
 	{
 	  /* This breakpoint is in an overlay section.  
@@ -1808,6 +1842,34 @@
   return 0;
 }
 
+#ifdef NATIVE_CLIENT
+
+/* This function returns non-zero iff there is a software breakpoint
+   inserted at PC.  */
+
+int
+overlay_breakpoint_inserted_here_p (CORE_ADDR pc)
+{
+  const struct bp_location *bpt;
+
+  ALL_BP_LOCATIONS (bpt)
+    {
+      if (bpt->loc_type != bp_loc_software_breakpoint)
+	continue;
+
+      if (bpt->inserted
+	  && bpt->address == pc
+	  && bpt->owner->type == bp_overlay_event)
+	{
+	  return 1;
+	}
+    }
+
+  return 0;
+}
+
+#endif
+
 /* breakpoint_thread_match (PC, PTID) returns true if the breakpoint at
    PC is valid for process/thread PTID.  */
 
@@ -3437,10 +3499,16 @@
   strcpy (wrap_indent, "                           ");
   if (addressprint)
     {
+      int width;
       if (gdbarch_addr_bit (current_gdbarch) <= 32)
-	strcat (wrap_indent, "           ");
+	width = 10;
       else
-	strcat (wrap_indent, "                   ");
+	width = 18;
+      ++width; /* space between columns */
+#ifdef NATIVE_CLIENT
+      width += 3;
+#endif
+      strcat (wrap_indent, n_spaces (width));
     }
 
   if (b->ops != NULL && b->ops->print_one != NULL)
@@ -3540,13 +3608,22 @@
       case bp_overlay_event:
 	if (addressprint)
 	  {
+#ifdef NATIVE_CLIENT
+	    const char *aspace = "sr";
+	    if (loc && section_is_overlay (loc->section))
+	      aspace = "nc";
+#endif
 	    annotate_field (4);
 	    if (header_of_multiple)
 	      ui_out_field_string (uiout, "addr", "<MULTIPLE>");
-	    if (b->loc == NULL || loc->shlib_disabled)
+	    else if (b->loc == NULL || loc->shlib_disabled)
 	      ui_out_field_string (uiout, "addr", "<PENDING>");
 	    else
+#ifdef NATIVE_CLIENT
+	      ui_out_field_aspace_core_addr (uiout, "addr", aspace, loc->address);
+#else
 	      ui_out_field_core_addr (uiout, "addr", loc->address);
+#endif
 	  }
 	annotate_field (5);
 	if (!header_of_multiple)
@@ -3771,14 +3848,19 @@
     annotate_field (3);
   ui_out_table_header (uiout, 3, ui_left, "enabled", "Enb");	/* 4 */
   if (addressprint)
-	{
-	  if (nr_printable_breakpoints > 0)
-	    annotate_field (4);
-	  if (gdbarch_addr_bit (current_gdbarch) <= 32)
-	    ui_out_table_header (uiout, 10, ui_left, "addr", "Address");/* 5 */
-	  else
-	    ui_out_table_header (uiout, 18, ui_left, "addr", "Address");/* 5 */
-	}
+    {
+      int width;
+      if (gdbarch_addr_bit (current_gdbarch) <= 32)
+	width = 10;
+      else
+	width = 18;
+#ifdef NATIVE_CLIENT
+      width += 3;
+#endif
+      if (nr_printable_breakpoints > 0)
+	annotate_field (4);
+      ui_out_table_header (uiout, width, ui_left, "addr", "Address");/* 5 */
+    }
   if (nr_printable_breakpoints > 0)
     annotate_field (5);
   ui_out_table_header (uiout, 40, ui_noalign, "what", "What");	/* 6 */
@@ -4364,6 +4446,14 @@
 				  bp_overlay_event);
   b->addr_string = xstrdup (func_name);
 
+#ifdef NATIVE_CLIENT
+  if (overlay_debugging == ovly_nacl)
+    {
+      b->enable_state = bp_enabled;
+      overlay_events_enabled = 1;
+    }
+  else
+#endif
   if (overlay_debugging == ovly_auto)
     {
       b->enable_state = bp_enabled;
@@ -4481,11 +4571,16 @@
        to insert those breakpoints and fail.  */
     if (((b->type == bp_breakpoint) || (b->type == bp_hardware_breakpoint))
 	&& !loc->shlib_disabled
+	&& (
 #ifdef PC_SOLIB
-	&& PC_SOLIB (loc->address)
+	  PC_SOLIB (loc->address)
 #else
-	&& solib_address (loc->address)
+	  solib_address (loc->address)
+#endif
+#ifdef NATIVE_CLIENT
+	  || (loc->section && nacl_section_p (loc->section))
 #endif
+	    )
 	)
       {
 	loc->shlib_disabled = 1;
@@ -7204,6 +7299,25 @@
       }
   }
 
+#ifdef NATIVE_CLIENT
+  /* Ditto for shlib_disable status.
+     Except the above code to copy over the disable status is subject to
+     heuristics.  We don't need heuristics, we can copy the state exactly.
+     We use shlib_disable status for native-client code to achieve the same
+     thing it does for shared libraries: Until the code is loaded we don't
+     know where it lives.  */
+  if (nacl_mode_p ()
+      && ! nacl_loaded_p ())
+    {
+      struct bp_location *l = b->loc;
+
+      for (; l; l = l->next)
+	{
+	  l->shlib_disabled = 1;
+	}
+    }
+#endif
+
   while (existing_locations)
     {
       struct bp_location *next = existing_locations->next;
@@ -7250,6 +7364,20 @@
 	  return 0;
 	}
 
+#ifdef NATIVE_CLIENT
+      /* This may be a pending breakpoint needing symbol lookup to resolve.
+	 Make sure the current nacl mode is correct for the breakpoint.  */
+      {
+	struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+	if (b->loc
+	    && b->loc->section
+	    && nacl_section_p (b->loc->section))
+	  set_nacl_gdb_state ();
+	else
+	  set_sr_gdb_state ();
+#endif
+
       set_language (b->language);
       input_radix = b->input_radix;
       s = b->addr_string;
@@ -7287,7 +7415,12 @@
 	}
 
       if (not_found)
-	break;
+	{
+#ifdef NATIVE_CLIENT
+	  do_cleanups (my_cleanups);
+#endif
+	  break;
+	}
       
       gdb_assert (sals.nelts == 1);
       resolve_sal_pc (&sals.sals[0]);
@@ -7310,6 +7443,11 @@
       check_duplicates (b);
 
       xfree (sals.sals);
+
+#ifdef NATIVE_CLIENT
+	do_cleanups (my_cleanups);
+      }
+#endif
       break;
 
     case bp_watchpoint:
@@ -7407,6 +7545,18 @@
   set_language (save_language);
   input_radix = save_input_radix;
 
+#ifdef NATIVE_CLIENT
+  /* These get deleted by breakpoint_re_set_one, so we need to restore them.
+     For the longjmp breakpoints we need to restore them for both
+     native-client and service-runtime modes.  */
+  /* FIXME: Restoring native-client versions is deferred.  */
+
+  {
+    struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+    set_sr_gdb_state ();
+#endif
+
   if (gdbarch_get_longjmp_target_p (current_gdbarch))
     {
       create_longjmp_breakpoint ("longjmp");
@@ -7417,7 +7567,29 @@
     }
   
   create_overlay_event_breakpoint ("_ovly_debug_event");
+
+#ifdef NATIVE_CLIENT
+    do_cleanups (my_cleanups);
+  }
+#endif
 }
+
+#ifdef NATIVE_CLIENT
+
+/* Clear the section entry for all breakpoint locations.  */
+
+void
+clear_breakpoint_loc_sections (void)
+{
+  struct bp_location *b;
+
+  ALL_BP_LOCATIONS (b)
+  {
+    b->section = NULL;
+  }
+}
+
+#endif
 
 /* Reset the thread number of this breakpoint:
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/breakpoint.h gdb-6.8/gdb/breakpoint.h
--- ../PRISTINE/gdb-6.8/gdb/breakpoint.h	2008-02-01 08:24:46.000000000 -0800
+++ gdb-6.8/gdb/breakpoint.h	2009-04-21 00:34:47.000000000 -0700
@@ -249,6 +249,11 @@
   /* This location's address is in an unloaded solib, and so this
      location should not be inserted.  It will be automatically
      enabled when that solib is loaded.  */
+#ifdef NATIVE_CLIENT
+  /* This is also used to refer to native client breakpoints when the
+     native-client program isn't loaded, either because sel_ldr hasn't
+     loaded it yet or the program isn't running.  */
+#endif
   char shlib_disabled; 
 
   /* Is this particular location enabled.  */
@@ -671,6 +676,11 @@
 
 extern int software_breakpoint_inserted_here_p (CORE_ADDR);
 
+#ifdef NATIVE_CLIENT
+extern int overlay_breakpoint_inserted_here_p (CORE_ADDR pc);
+extern void clear_breakpoint_loc_sections (void);
+#endif
+
 extern int breakpoint_thread_match (CORE_ADDR, ptid_t);
 
 extern void until_break_command (char *, int, int);
diff -Naur ../PRISTINE/gdb-6.8/gdb/config/i386/nacl-linux.mh gdb-6.8/gdb/config/i386/nacl-linux.mh
--- ../PRISTINE/gdb-6.8/gdb/config/i386/nacl-linux.mh	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/gdb/config/i386/nacl-linux.mh	2009-04-21 00:34:47.000000000 -0700
@@ -0,0 +1,13 @@
+# Host: Intel 386 running NativeClient.
+
+MH_CFLAGS = -DNATIVE_CLIENT
+
+NAT_FILE = nm-linux.h
+NATDEPFILES = inf-ptrace.o fork-child.o \
+	i386-nat.o i386-linux-nat.o i386-nacl-nat.o i386-nacl-thread.o \
+	proc-service.o linux-thread-db.o gcore.o \
+	linux-nat.o linux-fork.o
+
+# The dynamically loaded libthread_db needs access to symbols in the
+# gdb executable.
+LOADLIBES = -ldl -rdynamic
diff -Naur ../PRISTINE/gdb-6.8/gdb/configure.host gdb-6.8/gdb/configure.host
--- ../PRISTINE/gdb-6.8/gdb/configure.host	2008-01-19 07:03:50.000000000 -0800
+++ gdb-6.8/gdb/configure.host	2009-04-21 00:34:47.000000000 -0700
@@ -92,7 +92,13 @@
 			gdb_host_obs=mingw-hdep.o
 			;;
 i[34567]86-*-msdosdjgpp*) gdb_host=go32 ;;
-i[34567]86-*-linux*)	gdb_host=linux ;;
+i[34567]86-*-linux*)	gdb_host=linux
+			# Support NativeClient native debugging
+			if test "${target_cpu}" = "${host_cpu}" -a "${target_os}" = "nacl"; then
+				gdb_host=nacl-linux
+				gdb_native=yes
+			fi
+			;;
 i[34567]86-*-gnu*)	gdb_host=i386gnu ;;
 i[3456]86-*-nto*) 	gdb_host=nto ;;
 i[34567]86-*-openbsd[0-2].* | i[34567]86-*-openbsd3.[0-3])
diff -Naur ../PRISTINE/gdb-6.8/gdb/configure.tgt gdb-6.8/gdb/configure.tgt
--- ../PRISTINE/gdb-6.8/gdb/configure.tgt	2008-02-11 13:58:41.000000000 -0800
+++ gdb-6.8/gdb/configure.tgt	2009-04-21 00:34:47.000000000 -0700
@@ -199,6 +199,14 @@
 			solib-target.o corelow.o"
 	build_gdbserver=yes
 	;;
+i[34567]86-*-nacl*)
+	# Target: Intel 386 running Native Client
+	gdb_target_obs="i386-tdep.o i386-linux-tdep.o glibc-tdep.o i387-tdep.o \
+			solib.o solib-svr4.o symfile-mem.o corelow.o \
+			i386-nacl-tdep.o"
+	# No point in building gdbserver yet.
+	build_gdbserver=no
+	;;
 i[34567]86-*-*)
 	# Target: i386
 	gdb_target_obs="i386-tdep.o i387-tdep.o"
diff -Naur ../PRISTINE/gdb-6.8/gdb/defs.h gdb-6.8/gdb/defs.h
--- ../PRISTINE/gdb-6.8/gdb/defs.h	2008-01-18 09:07:39.000000000 -0800
+++ gdb-6.8/gdb/defs.h	2009-04-21 00:34:48.000000000 -0700
@@ -934,6 +934,9 @@
 
   GDB_OSABI_CYGWIN,
   GDB_OSABI_AIX,
+#ifdef NATIVE_CLIENT
+  GDB_OSABI_NACL,
+#endif
 
   GDB_OSABI_INVALID		/* keep this last */
 };
diff -Naur ../PRISTINE/gdb-6.8/gdb/exec.c gdb-6.8/gdb/exec.c
--- ../PRISTINE/gdb-6.8/gdb/exec.c	2008-01-11 05:34:14.000000000 -0800
+++ gdb-6.8/gdb/exec.c	2009-04-21 00:34:48.000000000 -0700
@@ -44,6 +44,10 @@
 
 #include "xcoffsolib.h"
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 struct vmap *map_vmap (bfd *, bfd *);
 
 void (*deprecated_file_changed_hook) (char *);
@@ -156,6 +160,107 @@
     printf_unfiltered (_("No executable file now.\n"));
 }
 
+/* Subroutine of exec_file_attach to extract the parts that
+   nacl_notify_new_executable needs.  */
+
+void
+exec_file_open (char *filename, int from_tty)
+{
+  char *scratch_pathname;
+  int scratch_chan;
+  /* For Native Client, don't set the global exec_bfd until we've opened
+     the bfd and set the appropriate nacl mode.  */
+  bfd *new_exec_bfd;
+
+  gdb_assert (filename != NULL);
+
+  scratch_chan = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, filename,
+			write_files ? O_RDWR | O_BINARY : O_RDONLY | O_BINARY,
+			0, &scratch_pathname);
+#if defined(__GO32__) || defined(_WIN32) || defined(__CYGWIN__)
+  if (scratch_chan < 0)
+    {
+      char *exename = alloca (strlen (filename) + 5);
+      strcat (strcpy (exename, filename), ".exe");
+      scratch_chan = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, exename,
+			    write_files ? O_RDWR | O_BINARY : O_RDONLY | O_BINARY, 0,
+			    &scratch_pathname);
+    }
+#endif
+  if (scratch_chan < 0)
+    perror_with_name (filename);
+
+  new_exec_bfd = bfd_fopen (scratch_pathname, gnutarget,
+			    write_files ? FOPEN_RUB : FOPEN_RB,
+			    scratch_chan);
+
+  if (!new_exec_bfd)
+    {
+      make_cleanup (xfree, scratch_pathname);
+      error (_("\"%s\": could not open as an executable file: %s"),
+	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
+    }
+
+  if (!bfd_check_format (new_exec_bfd, bfd_object))
+    {
+      /* Make sure to close exec_bfd, or else "run" might try to use
+	 it.  */
+      bfd_close (new_exec_bfd);
+      make_cleanup (xfree, scratch_pathname);
+      /* Leave exec_bfd == NULL, exec_close will skip it.  */
+      exec_close (0);
+
+      error (_("\"%s\": not in executable format: %s"),
+	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
+    }
+
+#ifdef NATIVE_CLIENT
+  /* Now that we've opened the bfd we can determine what kind of file it
+     is and set the nacl mode appropriately.  This must be done before
+     setting exec_bfd so that we set the correct exec_bfd (there's two).
+     IWBN to use observer_notify_executable_changed instead of this hack,
+     but the former is also called by reread_symbols and it's not clear
+     how to make it work in all cases.  */
+  nacl_notify_new_executable (new_exec_bfd);
+#endif
+  exec_bfd = new_exec_bfd;
+
+  /* At this point, scratch_pathname and exec_bfd->filename both point to
+     the same malloc'd string.  However exec_close() will attempt to free
+     it via the exec_bfd->filename pointer, so we need to make another copy
+     and leave exec_bfd as the new owner of the original copy. */
+  scratch_pathname = xstrdup (scratch_pathname);
+  make_cleanup (xfree, scratch_pathname);
+
+  /* FIXME - This should only be run for RS6000, but the ifdef is a poor
+     way to accomplish.  */
+#ifdef DEPRECATED_IBM6000_TARGET
+  /* Setup initial vmap. */
+
+  map_vmap (exec_bfd, 0);
+  if (vmap == NULL)
+    {
+      /* Make sure to close exec_bfd, or else "run" might try to use
+	 it.  */
+      exec_close (0);
+      error (_("\"%s\": can't find the file sections: %s"),
+	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
+    }
+#endif /* DEPRECATED_IBM6000_TARGET */
+
+  if (build_section_table (exec_bfd, &exec_ops.to_sections,
+			   &exec_ops.to_sections_end))
+    {
+      /* Make sure to close exec_bfd, or else "run" might try to use
+	 it.  */
+      exec_close (0);
+      error (_("\"%s\": can't find the file sections: %s"),
+	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
+    }
+
+  validate_files ();
+}
+
 /*  Process the first arg in ARGS as the new exec file.
 
    This function is intended to be behave essentially the same
@@ -181,6 +286,11 @@
   /* Remove any previous exec file.  */
   unpush_target (&exec_ops);
 
+#ifdef NATIVE_CLIENT
+  /* Unpushing the target should close it and reset this.  */
+  gdb_assert (exec_bfd == NULL);
+#endif
+
   /* Now open and digest the file the user requested, if any.  */
 
   if (!filename)
@@ -192,75 +302,7 @@
     }
   else
     {
-      char *scratch_pathname;
-      int scratch_chan;
-
-      scratch_chan = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, filename,
-		   write_files ? O_RDWR | O_BINARY : O_RDONLY | O_BINARY, 0,
-			    &scratch_pathname);
-#if defined(__GO32__) || defined(_WIN32) || defined(__CYGWIN__)
-      if (scratch_chan < 0)
-	{
-	  char *exename = alloca (strlen (filename) + 5);
-	  strcat (strcpy (exename, filename), ".exe");
-	  scratch_chan = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, exename,
-	     write_files ? O_RDWR | O_BINARY : O_RDONLY | O_BINARY, 0,
-	     &scratch_pathname);
-	}
-#endif
-      if (scratch_chan < 0)
-	perror_with_name (filename);
-      exec_bfd = bfd_fopen (scratch_pathname, gnutarget,
-			    write_files ? FOPEN_RUB : FOPEN_RB,
-			    scratch_chan);
-
-      if (!exec_bfd)
-	error (_("\"%s\": could not open as an executable file: %s"),
-	       scratch_pathname, bfd_errmsg (bfd_get_error ()));
-
-      /* At this point, scratch_pathname and exec_bfd->name both point to the
-         same malloc'd string.  However exec_close() will attempt to free it
-         via the exec_bfd->name pointer, so we need to make another copy and
-         leave exec_bfd as the new owner of the original copy. */
-      scratch_pathname = xstrdup (scratch_pathname);
-      make_cleanup (xfree, scratch_pathname);
-
-      if (!bfd_check_format (exec_bfd, bfd_object))
-	{
-	  /* Make sure to close exec_bfd, or else "run" might try to use
-	     it.  */
-	  exec_close (0);
-	  error (_("\"%s\": not in executable format: %s"),
-		 scratch_pathname, bfd_errmsg (bfd_get_error ()));
-	}
-
-      /* FIXME - This should only be run for RS6000, but the ifdef is a poor
-         way to accomplish.  */
-#ifdef DEPRECATED_IBM6000_TARGET
-      /* Setup initial vmap. */
-
-      map_vmap (exec_bfd, 0);
-      if (vmap == NULL)
-	{
-	  /* Make sure to close exec_bfd, or else "run" might try to use
-	     it.  */
-	  exec_close (0);
-	  error (_("\"%s\": can't find the file sections: %s"),
-		 scratch_pathname, bfd_errmsg (bfd_get_error ()));
-	}
-#endif /* DEPRECATED_IBM6000_TARGET */
-
-      if (build_section_table (exec_bfd, &exec_ops.to_sections,
-			       &exec_ops.to_sections_end))
-	{
-	  /* Make sure to close exec_bfd, or else "run" might try to use
-	     it.  */
-	  exec_close (0);
-	  error (_("\"%s\": can't find the file sections: %s"),
-		 scratch_pathname, bfd_errmsg (bfd_get_error ()));
-	}
-
-      validate_files ();
+      exec_file_open (filename, from_tty);
 
       set_gdbarch_from_file (exec_bfd);
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/exec.h gdb-6.8/gdb/exec.h
--- ../PRISTINE/gdb-6.8/gdb/exec.h	2008-01-01 14:53:09.000000000 -0800
+++ gdb-6.8/gdb/exec.h	2009-04-21 00:34:48.000000000 -0700
@@ -37,4 +37,7 @@
 /* Set the loaded address of a section.  */
 extern void exec_set_section_address (const char *, int, CORE_ADDR);
 
+/* Open FILENAME and set exec_bfd.  */
+extern void exec_file_open (char *filename, int from_tty);
+
 #endif
diff -Naur ../PRISTINE/gdb-6.8/gdb/i386-linux-nat.c gdb-6.8/gdb/i386-linux-nat.c
--- ../PRISTINE/gdb-6.8/gdb/i386-linux-nat.c	2008-01-01 14:53:10.000000000 -0800
+++ gdb-6.8/gdb/i386-linux-nat.c	2009-04-21 00:34:48.000000000 -0700
@@ -65,6 +65,7 @@
 #include "i387-tdep.h"
 #include "i386-tdep.h"
 #include "i386-linux-tdep.h"
+#include "i386-linux-nat.h"
 
 /* Defines ps_err_e, struct ps_prochandle.  */
 #include "gdb_proc_service.h"
@@ -663,7 +664,7 @@
   return i386_linux_dr_get (inferior_ptid, DR_STATUS);
 }
 
-static void
+void
 i386_linux_new_thread (ptid_t ptid)
 {
   int i;
@@ -812,8 +813,8 @@
   super_post_startup_inferior (ptid);
 }
 
-void
-_initialize_i386_linux_nat (void)
+struct target_ops *
+i386_linux_target (void)
 {
   struct target_ops *t;
 
@@ -831,7 +832,22 @@
   t->to_fetch_registers = i386_linux_fetch_inferior_registers;
   t->to_store_registers = i386_linux_store_inferior_registers;
 
+  return t;
+}
+
+void
+_initialize_i386_linux_nat (void)
+{
+#ifndef NATIVE_CLIENT
+  /* Don't do this for native-client.
+     linux_nat_add_target registers the "child" target which handles "run"
+     and there can be only one registered to_can_run.  */
+  struct target_ops *t;
+
+  t = i386_linux_target ();
+
   /* Register the target.  */
   linux_nat_add_target (t);
   linux_nat_set_new_thread (t, i386_linux_new_thread);
+#endif
 }
diff -Naur ../PRISTINE/gdb-6.8/gdb/i386-linux-nat.h gdb-6.8/gdb/i386-linux-nat.h
--- ../PRISTINE/gdb-6.8/gdb/i386-linux-nat.h	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/gdb/i386-linux-nat.h	2009-04-21 00:34:48.000000000 -0700
@@ -0,0 +1,28 @@
+/* Native-dependent code for GNU/Linux i386.
+
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef I386_LINUX_NAT_H
+#define I386_LINUX_NAT_H
+
+extern struct target_ops *i386_linux_target (void);
+
+void i386_linux_new_thread (ptid_t ptid);
+
+#endif /* I386_LINUX_NAT_H */
diff -Naur ../PRISTINE/gdb-6.8/gdb/i386-linux-tdep.c gdb-6.8/gdb/i386-linux-tdep.c
--- ../PRISTINE/gdb-6.8/gdb/i386-linux-tdep.c	2008-01-01 14:53:11.000000000 -0800
+++ gdb-6.8/gdb/i386-linux-tdep.c	2009-04-21 00:34:48.000000000 -0700
@@ -402,7 +402,7 @@
   0 * 4				/* %gs */
 };
 
-static void
+void
 i386_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
diff -Naur ../PRISTINE/gdb-6.8/gdb/i386-nacl-nat.c gdb-6.8/gdb/i386-nacl-nat.c
--- ../PRISTINE/gdb-6.8/gdb/i386-nacl-nat.c	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/gdb/i386-nacl-nat.c	2009-04-21 00:34:48.000000000 -0700
@@ -0,0 +1,203 @@
+/* Native-dependent code for NativeClient i386.
+
+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "inf-ptrace.h"
+#include "linux-nat.h"
+#include "i386-tdep.h"
+#include "i386-nacl-tdep.h"
+#include "i386-linux-nat.h"
+
+/* NOTE: Proper partitioning of *-tdep.c vs *-nat.c code is wip.  */
+
+/* The underlying target ops.
+   Need to pass some requests on to.  */
+static struct target_ops i386_linux_nat_target_ops;
+
+/* Attempt a transfer all LEN bytes starting at OFFSET between the
+   inferior's OBJECT:ANNEX space and GDB's READBUF/WRITEBUF buffer.
+   Return the number of bytes actually transferred.  */
+
+static LONGEST
+i386_nacl_nat_xfer_partial (struct target_ops *ops,
+			    enum target_object object,
+			    const char *annex, gdb_byte *readbuf,
+			    const gdb_byte *writebuf,
+			    ULONGEST offset, LONGEST len)
+{
+  /* NOTE: OFFSET cannot already contain the base offset.
+     This gets called for "x/4xb 0x102c0", for example, and these requests
+     end up here with offset == 0x102c0, and this routine can't distinguish
+     "x/4xb hello_world" vs "x/4xb 0x102c0".  */
+
+  /* NOTE: This gets called from libthread_db to fetch libpthread data.
+     It's i386-nacl-thread.c's job to ensure we're in service-runtime mode
+     before we get called. */
+
+  /* If we're in native-client mode, adjust the address by adding the
+     load-address of the native client code to OFFSET.  */
+  if (nacl_mode_p ())
+    offset += get_nacl_thread_base_offset ();
+
+  return i386_linux_nat_target_ops.to_xfer_partial (ops, object, annex,
+						    readbuf, writebuf,
+						    offset, len);
+}
+
+static int
+i386_nacl_insert_breakpoint (struct bp_target_info *bp_tgt)
+{
+  struct gdbarch *gdbarch = current_gdbarch;
+  int val;
+  const gdb_byte *bp;
+  int bplen;
+  CORE_ADDR addr;
+
+  /* Determine appropriate breakpoint contents and size for this address.  */
+  bp = gdbarch_breakpoint_from_pc
+       (gdbarch, &bp_tgt->placed_address, &bp_tgt->placed_size);
+  gdb_assert (bp != NULL);
+
+  addr = bp_tgt->placed_address;
+
+  /* Don't bypass memory_xfer_partial, the dcache may be active.
+     Breakpoints are always recorded in "service runtime" mode.
+     That is, for native-client breakpoints, the breakpoint address is the LMA.
+     Adjust the address so i386_nacl_nat_xfer_partial will DTRT.  Blech.  */
+  if (nacl_mode_p ())
+    addr -= get_nacl_thread_base_offset ();
+
+  /* Save the memory contents.  */
+  bp_tgt->shadow_len = bp_tgt->placed_size;
+  val = target_read_memory (addr, bp_tgt->shadow_contents,
+			    bp_tgt->placed_size);
+
+  /* Write the breakpoint.  */
+  if (val == 0)
+    val = target_write_memory (addr, bp, bp_tgt->placed_size);
+
+  return val;
+}
+
+static int
+i386_nacl_remove_breakpoint (struct bp_target_info *bp_tgt)
+{
+  CORE_ADDR addr = bp_tgt->placed_address;
+
+  /* Don't bypass memory_xfer_partial, the dcache may be active.
+     Breakpoints are always recorded in "service runtime" mode.
+     That is, for native-client breakpoints, the breakpoint address is the LMA.
+     Adjust the address so i386_nacl_nat_xfer_partial will DTRT.  Blech.  */
+  if (nacl_mode_p ())
+    addr -= get_nacl_thread_base_offset ();
+
+  return target_write_memory (addr, bp_tgt->shadow_contents,
+			      bp_tgt->placed_size);
+}
+
+/* Start a new inferior child process.  EXEC_FILE is the file to
+   run, ALLARGS is a string containing the arguments to the program.
+   ENV is the environment vector to pass.  If FROM_TTY is non-zero, be
+   chatty about it.
+
+   This function exists to effect the running of nacl programs,
+   which require that we run them via sel_ldr.  */
+
+static void
+i386_nacl_nat_create_inferior (char *exec_file, char *allargs, char **env,
+			       int from_tty)
+{
+  if (! native_debugging)
+    {
+      char *new_allargs = concat (sel_ldr_args,
+				  " ", exec_file, " ", allargs,
+				  NULL);
+      struct cleanup *cleanups = make_cleanup (xfree, new_allargs);
+
+      i386_linux_nat_target_ops.to_create_inferior (sel_ldr_path, new_allargs,
+						    env, from_tty);
+
+      do_cleanups (cleanups);
+    }
+  else
+    {
+      i386_linux_nat_target_ops.to_create_inferior (exec_file, allargs, env,
+						    from_tty);
+    }
+}
+
+/* Return a single-threaded i386-nacl-nat target.
+
+   ??? Another way to go is to have separate targets for linux and nacl,
+   and switch b/w them depending on nacl_mode_p ().  I dunno,
+   maybe later if it seems like the right thing to do.  */
+
+static struct target_ops *
+i386_nacl_nat_target (void)
+{
+  struct target_ops *t;
+
+  t = i386_linux_target ();
+
+  t = linux_nat_target (t);
+
+  /* Save copy, we need to refer to some of the routines we override.  */
+  i386_linux_nat_target_ops = *t;
+
+  /* Install our overrides into t.
+     Targets "underneath" us have already cached a pointer to T.
+     E.g., inf-prace.c:ptrace_ops_hack.
+     GDB's poor-man's version of target inheritance.  */
+
+  t->to_shortname = "nacl-child";
+  t->to_longname = "nacl child process";
+  t->to_doc = "NaCl process support.";
+  t->to_xfer_partial = i386_nacl_nat_xfer_partial;
+
+  /* Insn breakpoints need to be handled specially.
+     The memory r/w routines can be called for service-runtime or
+     native-client breakpoints, independent of nacl_mode_p ().
+     i386_nacl_nat_xfer_partial can't distinguish them.  */
+  t->to_insert_breakpoint = i386_nacl_insert_breakpoint;
+  t->to_remove_breakpoint = i386_nacl_remove_breakpoint;
+
+  /* When debugging a nacl program "directly" (i.e., native_debugging == 0),
+     we have to do a bit of a dance so that we run sel_ldr instead with
+     the correct arguments.  */
+  t->to_create_inferior = i386_nacl_nat_create_inferior;
+
+  return t;
+}
+
+void
+_initialize_i386_nacl_nat (void)
+{
+  struct target_ops *t;
+
+  t = i386_nacl_nat_target ();
+
+  /* Register the target.  */
+  i386_nacl_add_target (t);
+
+  /* Copied from i386-linux-nat.c to keep it all in this function.
+     ??? Do we need a different version for nacl anyway?  */
+  linux_nat_set_new_thread (t, i386_linux_new_thread);
+}
diff -Naur ../PRISTINE/gdb-6.8/gdb/i386-nacl-tdep.c gdb-6.8/gdb/i386-nacl-tdep.c
--- ../PRISTINE/gdb-6.8/gdb/i386-nacl-tdep.c	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/gdb/i386-nacl-tdep.c	2009-04-21 00:34:48.000000000 -0700
@@ -0,0 +1,905 @@
+/* Target-dependent code for NativeClient i386.
+
+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "frame.h"
+#include "value.h"
+#include "regcache.h"
+#include "inferior.h"
+#include "osabi.h"
+#include "reggroups.h"
+#include "dwarf2-frame.h"
+#include "gdb_string.h"
+#include "gdbcmd.h"
+#include "symfile.h"
+#include "completer.h"
+#include "objfiles.h"
+#include "observer.h"
+#include "exec.h"
+#include "event-top.h"
+#include "exceptions.h"
+#include "gdb_proc_service.h"
+#include "symtab.h"
+#include "linux-nat.h"
+#include "solist.h"
+#include "readline/tilde.h" /* tilde_expand */
+#include "elf/external.h"
+#include "elf/common.h"
+#include "i386-tdep.h"
+#include "i386-nacl-tdep.h"
+
+/* State to be saved/restored across nacl/runtime mode switches.
+   NOTE: This does not contain LIVE state.  Instead it contains the
+   state at the time we switched out of that mode.  */
+
+struct gdb_state
+{
+  /* From objfiles.c.  */
+  struct objfile *object_files;
+  struct objfile *current_objfile;
+  struct objfile *symfile_objfile;
+  /* Not relevant, but for completeness' sake ...  */
+  struct objfile *rt_common_objfile;
+
+  /* From exec.c.  */
+  bfd *exec_bfd;
+
+  /* From solib.c.  */
+  struct so_list *so_list_head;
+
+  /* Other things of note that aren't saved but need to be managed.
+
+     target.c:target_dcache - flushed on each mode switch (FIXME: TODO)
+  */
+};
+
+/* Saved copy of service-runtime gdb state.  */
+static struct gdb_state sr_gdb_state;
+
+/* Saved copy of nacl-client gdb state.  */
+static struct gdb_state nacl_gdb_state;
+
+/* Zero if current state is service-runtime state,
+   Non-zero if current state is nacl-client state.  */
+static int current_gdb_state_is_nacl = 0;
+
+struct cmd_list_element *nacl_list;
+struct cmd_list_element *set_nacl_list;
+struct cmd_list_element *show_nacl_list;
+
+/* Prompt used when debugging the native-client side.  */
+static char *native_client_prompt;
+
+/* The offset that nacl threads are loaded at.
+   This is like their LMA.  */
+static ULONGEST xlate_base = 0;
+
+/* This is the value of the segment regs while in service-runtime mode.
+   When libthread_db calls ps_lgetregs we need to restore these values.  */
+static unsigned int service_runtime_cs;
+static unsigned int service_runtime_ds;
+static unsigned int service_runtime_es;
+static unsigned int service_runtime_fs;
+static unsigned int service_runtime_gs;
+static unsigned int service_runtime_ss;
+
+/* Non-zero if specified file to debug on command line is a native program.
+   Zero -> native-client program.
+   This is determined from the binary.
+   As such we don't provide a command line option to specify it;
+   we don't want to have to continue to support such an option.  */
+int native_debugging = 1;
+
+/* Path to sel_ldr.
+   The default value is set later, it needs to live in malloc space.
+   NOTE: This must be set before the call to nacl_notify_new_executable.
+   Thus it is a command-line option.  */
+char *sel_ldr_path;
+
+/* A copy of sel_ldr_path for use by set/show service-runtime-path.
+   We want to support "show" but not "set" (as we may eventually support
+   "set"), but there's no way to intercept "set" before it updates the
+   value.  */
+static char *copy_sel_ldr_path;
+
+/* List of sel_ldr arguments.
+   The default value is set later, it needs to live in malloc space.  */
+char *sel_ldr_args;
+
+/* In native mode this is the path to the nacl binary.  */
+char *nacl_program_path;
+
+/* Initialize the service-runtime/native-client switching mechanism.  */
+
+static void
+init_nacl_gdb_state (void)
+{
+  memset (&nacl_gdb_state, 0, sizeof (nacl_gdb_state));
+
+  memset (&sr_gdb_state, 0, sizeof (sr_gdb_state));
+
+  current_gdb_state_is_nacl = 0;
+}
+
+static void
+switch_gdb_state (struct gdb_state *from, struct gdb_state *to)
+{
+  from->object_files = object_files;
+  from->current_objfile = current_objfile;
+  from->symfile_objfile = symfile_objfile;
+  from->rt_common_objfile = rt_common_objfile;;
+  from->exec_bfd = exec_bfd;
+  from->so_list_head = master_so_list ();
+
+  object_files = to->object_files;
+  current_objfile = to->current_objfile;
+  symfile_objfile = to->symfile_objfile;
+  rt_common_objfile = to->rt_common_objfile;
+  exec_bfd = to->exec_bfd;
+  set_so_list (to->so_list_head);
+}
+
+void
+set_sr_gdb_state (void)
+{
+  /* No-op if already there.  */
+  if (! current_gdb_state_is_nacl)
+    return;
+
+  switch_gdb_state (&nacl_gdb_state, &sr_gdb_state);
+  current_gdb_state_is_nacl = 0;
+}
+
+void
+set_nacl_gdb_state (void)
+{
+  /* No-op if already there.  */
+  if (current_gdb_state_is_nacl)
+    return;
+
+  switch_gdb_state (&sr_gdb_state, &nacl_gdb_state);
+  current_gdb_state_is_nacl = 1;
+}
+
+void
+set_nacl_gdb_state_for_ptid (ptid_t ptid)
+{
+  if (ptid_nacl_mode_p (ptid))
+    set_nacl_gdb_state ();
+  else
+    set_sr_gdb_state ();
+}
+
+static void
+do_cleanup_restore_gdb_state (void *orig_state_ptr)
+{
+  int *orig_state = orig_state_ptr;
+
+  if (*orig_state)
+    set_nacl_gdb_state ();
+  else
+    set_sr_gdb_state ();
+
+  xfree (orig_state);
+}
+
+struct cleanup *
+make_cleanup_restore_gdb_state (void)
+{
+  int *orig_state = (int *) xmalloc (sizeof (int));
+
+  *orig_state = current_gdb_state_is_nacl;
+  return make_cleanup (do_cleanup_restore_gdb_state, orig_state);
+}
+
+/* Call when the symbol table is cleared.  */
+
+void
+nacl_symbol_file_clear (int from_tty)
+{
+  /* FIXME: Anything to do?  */
+}
+
+/* Observer callback for when a new program is run,
+   or when a process is attached to.  */
+
+static void
+nacl_handle_inferior_created (struct target_ops *ops, int from_tty)
+{
+  /* Reset the indicator of whether the nacl app has been loaded,
+     in case we're re-running or re-attaching.  */
+  xlate_base = 0;
+
+  /* Start out in service-runtime mode.  */
+  set_sr_gdb_state ();
+
+  /* In case we attached.  */
+  nacl_check_app_loaded ();
+}
+
+/* Fetch the value of sel_ldr's nacl_global_xlate_base.
+   Returns zero if there's a problem in fetching its value.
+
+   The value is stored in a global so that we don't require debug info,
+   just symbol info.  */
+
+static ULONGEST
+get_xlate_base (void)
+{
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+  struct minimal_symbol *m;
+  ULONGEST xlate_base_tmp;
+
+  /* Enable the service-runtime symbol table so we can find
+     nacl_global_xlate_base.  */
+  set_sr_gdb_state ();
+
+  m = lookup_minimal_symbol ("nacl_global_xlate_base", NULL, NULL);
+  if (m == NULL)
+    {
+      do_cleanups (my_cleanups);
+      return 0;
+    }
+
+  /* If we can find the minsym, we assume the following will work.
+     Perhaps it should be wrapped in TRY_CATCH, but it's left out to
+     see if it really is necessary.  */
+  xlate_base_tmp = parse_and_eval_long ("*(unsigned*) &nacl_global_xlate_base");
+
+  do_cleanups (my_cleanups);
+  return xlate_base_tmp;
+}
+
+/* Initialize the things we can't do until the nacl program is loaded.
+
+   NOTE: This function can only be called once per run/attach.  */
+
+static void
+nacl_init_runtime_state (void)
+{
+  struct objfile *objfile;
+  struct obj_section *osect;
+  int flags = 0;
+
+  /* This function can only be called once per run/attach.
+     [Technically speaking, it *could* be called more than once, but
+     that would be a bit sloppy and indicative of a problem somewhere.  */
+  gdb_assert (! nacl_loaded_p ());
+
+  xlate_base = get_xlate_base ();
+  if (xlate_base == 0)
+    return;
+
+  /* Save the value of %gs.  We need ps_lgetregs to return this value.  */
+  {
+    struct regcache *regcache;
+    ULONGEST sreg;
+
+    regcache = get_thread_regcache (inferior_ptid);
+    regcache_raw_read_unsigned (regcache, I386_CS_REGNUM, &sreg);
+    service_runtime_cs = sreg;
+    regcache_raw_read_unsigned (regcache, I386_DS_REGNUM, &sreg);
+    service_runtime_ds = sreg;
+    regcache_raw_read_unsigned (regcache, I386_ES_REGNUM, &sreg);
+    service_runtime_es = sreg;
+    regcache_raw_read_unsigned (regcache, I386_FS_REGNUM, &sreg);
+    service_runtime_fs = sreg;
+    regcache_raw_read_unsigned (regcache, I386_GS_REGNUM, &sreg);
+    service_runtime_gs = sreg;
+    regcache_raw_read_unsigned (regcache, I386_SS_REGNUM, &sreg);
+    service_runtime_ss = sreg;
+  }
+
+  if (native_debugging)
+    {
+      struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+      set_nacl_gdb_state ();
+      objfile = symbol_file_add (nacl_program_path, 0, NULL, 0, flags);
+
+      do_cleanups (my_cleanups);
+    }
+  else
+    {
+      if (current_gdb_state_is_nacl)
+	objfile = symfile_objfile;
+      else
+	objfile = nacl_gdb_state.symfile_objfile;
+    }
+
+  /* Fiddle with the LMAs to fake an overlay.  */
+  ALL_OBJFILE_OSECTIONS (objfile, osect)
+    {
+      bfd *obfd = objfile->obfd;
+      asection *bsect = osect->the_bfd_section;
+
+      bfd_section_lma (obfd, bsect) = bsect->vma + xlate_base;
+    }
+
+  /* Add the file's sections to our section table.
+     ??? It's too bad there isn't a symbol_file_add fn that does this.  */
+  {
+    struct section_table *start;
+    struct section_table *end;
+    int count;
+
+    start = NULL;
+    if (build_section_table (objfile->obfd, &start, &end) != 0)
+      error ("Unable to build section table for NaCl program");
+
+    count = end - start;
+    if (count > 0)
+      {
+	int space = target_resize_to_sections (&current_target, count);
+	memcpy (current_target.to_sections + space,
+		start,
+		count * sizeof (*start));
+      }
+
+    xfree (start);
+  }
+
+  /* Nacl breakpoints get marked pending when we start to run because
+     we don't know the address (akin to shared library breakpoints).
+     We know them now, so reset all the addresses.  */
+  breakpoint_re_set ();
+
+  /* Getting new symbols may change our opinion about what is frameless.  */
+  reinit_frame_cache ();
+}
+
+/* Called when we hit _ovly_debug_event.
+
+   NOTE: It's important that this function only be called once per
+   inferior run.  */
+
+void
+nacl_handle_ovly_debug_event (void)
+{
+  nacl_init_runtime_state ();
+}
+
+/* Called when we attach to a program.
+   See if the nacl program has been loaded and if so initialize
+   our runtime state.  */
+
+void
+nacl_check_app_loaded (void)
+{
+  /* The nacl app has been loaded if xlate_base has been set
+     (to non-zero).  */
+  if (get_xlate_base () != 0)
+    nacl_init_runtime_state ();
+}
+
+/* Return non-zero if we're currently switched to nacl mode.  */
+
+int
+nacl_mode_p (void)
+{
+  return current_gdb_state_is_nacl;
+}
+
+/* Return non-zero if thread PTID is in nacl-mode
+   (as opposed to service-runtime mode).  */
+
+int
+ptid_nacl_mode_p (ptid_t ptid)
+{
+  struct regcache *regcache;
+  ULONGEST ds;
+  ULONGEST cs;
+  int result;
+  volatile struct gdb_exception e;
+
+  if (! target_has_execution)
+    return 0;
+
+  /* We reference service_runtime_{cs,ds} below.
+     Don't reference them until they're valid.  */
+  if (! nacl_loaded_p ())
+    return 0;
+
+  /* This may be called to help compute the prompt text.
+     If reading regs from the target error's out we'll be in an
+     finite loop of trying to get the prompt text and failing.
+     If this fails, just assume we're in service-runtime mode for now.  */
+
+  result = 0;
+
+  TRY_CATCH (e, RETURN_MASK_ALL)
+    {
+      regcache = get_thread_regcache (ptid);
+      regcache_raw_read_unsigned (regcache, I386_DS_REGNUM, &ds);
+      if (ds != service_runtime_ds)
+	{
+	  result = 1;
+	}
+      else
+	{
+	  regcache_raw_read_unsigned (regcache, I386_CS_REGNUM, &cs);
+	  if (cs != service_runtime_cs)
+	    result = 1;
+	}
+    }
+
+  return result;
+}
+
+/* Return non-zero if the native-client program has been loaded.  */
+
+int
+nacl_loaded_p (void)
+{
+  return xlate_base != 0;
+}
+
+/* This is called by handle_inferior_event when we know the target has
+   stopped.  It updates current_gdb_state_is_nacl.  We need to update
+   it early, before breakpoint detection, because we need
+   software_breakpoint_inserted_here_p to see the correct objfiles;
+   it calls section_is_mapped which loops over all objfiles.
+
+   NOTE: Because we need to be called before
+   software_breakpoint_inserted_here_p we are called before
+   adjust_pc_after_break.
+
+   This also handles stops at _ovly_debug_event.  GDB provides
+   bp_overlay_event, but it doesn't provide any way to hook into
+   handling it.  Blech.  */
+
+void
+nacl_handle_inferior_event (const struct target_waitstatus *ws, ptid_t ptid)
+{
+  switch (ws->kind)
+    {
+    case TARGET_WAITKIND_EXITED:
+    case TARGET_WAITKIND_SIGNALLED:
+      /* Program has terminated.  */
+      if (native_debugging)
+	set_sr_gdb_state ();
+      else
+	set_nacl_gdb_state ();
+      return;
+    case TARGET_WAITKIND_STOPPED:
+      break;
+    default:
+      /* ??? What to do?  */
+      return;
+    }
+
+  /* Set the current nacl mode.
+     This is needed to let symbol lookups while we're stopped use
+     the right symbol table.  */
+
+  set_nacl_gdb_state_for_ptid (ptid);
+}
+
+char *
+get_native_client_prompt (void)
+{
+  return native_client_prompt;
+}
+
+/* FIXME: When porting this to more arches, redo some of this as it's
+   not i386-specific.  */
+
+void
+i386_nacl_add_target (struct target_ops *t)
+{
+  add_target (t);
+
+  /* This is here because linux-nat.c:linux_nat_add_target does this.
+     See the TODO there though.  */
+  thread_db_init (t);
+}
+
+char *
+get_nacl_prompt (void)
+{
+  if (! target_has_execution)
+    {
+      if (native_debugging)
+	return PROMPT (0);
+      else
+	return get_native_client_prompt ();
+    }
+  else if (ptid_nacl_mode_p (inferior_ptid))
+    {
+      /* FIXME: This is the wrong place to do this.
+	 We should do it at the places where it can change:
+	 - execution stops
+	 - current thread changes
+	 - ???
+	 I believe this code is outdated though.  */
+      set_nacl_gdb_state ();
+      return get_native_client_prompt ();
+    }
+  else
+    {
+      set_sr_gdb_state ();
+      return PROMPT (0);
+    }
+}
+
+ULONGEST
+get_nacl_thread_base_offset (void)
+{
+  return xlate_base;
+}
+
+/* Update the segment regs used by the service runtime.
+   This is the value that libthread_db needs.  */
+
+struct regcache *
+i386_nacl_set_sr_seg_regs (struct regcache *p)
+{
+  struct regcache *r = regcache_dup_no_passthrough (p);
+
+  if (nacl_loaded_p ())
+    {
+      /* FIXME: There's no current way to do what we want to do, which is to
+	 supply a modified register set to fill_gregset (see ps_lgetregs).
+	 So we temporarily hack the value of readonly so we can
+	 do what we want to do.  */
+      regcache_set_readonly (r, 0);
+      regcache_raw_supply_unsigned (r, I386_CS_REGNUM, service_runtime_cs);
+      regcache_raw_supply_unsigned (r, I386_DS_REGNUM, service_runtime_ds);
+      regcache_raw_supply_unsigned (r, I386_ES_REGNUM, service_runtime_es);
+      regcache_raw_supply_unsigned (r, I386_FS_REGNUM, service_runtime_fs);
+      regcache_raw_supply_unsigned (r, I386_GS_REGNUM, service_runtime_gs);
+      regcache_raw_supply_unsigned (r, I386_SS_REGNUM, service_runtime_ss);
+      regcache_set_readonly (r, 1);
+    }
+
+  return r;
+}
+
+static void
+nacl_command (char *args, int from_tty)
+{
+  printf_unfiltered
+    ("\"nacl\" must be followed by the name of a nacl command.\n");
+  help_list (nacl_list, "nacl ", -1, gdb_stdout);
+}
+
+static void
+nacl_apply_runtime_command (char *args, int from_tty)
+{
+  struct cleanup *cleanups = make_cleanup_restore_gdb_state ();
+
+  set_sr_gdb_state ();
+  execute_command (args, from_tty);
+  do_cleanups (cleanups);
+}
+
+static void
+nacl_apply_command (char *args, int from_tty)
+{
+  struct cleanup *cleanups = make_cleanup_restore_gdb_state ();
+
+  set_nacl_gdb_state ();
+  execute_command (args, from_tty);
+  do_cleanups (cleanups);
+}
+
+static void
+set_nacl (char *arg, int from_tty)
+{
+  printf_unfiltered (_("\"set nacl\" must be followed by the name of a \"set nacl\" subcommand.\n"));
+  help_list (set_nacl_list, "set nacl ", -1, gdb_stdout);
+}
+
+static void
+show_nacl (char *args, int from_tty)
+{
+  cmd_show_list (show_nacl_list, from_tty, "");
+}
+
+static void
+set_native_client_prompt (char *args, int from_tty, struct cmd_list_element *c)
+{
+  /* FIXME: Anything else to do?  */
+}
+
+static void
+show_native_client_prompt (struct ui_file *file, int from_tty,
+			   struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file, _("The native-client prompt is \"%s\".\n"), value);
+}
+
+static void
+set_sel_ldr_path (char *args, int from_tty, struct cmd_list_element *c)
+{
+  error ("The path of the service-runtime loader must be set\n"
+	 "via the --loader command line option.");
+}
+
+static void
+show_sel_ldr_path (struct ui_file *file, int from_tty,
+		   struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file,
+		    _("The path of the service-runtime loader is \"%s\".\n"),
+		    sel_ldr_path);
+}
+
+static void
+i386_nacl_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  i386_linux_init_abi (info, gdbarch);
+}
+
+/* Return non-zero if HEADER is a native-client file.  */
+
+static int
+nacl_elf_p (Elf64_External_Ehdr *header)
+{
+  return (header->e_ident[EI_MAG0] == ELFMAG0
+          && header->e_ident[EI_MAG1] == ELFMAG1
+          && header->e_ident[EI_MAG2] == ELFMAG2
+          && header->e_ident[EI_MAG3] == ELFMAG3
+          && header->e_ident[EI_OSABI] == ELFOSABI_NACL);
+}
+
+/* Return non-zero if HEADER is an ELF file.  */
+
+static int
+elf_p (Elf64_External_Ehdr *header)
+{
+  return (header->e_ident[EI_MAG0] == ELFMAG0
+          && header->e_ident[EI_MAG1] == ELFMAG1
+          && header->e_ident[EI_MAG2] == ELFMAG2
+          && header->e_ident[EI_MAG3] == ELFMAG3);
+}
+
+/* Return non-zero if ABFD is a native-client file.
+
+   PERF: This is called by section_is_overlay and thus can get called
+   many times.  If this becomes a perf issue, we can use bfd->usrdata
+   to cache various nacl-related things.  */
+
+int
+nacl_bfd_p (bfd *abfd)
+{
+  Elf64_External_Ehdr header;
+
+  if (bfd_seek (abfd, 0, SEEK_SET) == 0
+      && bfd_bread (&header, sizeof (header), abfd) == sizeof (header)
+      && nacl_elf_p (&header))
+    return 1;
+
+  return 0;
+}
+
+/* Return non-zero if SECTION is a from native-client file.  */
+
+int
+nacl_section_p (asection *sec)
+{
+  return nacl_bfd_p (sec->owner);
+}
+
+/* Prepare to load symbols for a new executable.
+
+   There's a sequencing issue here.
+   We need to prepare for new symbols to be added but we need to know the
+   kind of executable (service-runtime or native-client) before we can add
+   the symbols.  This must be called when we have the bfd of the new
+   executable but before allocate_objfile is called, we need object_files
+   set for sr/nc mode.
+   Similarily for setting exec_bfd: We need to know the kind of executable
+   before we can set exec_bfd - it needs to be set in the right mode.  */
+
+void
+nacl_notify_new_executable (bfd *new_exec_bfd)
+{
+  Elf64_External_Ehdr header;
+
+  if (new_exec_bfd != NULL
+      && bfd_seek (new_exec_bfd, 0, SEEK_SET) == 0
+      && bfd_bread (&header, sizeof (header), new_exec_bfd) == sizeof (header))
+    {
+      if (nacl_elf_p (&header))
+	{
+	  /* If we're currently debugging a native program,
+	     switch to debugging a nacl program.  */
+	  if (native_debugging)
+	    {
+	      /* First clear both sets of symbols.  */
+	      set_sr_gdb_state ();
+	      /* Pass zero for from_tty because we don't want the query
+		 at this point.  */
+	      symbol_file_clear (0);
+	      set_nacl_gdb_state ();
+	      symbol_file_clear (0);
+
+	      /* Everything has been cleared, reset our saved state.  */
+	      init_nacl_gdb_state ();
+
+	      /* Before we set the nacl mode to native-client, install sel_ldr
+		 on the service-runtime side of things.
+		 ??? I think this is why we need to have sel_ldr_path set
+		 via a command line option.  But can't we defer setting up
+		 the service-runtime side of things?  */
+	      {
+		char *path = tilde_expand (sel_ldr_path);
+		make_cleanup (xfree, path);
+		set_sr_gdb_state ();
+		/* Note: If sel_ldr_path is invalid, this will error().  */
+		exec_file_open (path, 0);
+		symbol_file_add (path, 0, NULL, 1, 0);
+	      }
+
+	      /* Reset this AFTER calling exec_file_attach,symbol_file_add,
+		 so that when we recurse back into here the next if (for
+		 non-nacl elfs) will DTRT.
+		 ??? Perhaps we could call something lower level than
+		 exec_file_attach,symbol_file_add.  Maybe later.  */
+	      native_debugging = 0;
+	    }
+
+	  set_nacl_gdb_state ();
+	  return;
+	}
+      else if (elf_p (&header))
+	{
+	  /* If we're currently debugging a nacl program,
+	     switch to debugging a native program.  */
+	  if (! native_debugging)
+	    {
+	      /* First clear both sets of symbols.  */
+	      set_sr_gdb_state ();
+	      /* Pass zero for from_tty because we don't want the query
+		 at this point.  */
+	      symbol_file_clear (0);
+	      set_nacl_gdb_state ();
+	      symbol_file_clear (0);
+
+	      /* Everything has been cleared, reset our saved state.  */
+	      init_nacl_gdb_state ();
+
+	      native_debugging = 1;
+	    }
+
+	  set_sr_gdb_state ();
+	  return;
+	}
+
+      /* fall through */
+    }
+
+  /* This is not an ELF file.
+     Don't change anything, just load the file in the current mode.
+     This can happen for things like "file foo.srec".  */
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+extern void _initialize_i386_nacl_tdep (void);
+
+void
+_initialize_i386_nacl_tdep (void)
+{
+  struct cmd_list_element *c;
+
+  init_nacl_gdb_state ();
+
+  overlay_debugging = ovly_nacl;
+
+  /* Only set sel_ldr_path if not set via command line option.  */
+  if (sel_ldr_path == NULL)
+    sel_ldr_path = xstrdup (DEFAULT_SEL_LDR_PATH);
+  /* Initialize copy_sel_ldr_path to something so gdb doesn't crash.  */
+  copy_sel_ldr_path = xstrdup ("I'm sorry Hal, you *can* do that.");
+  sel_ldr_args = xstrdup (DEFAULT_SEL_LDR_ARGS);
+  nacl_program_path = xstrdup ("native-client-path unset");
+
+  add_prefix_cmd ("nacl", class_support, nacl_command,
+		  _("\
+Commands for nacl.\n\
+\n\
+GDB for Native Client is a little different than normal GDB.\n\
+When debugging Native Client programs there are two separate programs:\n\
+the \"service runtime\", sel_ldr_bin, and the Native Client program itself.\n\
+Each have their own set of symbols and their own \"address space\", and GDB\n\
+needs to keep them separate.\n\
+GDB does this by maintaining two separate sets of symbols, and having two\n\
+\"modes\" depending on the current value of $pc.\n\
+If the program is stopped inside the service runtime then the service\n\
+runtime's symbols are active.  If the program is stopped inside the native\n\
+client then the native client's symbols are active.\n\
+\n\
+To assist in knowing which is active, GDB uses different prompts to\n\
+identify the current mode.\n\
+(sr-gdb) <- indicates the current mode is service-runtime\n\
+(nc-gdb) <- indicates the current mode is native-client\n\
+\n\
+Breakpoints in either mode are distinguished by prefixing the address with\n\
+\"sr\" or \"nc\".\
+"),
+		  &nacl_list, "nacl ", 0 /*allow_unknown*/, &cmdlist);
+
+  add_prefix_cmd ("nacl", no_class, set_nacl,
+		  _("Generic command for setting nacl flags"),
+		  &set_nacl_list, "set nacl ", 0, &setlist);
+
+  add_prefix_cmd ("nacl", no_class, show_nacl,
+		  _("Generic command for showing nacl flags"),
+		  &show_nacl_list, "show nacl ", 0, &showlist);
+
+  native_client_prompt = xstrdup ("(nc-gdb) ");
+  add_setshow_string_cmd ("prompt", class_support,
+			  &native_client_prompt, _("\
+Set the prompt to use when debugging native-client code"), _("\
+Show the prompt to use when debugging native-client code"), NULL,
+			  set_native_client_prompt,
+			  show_native_client_prompt,
+			  &set_nacl_list, &show_nacl_list);
+
+  c = add_cmd ("apply-runtime", class_run, nacl_apply_runtime_command,
+	       _("\
+Temporarily switch to service-runtime mode and apply a command."),
+	       &nacl_list);
+  set_cmd_completer (c, command_completer);
+
+  c = add_cmd ("apply", class_run, nacl_apply_command,
+	       _("\
+Temporarily switch to native-client mode and apply a command."),
+	       &nacl_list);
+  set_cmd_completer (c, command_completer);
+
+  /* While we currently don't support setting sel_ldr_path except as a command
+     line option, we still support displaying the current value.
+     We use "set/show" (and have "set" flag an error) instead of "info" in
+     case we one day _do_ support setting sel_ldr_path this way.  */
+  add_setshow_filename_cmd ("service-runtime-path", no_class, &copy_sel_ldr_path, _("\
+Set the path of the runtime loader"), _("\
+Show the path of the runtime loader"), NULL,
+			    set_sel_ldr_path, show_sel_ldr_path,
+			    &set_nacl_list, &show_nacl_list);
+
+  add_setshow_filename_cmd ("service-runtime-args", no_class, &sel_ldr_args, _("\
+Set the arguments of the sel_ldr program"), _("\
+Show the arguments of the sel_ldr program"), NULL,
+			    NULL, NULL,
+			    &set_nacl_list, &show_nacl_list);
+
+  add_setshow_filename_cmd ("native-client-path", no_class, &nacl_program_path, _("\
+Set the path of the native client program.\n\
+For use when debugging sel_ldr_bin itself.\n\
+You still have to specify all the arguments to sel_ldr_bin, including the\n\
+native client program to run.  This option exists to tell gdb what the\n\
+native client program is.\n\
+Example:\n\
+bash$ nacl-gdb sel_ldr_bin\n\
+(gdb) set nacl native-client-path ~/hello.nexe\n\
+(gdb) run ~/hello.nexe\n\
+[...]\
+"), _("\
+Show the path of the nacl program"), NULL,
+			    NULL, NULL,
+			    &set_nacl_list, &show_nacl_list);
+
+  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_NACL,
+			  i386_nacl_init_abi);
+
+  observer_attach_inferior_created (nacl_handle_inferior_created);
+}
diff -Naur ../PRISTINE/gdb-6.8/gdb/i386-nacl-tdep.h gdb-6.8/gdb/i386-nacl-tdep.h
--- ../PRISTINE/gdb-6.8/gdb/i386-nacl-tdep.h	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/gdb/i386-nacl-tdep.h	2009-04-21 00:34:48.000000000 -0700
@@ -0,0 +1,150 @@
+/* Target-dependent code for NativeClient i386.
+
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef I386_NACL_TDEP_H
+#define I386_NACL_TDEP_H
+
+#include "i386-linux-tdep.h"
+
+#define DEFAULT_SEL_LDR_PATH "~/.mozilla/plugins/sel_ldr_bin"
+
+#define DEFAULT_SEL_LDR_ARGS ""
+
+/* FIXME: This works because top.c includes us.  It's a hack,
+   but good enough for now.  */
+#define DEFAULT_PROMPT "(sr-gdb) "
+
+/* Non-zero if specified file to debug is a native program.
+   Zero -> native-client program.  */
+extern int native_debugging;
+
+/* Path to sel_ldr.
+   The default value is set later, it needs to live in malloc space.  */
+extern char *sel_ldr_path;
+
+/* List of sel_ldr arguments.
+   The default value is set later, it needs to live in malloc space.  */
+extern char *sel_ldr_args;
+
+struct gdbarch_info;
+struct gdbarch;
+extern void i386_linux_init_abi (struct gdbarch_info info,
+				 struct gdbarch *gdbarch);
+
+/* Return non-zero if ABFD is a native-client file.  */
+
+extern int
+nacl_bfd_p (bfd *abfd);
+
+/* Return non-zero if SECTION is a from native-client file.  */
+
+extern int
+nacl_section_p (asection *sec);
+
+/* Call when a new main executable is set.  */
+
+extern void
+nacl_notify_new_executable (bfd *new_exec_bfd);
+
+/* Call when the symbol table is cleared.  */
+
+extern void
+nacl_symbol_file_clear (int from_tty);
+
+/* Called when we hit _ovly_debug_event.  */
+
+extern void
+nacl_handle_ovly_debug_event (void);
+
+/* Call after attaching to a process.
+   Checks if the nacl app has been loaded yet.  */
+
+extern void
+nacl_check_app_loaded (void);
+
+/* Set native-client/service-runtime state for PTID.  */
+
+extern void
+set_nacl_gdb_state_for_ptid (ptid_t ptid);
+
+/* Create a cleanup to restore gdb's state
+   (which is one of service-runtime or native-client).  */
+
+extern struct cleanup *
+make_cleanup_restore_gdb_state (void);
+
+/* Return a nacl thread's base address.  */
+
+extern ULONGEST
+get_nacl_thread_base_offset (void);
+
+/* Return a copy of a regcache, with the service-runtime values for the
+   segment regs filled in.
+   These are the values that libthread_db needs.  */
+
+extern struct regcache *
+i386_nacl_set_sr_seg_regs (/*const*/ struct regcache *);
+
+/* Return non-zero if we're currently switched to nacl mode.  */
+
+extern int
+nacl_mode_p (void);
+
+/* Return non-zero if thread PTID is in nacl-mode
+   (as opposed to service-runtime mode).  */
+
+extern int
+ptid_nacl_mode_p (ptid_t);
+
+/* Return non-zero if the native-client program has been loaded.  */
+
+extern int
+nacl_loaded_p (void);
+
+/* Called very early by handle_inferior_event.  */
+
+extern void
+nacl_handle_inferior_event (const struct target_waitstatus *, ptid_t ptid);
+
+/* Return the prompt to use when debugging service runtime code.
+   NOTE: This doesn't return a const char * because get_prompt doesn't.  */
+
+extern char *
+get_nacl_prompt (void);
+
+/* Register the nacl target.  */
+
+extern void
+i386_nacl_add_target (struct target_ops *);
+
+/* Fill in target_ops for nacl thread support.  */
+
+extern void nacl_init_thread_db_ops (struct target_ops *);
+
+/* Set to native client mode.  */
+
+extern void
+set_nacl_gdb_state (void);
+
+/* Set to service runtime mode.  */
+
+extern void
+set_sr_gdb_state (void);
+
+#endif /* i386-nacl-tdep.h */
diff -Naur ../PRISTINE/gdb-6.8/gdb/i386-nacl-thread.c gdb-6.8/gdb/i386-nacl-thread.c
--- ../PRISTINE/gdb-6.8/gdb/i386-nacl-thread.c	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/gdb/i386-nacl-thread.c	2009-04-21 00:34:48.000000000 -0700
@@ -0,0 +1,230 @@
+/* Wrapper to linux-thread-db.c for i386-nacl.
+
+   Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* This file contains wrappers to the target_ops routines in linux-thread-db.c.
+   It exists because we need to force the mode to service-runtime mode
+   when making calls to libthread_db.
+
+   This file may not be i386 specific, but for now it doesn't matter.  */
+
+#include "defs.h"
+#include "target.h"
+#include "i386-nacl-tdep.h"
+
+/* This module's target vector.  */
+static struct target_ops nacl_thread_ops;
+
+/* The target vector that we call for things this module can't handle.  */
+static struct target_ops linux_thread_db_ops;
+
+static void
+nacl_thread_detach (char *args, int from_tty)
+{
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  linux_thread_db_ops.to_detach (args, from_tty);
+
+  do_cleanups (my_cleanups);
+}
+
+static void
+nacl_thread_resume (ptid_t ptid, int step, enum target_signal signo)
+{
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  linux_thread_db_ops.to_resume (ptid, step, signo);
+
+  do_cleanups (my_cleanups);
+}
+
+static ptid_t
+nacl_thread_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
+{
+  ptid_t result_ptid;
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  result_ptid = linux_thread_db_ops.to_wait (ptid, ourstatus);
+
+  do_cleanups (my_cleanups);
+
+  return result_ptid;
+}
+
+static void
+nacl_thread_kill (void)
+{
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  linux_thread_db_ops.to_kill ();
+
+  do_cleanups (my_cleanups);
+}
+
+static void
+nacl_thread_mourn_inferior (void)
+{
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  linux_thread_db_ops.to_mourn_inferior ();
+
+  do_cleanups (my_cleanups);
+}
+
+static void
+nacl_thread_find_new_threads (void)
+{
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  linux_thread_db_ops.to_find_new_threads ();
+
+  do_cleanups (my_cleanups);
+}
+
+static char *
+nacl_thread_pid_to_str (ptid_t ptid)
+{
+  char *str;
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  str = linux_thread_db_ops.to_pid_to_str (ptid);
+
+  do_cleanups (my_cleanups);
+
+  return str;
+}
+
+static CORE_ADDR
+nacl_thread_get_thread_local_address (ptid_t ptid,
+					 CORE_ADDR lm,
+					 CORE_ADDR offset)
+{
+  CORE_ADDR addr;
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  addr = linux_thread_db_ops.to_get_thread_local_address (ptid, lm, offset);
+
+  do_cleanups (my_cleanups);
+
+  return addr;
+}
+
+static char *
+nacl_thread_extra_thread_info (struct thread_info *info)
+{
+  char *str;
+  struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+  /* Override the current gdb state, we need libthread_db to see the
+     service-runtime view.  */
+  set_sr_gdb_state ();
+
+  str = linux_thread_db_ops.to_extra_thread_info (info);
+
+  do_cleanups (my_cleanups);
+
+  return str;
+}
+
+/* This method is required (see add_target).
+   All we have to do is pass the request to the layer beneath us
+   (the process layer).  */
+
+static LONGEST
+nacl_thread_xfer_partial (struct target_ops *ops, enum target_object object,
+			     const char *annex,
+			     gdb_byte *readbuf, const gdb_byte *writebuf,
+			     ULONGEST offset, LONGEST len)
+{
+  return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
+					readbuf, writebuf, offset, len);
+}
+
+static void
+fill_nacl_thread_ops (struct target_ops *t)
+{
+  t->to_shortname = "nacl-multi-thread";
+  t->to_longname = "nacl multi-threaded child process.";
+  t->to_doc = "NaCl threads support.";
+  t->to_detach = nacl_thread_detach;
+  t->to_resume = nacl_thread_resume;
+  t->to_wait = nacl_thread_wait;
+  t->to_kill = nacl_thread_kill;
+  t->to_mourn_inferior = nacl_thread_mourn_inferior;
+  t->to_find_new_threads = nacl_thread_find_new_threads;
+  t->to_pid_to_str = nacl_thread_pid_to_str;
+  t->to_stratum = thread_stratum;
+  t->to_has_thread_control = tc_schedlock;
+  t->to_get_thread_local_address = nacl_thread_get_thread_local_address;
+  t->to_extra_thread_info = nacl_thread_extra_thread_info;
+  t->to_magic = OPS_MAGIC;
+
+  /* The above is what linux-thread-db.c initializes.
+     It relies upon add_target to set to_xfer_partial.
+     We don't call add_target (see i386_nacl_add_target),
+     so we set to_xfer_partial here.  */
+  t->to_xfer_partial = nacl_thread_xfer_partial;
+}
+
+void
+nacl_init_thread_db_ops (struct target_ops *thread_target)
+{
+  linux_thread_db_ops = *thread_target;
+
+  fill_nacl_thread_ops (thread_target);
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+extern void _initialize_i386_nacl_thread (void);
+
+void
+_initialize_i386_nacl_thread (void)
+{
+}
diff -Naur ../PRISTINE/gdb-6.8/gdb/inf-ptrace.c gdb-6.8/gdb/inf-ptrace.c
--- ../PRISTINE/gdb-6.8/gdb/inf-ptrace.c	2008-01-01 14:53:11.000000000 -0800
+++ gdb-6.8/gdb/inf-ptrace.c	2009-04-21 00:34:48.000000000 -0700
@@ -431,7 +431,7 @@
    inferior's OBJECT:ANNEX space and GDB's READBUF/WRITEBUF buffer.
    Return the number of bytes actually transferred.  */
 
-static LONGEST
+LONGEST
 inf_ptrace_xfer_partial (struct target_ops *ops, enum target_object object,
 			 const char *annex, gdb_byte *readbuf,
 			 const gdb_byte *writebuf,
diff -Naur ../PRISTINE/gdb-6.8/gdb/inf-ptrace.h gdb-6.8/gdb/inf-ptrace.h
--- ../PRISTINE/gdb-6.8/gdb/inf-ptrace.h	2008-01-01 14:53:11.000000000 -0800
+++ gdb-6.8/gdb/inf-ptrace.h	2009-04-21 00:34:48.000000000 -0700
@@ -33,4 +33,14 @@
   inf_ptrace_trad_target (CORE_ADDR (*register_u_offset)
 					(struct gdbarch *, int, int));
 
+/* Attempt a transfer all LEN bytes starting at OFFSET between the
+   inferior's OBJECT:ANNEX space and GDB's READBUF/WRITEBUF buffer.
+   Return the number of bytes actually transferred.  */
+
+extern LONGEST
+inf_ptrace_xfer_partial (struct target_ops *ops, enum target_object object,
+			 const char *annex, gdb_byte *readbuf,
+			 const gdb_byte *writebuf,
+			 ULONGEST offset, LONGEST len);
+
 #endif
diff -Naur ../PRISTINE/gdb-6.8/gdb/infcmd.c gdb-6.8/gdb/infcmd.c
--- ../PRISTINE/gdb-6.8/gdb/infcmd.c	2008-01-31 05:37:21.000000000 -0800
+++ gdb-6.8/gdb/infcmd.c	2009-04-21 00:34:48.000000000 -0700
@@ -477,11 +477,6 @@
      this function should probably be moved into target_pre_inferior.  */
   target_pre_inferior (from_tty);
 
-  /* Purge old solib objfiles. */
-  objfile_purge_solibs ();
-
-  clear_solib ();
-
   /* The comment here used to read, "The exec file is re-read every
      time we do a generic_mourn_inferior, so we just have to worry
      about the symbol file."  The `generic_mourn_inferior' function
@@ -1870,24 +1865,6 @@
      this function should probably be moved into target_pre_inferior.  */
   target_pre_inferior (from_tty);
 
-  /* Clear out solib state. Otherwise the solib state of the previous
-     inferior might have survived and is entirely wrong for the new
-     target.  This has been observed on GNU/Linux using glibc 2.3. How
-     to reproduce:
-
-     bash$ ./foo&
-     [1] 4711
-     bash$ ./foo&
-     [1] 4712
-     bash$ gdb ./foo
-     [...]
-     (gdb) attach 4711
-     (gdb) detach
-     (gdb) attach 4712
-     Cannot access memory at address 0xdeadbeef
-  */
-  clear_solib ();
-
   target_attach (args, from_tty);
 
   /* Set up the "saved terminal modes" of the inferior
diff -Naur ../PRISTINE/gdb-6.8/gdb/infrun.c gdb-6.8/gdb/infrun.c
--- ../PRISTINE/gdb-6.8/gdb/infrun.c	2008-01-29 14:47:19.000000000 -0800
+++ gdb-6.8/gdb/infrun.c	2009-04-21 00:34:48.000000000 -0700
@@ -49,6 +49,10 @@
 #include "gdb_assert.h"
 #include "mi/mi-common.h"
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 /* Prototypes for local functions */
 
 static void signals_info (char *, int);
@@ -1284,6 +1288,14 @@
   /* Always clear state belonging to the previous time we stopped.  */
   stop_stack_dummy = 0;
 
+#ifdef NATIVE_CLIENT
+  /* We need software_breakpoint_inserted_here_p to see the correct objfiles;
+     it calls section_is_mapped which loops over all objfiles.
+     Plus we need any symbol lookup to see the correct symbol tables.
+     NOTE: adjust_pc_after_break calls software_breakpoint_inserted_here_p.  */
+  nacl_handle_inferior_event (&ecs->ws, ecs->ptid);
+#endif
+
   adjust_pc_after_break (ecs);
 
   switch (ecs->infwait_state)
@@ -2162,6 +2174,14 @@
 	/* else fallthrough */
 
       case BPSTAT_WHAT_SINGLE:
+#ifdef NATIVE_CLIENT
+	/* FIXME: Why do overlay breakpoints end up here with no hook
+	   to do something special to handle them?  */
+	if (overlay_breakpoint_inserted_here_p (stop_pc))
+	  {
+	    nacl_handle_ovly_debug_event ();
+	  }
+#endif
         if (debug_infrun)
 	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_SINGLE\n");
 	ecs->stepping_over_breakpoint = 1;
diff -Naur ../PRISTINE/gdb-6.8/gdb/linux-nat.c gdb-6.8/gdb/linux-nat.c
--- ../PRISTINE/gdb-6.8/gdb/linux-nat.c	2008-01-29 14:47:20.000000000 -0800
+++ gdb-6.8/gdb/linux-nat.c	2009-04-21 00:40:22.000000000 -0700
@@ -29,6 +29,7 @@
 #include <sys/syscall.h>
 #endif
 #include <sys/ptrace.h>
+#include <time.h>
 #include "linux-nat.h"
 #include "linux-fork.h"
 #include "gdbthread.h"
@@ -1355,23 +1356,83 @@
 		  _("unknown ptrace event %d"), event);
 }
 
+/* Return non-zero if LWP is a zombie.  */
+
+static int
+linux_lwp_is_zombie (long lwp)
+{
+  char buffer[MAXPATHLEN];
+  FILE *procfile;
+  int retval = 0;
+
+  sprintf (buffer, "/proc/%ld/status", lwp);
+  procfile = fopen (buffer, "r");
+  if (procfile == NULL)
+    {
+      warning (_("unable to open /proc file '%s'"), buffer);
+      return 0;
+    }
+  while (fgets (buffer, sizeof (buffer), procfile) != NULL)
+    if (strcmp (buffer, "State:\tZ (zombie)\n") == 0)
+      {
+	retval = 1;
+	break;
+      }
+  fclose (procfile);
+
+  return retval;
+}
+
 /* Wait for LP to stop.  Returns the wait status, or 0 if the LWP has
    exited.  */
 
 static int
 wait_lwp (struct lwp_info *lp)
 {
-  pid_t pid;
+  pid_t pid = 0;
   int status;
   int thread_dead = 0;
 
   gdb_assert (!lp->stopped);
   gdb_assert (lp->status == 0);
 
-  pid = my_waitpid (GET_LWP (lp->ptid), &status, 0);
-  if (pid == -1 && errno == ECHILD)
+  /* The thread group leader may have exited.  If there are other threads
+     then we cannot pass 0 for flags to waitpid: the call will hang.
+     As a quick hack to work around this issue, if this is the thread
+     group leader (pid == lwp) loop calling waitpid with WNOHANG,
+     and if that returns with no status change then we check /proc to see
+     whether the thread is a zombie.  Blech.  */
+
+  if (is_lwp (lp->ptid)
+      && GET_PID (lp->ptid) == GET_LWP (lp->ptid))
     {
-      pid = my_waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
+      do
+	{
+	  pid = my_waitpid (GET_LWP (lp->ptid), &status, WNOHANG);
+	  if (pid == 0)
+	    {
+	      static const struct timespec ts = { 0, 200000000 }; /* 0.2 sec */
+	      if (linux_lwp_is_zombie (GET_LWP (lp->ptid)))
+		{
+		  if (debug_linux_nat)
+		    fprintf_unfiltered (gdb_stdlog,
+					"WL: Thread leader %s vanished.\n",
+					target_pid_to_str (lp->ptid));
+		  /* Don't delete the thread just yet.
+		     We'd still like to get its exit code.  */
+		  return 0;
+		}
+	      nanosleep (&ts, NULL);
+	    }
+	}
+      while (pid == 0);
+    }
+
+  if (pid == 0)
+    {
+      pid = my_waitpid (GET_LWP (lp->ptid), &status, 0);
+      if (pid == -1 && errno == ECHILD)
+	pid = my_waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
       if (pid == -1 && errno == ECHILD)
 	{
 	  /* The thread has previously exited.  We need to delete it
@@ -1400,7 +1461,7 @@
     }
 
   /* Check if the thread has exited.  */
-  if (WIFEXITED (status) || WIFSIGNALED (status))
+  if (! thread_dead && (WIFEXITED (status) || WIFSIGNALED (status)))
     {
       thread_dead = 1;
       if (debug_linux_nat)
@@ -2876,7 +2937,7 @@
       sprintf (fname1, "/proc/%lld/cmdline", pid);
       if ((procfile = fopen (fname1, "r")) != NULL)
 	{
-	  fgets (buffer, sizeof (buffer), procfile);
+	  gdb_assert(fgets (buffer, sizeof (buffer), procfile) != NULL);
 	  printf_filtered ("cmdline = '%s'\n", buffer);
 	  fclose (procfile);
 	}
@@ -3260,9 +3321,13 @@
   return t;
 }
 
-void
-linux_nat_add_target (struct target_ops *t)
+/* Return a linux native target, given its single-threaded cousin.  */
+
+struct target_ops *
+linux_nat_target (struct target_ops *single_threaded_target)
 {
+  struct target_ops *t = single_threaded_target;
+
   /* Save the provided single-threaded target.  We save this in a separate
      variable because another target we've inherited from (e.g. inf-ptrace)
      may have saved a pointer to T; we want to use it for the final
@@ -3282,6 +3347,17 @@
   t->to_pid_to_str = linux_nat_pid_to_str;
   t->to_has_thread_control = tc_schedlock;
 
+  return t;
+}
+
+/* Add linux native target T.
+   This is just a wrapper around add_target to also call thread_db_init.  */
+
+void
+linux_nat_add_target (struct target_ops *t)
+{
+  t = linux_nat_target (t);
+
   /* We don't change the stratum; this target will sit at
      process_stratum and thread_db will set at thread_stratum.  This
      is a little strange, since this is a multi-threaded-capable
diff -Naur ../PRISTINE/gdb-6.8/gdb/linux-nat.h gdb-6.8/gdb/linux-nat.h
--- ../PRISTINE/gdb-6.8/gdb/linux-nat.h	2008-01-23 03:26:28.000000000 -0800
+++ gdb-6.8/gdb/linux-nat.h	2009-04-21 00:34:48.000000000 -0700
@@ -111,6 +111,10 @@
 struct target_ops *
 linux_trad_target (CORE_ADDR (*register_u_offset)(struct gdbarch *, int, int));
 
+/* Return a linux native target, given its single-threaded cousin.  */
+struct target_ops *
+linux_nat_target (struct target_ops *single_threaded_target);
+
 /* Register the customized GNU/Linux target.  This should be used
    instead of calling add_target directly.  */
 void linux_nat_add_target (struct target_ops *);
diff -Naur ../PRISTINE/gdb-6.8/gdb/linux-thread-db.c gdb-6.8/gdb/linux-thread-db.c
--- ../PRISTINE/gdb-6.8/gdb/linux-thread-db.c	2008-01-23 03:26:28.000000000 -0800
+++ gdb-6.8/gdb/linux-thread-db.c	2009-04-21 00:34:48.000000000 -0700
@@ -40,6 +40,10 @@
 
 #include <signal.h>
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 #ifdef HAVE_GNU_LIBC_VERSION_H
 #include <gnu/libc-version.h>
 #endif
@@ -901,8 +905,11 @@
 	 event gets postponed by other simultaneous events.  In such a
 	 case, we want to just ignore the event and continue on.  */
 
+#if 0 /* trap_ptid is gone in CVS head,
+         and calling thread_from_lwp at this point was causing trouble */
       if (!ptid_equal (trap_ptid, null_ptid))
 	trap_ptid = thread_from_lwp (trap_ptid);
+#endif
 
       ptid = thread_from_lwp (ptid);
       if (GET_PID (ptid) == -1)
@@ -1136,6 +1143,16 @@
   thread_db_ops.to_magic = OPS_MAGIC;
 }
 
+#ifdef NATIVE_CLIENT
+
+struct target_ops *
+get_thread_db_ops (void)
+{
+  return &thread_db_ops;
+}
+
+#endif
+
 void
 _initialize_thread_db (void)
 {
@@ -1143,6 +1160,9 @@
   if (thread_db_load ())
     {
       init_thread_db_ops ();
+#ifdef NATIVE_CLIENT
+      nacl_init_thread_db_ops (&thread_db_ops);
+#endif
       add_target (&thread_db_ops);
 
       /* Add ourselves to objfile event chain.  */
diff -Naur ../PRISTINE/gdb-6.8/gdb/main.c gdb-6.8/gdb/main.c
--- ../PRISTINE/gdb-6.8/gdb/main.c	2008-01-05 08:49:53.000000000 -0800
+++ gdb-6.8/gdb/main.c	2009-04-21 00:34:48.000000000 -0700
@@ -40,6 +40,10 @@
 #include "interps.h"
 #include "main.h"
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 /* If nonzero, display time usage both at startup and for each command.  */
 
 int display_time;
@@ -285,6 +289,9 @@
       OPT_CD,
       OPT_ANNOTATE,
       OPT_STATISTICS,
+#ifdef NATIVE_CLIENT
+      OPT_LOADER,
+#endif
       OPT_TUI,
       OPT_NOWINDOWS,
       OPT_WINDOWS
@@ -350,6 +357,9 @@
       {"args", no_argument, &set_args, 1},
      {"l", required_argument, 0, 'l'},
       {"return-child-result", no_argument, &return_child_result, 1},
+#ifdef NATIVE_CLIENT
+      {"loader", required_argument, 0, OPT_LOADER},
+#endif
       {0, no_argument, 0, 0}
     };
 
@@ -533,6 +543,16 @@
 	    }
 	    break;
 
+#ifdef NATIVE_CLIENT
+	  case OPT_LOADER:
+	    /* This is a command-line option because we need the value set
+	       before the call to exec_file_attach below.  We could make it
+	       a user-settable option and deal with the extra complexity,
+	       but it generally won't be changed once set.  */
+	    sel_ldr_path = xstrdup (optarg);
+	    break;
+#endif
+
 	  case '?':
 	    fprintf_unfiltered (gdb_stderr,
 			_("Use `%s --help' for a complete list of options.\n"),
@@ -938,6 +958,12 @@
   --interpreter=INTERP\n\
                      Select a specific interpreter / user interface\n\
 "), stream);
+#ifdef NATIVE_CLIENT
+  fputs_unfiltered (_("\
+  --loader=LOADER    Specify the program loader to use.\n\
+                     The default is " DEFAULT_SEL_LDR_PATH "\n\
+"), stream);
+#endif
   fputs_unfiltered (_("\
   -l TIMEOUT         Set timeout in seconds for remote debugging.\n\
   --nw		     Do not use a window interface.\n\
@@ -966,6 +992,6 @@
   fputs_unfiltered (_("\n\
 For more information, type \"help\" from within GDB, or consult the\n\
 GDB manual (available as on-line info or a printed manual).\n\
-Report bugs to \"bug-gdb@gnu.org\".\
+For further information see http://code.google.com/p/nativeclient/.\
 "), stream);
 }
diff -Naur ../PRISTINE/gdb-6.8/gdb/osabi.c gdb-6.8/gdb/osabi.c
--- ../PRISTINE/gdb-6.8/gdb/osabi.c	2008-01-01 14:53:12.000000000 -0800
+++ gdb-6.8/gdb/osabi.c	2009-04-21 00:34:48.000000000 -0700
@@ -72,6 +72,9 @@
 
   "Cygwin",
   "AIX",
+#ifdef NATIVE_CLIENT
+  "NativeClient",
+#endif
 
   "<invalid>"
 };
@@ -532,6 +535,12 @@
 			     generic_elf_osabi_sniff_abi_tag_sections,
 			     &osabi);
       break;
+
+#ifdef NATIVE_CLIENT
+    case ELFOSABI_NACL:
+      osabi = GDB_OSABI_NACL;
+      break;
+#endif
     }
 
   if (osabi == GDB_OSABI_UNKNOWN)
diff -Naur ../PRISTINE/gdb-6.8/gdb/printcmd.c gdb-6.8/gdb/printcmd.c
--- ../PRISTINE/gdb-6.8/gdb/printcmd.c	2008-01-30 11:19:51.000000000 -0800
+++ gdb-6.8/gdb/printcmd.c	2009-04-21 00:34:48.000000000 -0700
@@ -592,7 +592,15 @@
   if (overlay_debugging)
     {
       section = find_pc_overlay (addr);
+#ifdef NATIVE_CLIENT
+      /* ??? Blech.  section_is_mapped has to loop over all objfiles when
+	 we just had it in find_pc_overlay.
+	 ??? Blech.  Why do we set SECTION only when overlay_debugging?  */
+      if ((section && ! section_is_mapped (section))
+	  || pc_in_unmapped_range (addr, section))
+#else
       if (pc_in_unmapped_range (addr, section))
+#endif
 	{
 	  *unmapped = 1;
 	  addr = overlay_mapped_address (addr, section);
diff -Naur ../PRISTINE/gdb-6.8/gdb/proc-service.c gdb-6.8/gdb/proc-service.c
--- ../PRISTINE/gdb-6.8/gdb/proc-service.c	2008-01-01 14:53:12.000000000 -0800
+++ gdb-6.8/gdb/proc-service.c	2009-04-21 00:34:48.000000000 -0700
@@ -32,6 +32,10 @@
 
 /* Prototypes for supply_gregset etc.  */
 #include "gregset.h"
+
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
 
 
 /* Fix-up some broken systems.  */
@@ -261,7 +265,20 @@
   regcache = get_thread_regcache (inferior_ptid);
 
   target_fetch_registers (regcache, -1);
+
+#ifdef NATIVE_CLIENT
+  /* Ensure gs (and other seg regs) have the correct values for
+     libthread_db.  */
+  {
+    struct regcache *dup_regcache;
+
+    dup_regcache = i386_nacl_set_sr_seg_regs (regcache);
+    fill_gregset (dup_regcache, (gdb_gregset_t *) gregset, -1);
+    regcache_xfree (dup_regcache);
+  }
+#else
   fill_gregset (regcache, (gdb_gregset_t *) gregset, -1);
+#endif
 
   do_cleanups (old_chain);
   return PS_OK;
diff -Naur ../PRISTINE/gdb-6.8/gdb/regcache.c gdb-6.8/gdb/regcache.c
--- ../PRISTINE/gdb-6.8/gdb/regcache.c	2008-03-04 12:01:21.000000000 -0800
+++ gdb-6.8/gdb/regcache.c	2009-04-21 00:34:48.000000000 -0700
@@ -385,6 +385,16 @@
   return newbuf;
 }
 
+#ifdef NATIVE_CLIENT
+
+void
+regcache_set_readonly (struct regcache *r, int readonly)
+{
+  r->readonly_p = readonly;
+}
+
+#endif
+
 int
 regcache_valid_p (const struct regcache *regcache, int regnum)
 {
@@ -565,6 +575,22 @@
   regcache_raw_write (regcache, regnum, buf);
 }
 
+#ifdef NATIVE_CLIENT
+
+void
+regcache_raw_supply_unsigned (struct regcache *regcache, int regnum,
+			      ULONGEST val)
+{
+  void *buf;
+  gdb_assert (regcache != NULL);
+  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_raw_registers);
+  buf = alloca (regcache->descr->sizeof_register[regnum]);
+  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum], val);
+  regcache_raw_supply (regcache, regnum, buf);
+}
+
+#endif
+
 void
 regcache_cooked_read (struct regcache *regcache, int regnum, gdb_byte *buf)
 {
diff -Naur ../PRISTINE/gdb-6.8/gdb/regcache.h gdb-6.8/gdb/regcache.h
--- ../PRISTINE/gdb-6.8/gdb/regcache.h	2008-02-18 08:37:17.000000000 -0800
+++ gdb-6.8/gdb/regcache.h	2009-04-21 00:34:48.000000000 -0700
@@ -146,6 +146,14 @@
 extern void regcache_cpy (struct regcache *dest, struct regcache *src);
 extern void regcache_cpy_no_passthrough (struct regcache *dest, struct regcache *src);
 
+#ifdef NATIVE_CLIENT
+extern void
+regcache_set_readonly (struct regcache *, int readonly);
+extern void
+regcache_raw_supply_unsigned (struct regcache *regcache, int regnum,
+			      ULONGEST val);
+#endif
+
 extern void registers_changed (void);
 
 #endif /* REGCACHE_H */
diff -Naur ../PRISTINE/gdb-6.8/gdb/solib.c gdb-6.8/gdb/solib.c
--- ../PRISTINE/gdb-6.8/gdb/solib.c	2008-01-07 07:19:58.000000000 -0800
+++ gdb-6.8/gdb/solib.c	2009-04-21 00:34:48.000000000 -0700
@@ -45,6 +45,10 @@
 #include "observer.h"
 #include "readline/readline.h"
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 /* Architecture-specific operations.  */
 
 /* Per-architecture data key.  */
@@ -399,6 +403,19 @@
   return so_list_head;
 }
 
+#ifdef NATIVE_CLIENT
+
+/* Set so_list_head.
+   Used when switch native-client vs service-runtime modes.  */
+
+void
+set_so_list (struct so_list *head)
+{
+  so_list_head = head;
+}
+
+#endif
+
 
 /* A small stub to get us past the arg-passing pinhole of catch_errors.  */
 
@@ -945,6 +962,24 @@
 {
   objfile_purge_solibs ();
   clear_solib ();
+
+#ifdef NATIVE_CLIENT
+  {
+    /* We need to clear both sides (maybe except for symbol_file_clear).
+       We do it here for simplicity, pending a better place.
+       Would some other target want a hook here?  */
+    struct cleanup *my_cleanups = make_cleanup_restore_gdb_state ();
+
+    if (nacl_mode_p ())
+      set_sr_gdb_state ();
+    else
+      set_nacl_gdb_state ();
+    objfile_purge_solibs ();
+    clear_solib ();
+
+    do_cleanups (my_cleanups);
+  }
+#endif
 }
 
 static void
diff -Naur ../PRISTINE/gdb-6.8/gdb/solist.h gdb-6.8/gdb/solist.h
--- ../PRISTINE/gdb-6.8/gdb/solist.h	2008-01-07 07:19:58.000000000 -0800
+++ gdb-6.8/gdb/solist.h	2009-04-21 00:34:48.000000000 -0700
@@ -127,6 +127,12 @@
 /* Return address of first so_list entry in master shared object list.  */
 struct so_list *master_so_list (void);
 
+#ifdef NATIVE_CLIENT
+/* Set so_list_head.
+   Used when switch native-client vs service-runtime modes.  */
+extern void set_so_list (struct so_list *head);
+#endif
+
 /* Find solib binary file and open it.  */
 extern int solib_open (char *in_pathname, char **found_pathname);
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/symfile.c gdb-6.8/gdb/symfile.c
--- ../PRISTINE/gdb-6.8/gdb/symfile.c	2008-01-29 14:47:20.000000000 -0800
+++ gdb-6.8/gdb/symfile.c	2009-04-21 00:34:48.000000000 -0700
@@ -62,6 +62,9 @@
 #include <time.h>
 #include <sys/time.h>
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
 
 int (*deprecated_ui_load_progress_hook) (const char *section, unsigned long num);
 void (*deprecated_show_load_progress) (const char *section,
@@ -1033,6 +1036,11 @@
       && !query ("Load new symbol table from \"%s\"? ", name))
     error (_("Not confirmed."));
 
+#ifdef NATIVE_CLIENT
+  if (mainline)
+    nacl_notify_new_executable (exec_bfd);
+#endif
+
   objfile = allocate_objfile (abfd, flags);
   discard_cleanups (my_cleanups);
 
@@ -1136,6 +1144,14 @@
 
   do_cleanups (my_cleanups);
 
+#ifdef NATIVE_CLIENT
+  /* FIXME: I don't understand why this code exists:
+     if (objfile->sf == NULL)
+       return objfile;
+     It means, for example, one can do "file foo.srec" and the symbols
+     for the previous "main" file are kept, but it's a bit hacky.  */
+#endif
+
   if (objfile->sf == NULL)
     return objfile;	/* No symbols. */
 
@@ -1218,11 +1234,19 @@
        storage has just been released, we'd better wipe the solib
        descriptors as well.
      */
+#ifdef NATIVE
+    /* This is, I think, the one case where we don't want no_shared_libraries
+       to clear both service-runtime and native-client sides.  */
+#endif
     no_shared_libraries (NULL, from_tty);
 
     symfile_objfile = NULL;
     if (from_tty)
       printf_unfiltered (_("No symbol file now.\n"));
+
+#ifdef NATIVE_CLIENT
+  nacl_symbol_file_clear (from_tty);
+#endif
 }
 
 struct build_id
@@ -2831,6 +2855,14 @@
   clear_current_source_symtab_and_line ();
 
   clear_displays ();
+#ifdef NATIVE_CLIENT
+  /* Clear out all bkpt locations, at this point they're dangling pointers.
+     We need to do this prior to calling breakpoint_re_set because in NaCl
+     we pass b->loc->section to nacl_section_p.
+     GDB 7.0 has substantial changes in this area.  A similar fix may or
+     may not be needed there.  */
+  clear_breakpoint_loc_sections ();
+#endif
   breakpoint_re_set ();
   set_default_breakpoint (0, 0, 0, 0);
   clear_pc_function_cache ();
@@ -3244,6 +3276,18 @@
 {
   /* FIXME: need bfd *, so we can use bfd_section_lma methods. */
 
+#ifdef NATIVE_CLIENT
+  /* We need to know whether a section is a nacl section before the target
+     is started, and thus before we know the load address, and thus before
+     we can compute the setion's lma.  Alas we can't use lma != vma before
+     the target is running, and thus we always just use this instead.  */
+  if (overlay_debugging == ovly_nacl)
+    {
+      /* NOTE: section->owner is NULL for *ABS* sections.  */
+      return section && section->owner && nacl_bfd_p (section->owner);
+    }
+#endif
+
   if (overlay_debugging)
     if (section && section->lma != 0 &&
 	section->vma != section->lma)
@@ -3303,6 +3347,13 @@
       /* fall thru to manual case */
     case ovly_on:		/* overlay debugging manual */
       return osect->ovly_mapped == 1;
+#ifdef NATIVE_CLIENT
+    case ovly_nacl:
+      /* If the program isn't running, overlay sections are not mapped.
+	 ??? I don't know why this isn't already checked for,
+	 perhaps just an oversight.  */
+      return target_has_execution && nacl_mode_p ();
+#endif
     }
 }
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/symfile.h gdb-6.8/gdb/symfile.h
--- ../PRISTINE/gdb-6.8/gdb/symfile.h	2008-02-03 14:13:29.000000000 -0800
+++ gdb-6.8/gdb/symfile.h	2009-04-21 00:34:48.000000000 -0700
@@ -308,6 +308,9 @@
   ovly_off,
   ovly_on,
   ovly_auto
+#ifdef NATIVE_CLIENT
+  , ovly_nacl
+#endif
 } overlay_debugging;
 extern int overlay_cache_invalid;
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/symtab.c gdb-6.8/gdb/symtab.c
--- ../PRISTINE/gdb-6.8/gdb/symtab.c	2008-02-05 14:17:40.000000000 -0800
+++ gdb-6.8/gdb/symtab.c	2009-04-21 00:34:48.000000000 -0700
@@ -2492,12 +2492,26 @@
 {
   CORE_ADDR pc;
   struct symtab_and_line sal;
+  /* Hack for Native Client.
+     GDB's symbol table handling is busted for constructors,
+     lookup_minimal_symbol may not find it and thus we won't be able to
+     set SYMBOL_BFD_SECTION.  */
+  asection *section;
 
   pc = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
   fixup_symbol_section (sym, NULL);
+
+  /* Native Client section hack.
+     If we can't find the symbol's section, then look it up via the pc.
+     Of course this is a bit bogus as it doesn't work if there are no
+     overlays.  GDB doesn't seem to have a lookup-section-given-pc
+     function and I'm loathe to add one just for this.  */
+  section = SYMBOL_BFD_SECTION (sym);
+  if (section == NULL)
+    section = find_pc_overlay (pc);
+
   if (funfirstline)
     {				/* skip "first line" of function (which is actually its prologue) */
-      asection *section = SYMBOL_BFD_SECTION (sym);
       /* If function is in an unmapped overlay, use its unmapped LMA
          address, so that gdbarch_skip_prologue has something unique to work
          on */
@@ -2511,7 +2525,7 @@
       /* For overlays, map pc back into its mapped VMA range */
       pc = overlay_mapped_address (pc, section);
     }
-  sal = find_pc_sect_line (pc, SYMBOL_BFD_SECTION (sym), 0);
+  sal = find_pc_sect_line (pc, section, 0);
 
   /* Check if gdbarch_skip_prologue left us in mid-line, and the next
      line is still part of the same function.  */
@@ -2521,8 +2535,18 @@
     {
       /* First pc of next line */
       pc = sal.end;
+
+      /* Another section hack for Native Client.
+	 If we can't find the symbol's section, then look it up via the pc.
+	 Of course this is a bit bogus as it doesn't work if there are no
+	 overlays.  GDB doesn't see to have a lookup-section-given-pc
+	 function and I'm loathe to add one just for this.  */
+      section = SYMBOL_BFD_SECTION (sym);
+      if (section == NULL)
+	section = find_pc_overlay (pc);
+
       /* Recalculate the line number (might not be N+1).  */
-      sal = find_pc_sect_line (pc, SYMBOL_BFD_SECTION (sym), 0);
+      sal = find_pc_sect_line (pc, section, 0);
     }
   sal.pc = pc;
 
@@ -4232,7 +4256,14 @@
 			* (sal->nelts + 1));
   init_sal (sal->sals + sal->nelts);
   sal->sals[sal->nelts].symtab = symtab;
+#ifdef NATIVE_CLIENT
+  /* NaCl needs the section to determine sr vs nc status.
+     I think this is the right thing to do globally, but to follow the
+     convention of this port, we #ifdef this.  */
+  sal->sals[sal->nelts].section = find_pc_overlay (pc);
+#else
   sal->sals[sal->nelts].section = NULL;
+#endif
   sal->sals[sal->nelts].end = 0;
   sal->sals[sal->nelts].line = lineno;  
   sal->sals[sal->nelts].pc = pc;
diff -Naur ../PRISTINE/gdb-6.8/gdb/target.c gdb-6.8/gdb/target.c
--- ../PRISTINE/gdb-6.8/gdb/target.c	2008-01-24 16:09:49.000000000 -0800
+++ gdb-6.8/gdb/target.c	2009-04-21 00:34:48.000000000 -0700
@@ -26,6 +26,7 @@
 #include "gdb_string.h"
 #include "target.h"
 #include "gdbcmd.h"
+#include "solib.h"
 #include "symtab.h"
 #include "inferior.h"
 #include "bfd.h"
@@ -1009,6 +1010,9 @@
 	return xfer_memory (memaddr, readbuf, len, 0, NULL, ops);
     }
 
+#ifndef NATIVE_CLIENT /* FIXME: Temp hack while getting bkpts working.
+			 This reads from the executable, but we want to
+			 exercise reading from memory.  */
   /* Likewise for accesses to unmapped overlay sections.  */
   if (readbuf != NULL && overlay_debugging)
     {
@@ -1016,6 +1020,7 @@
       if (pc_in_unmapped_range (memaddr, section))
 	return xfer_memory (memaddr, readbuf, len, 0, NULL, ops);
     }
+#endif
 
   /* Try GDB's internal data cache.  */
   region = lookup_mem_region (memaddr);
@@ -1612,6 +1617,24 @@
 void
 target_pre_inferior (int from_tty)
 {
+  /* Clear out solib state. Otherwise the solib state of the previous
+     inferior might have survived and is entirely wrong for the new
+     target.  This has been observed on GNU/Linux using glibc 2.3. How
+     to reproduce:
+
+     bash$ ./foo&
+     [1] 4711
+     bash$ ./foo&
+     [1] 4712
+     bash$ gdb ./foo
+     [...]
+     (gdb) attach 4711
+     (gdb) detach
+     (gdb) attach 4712
+     Cannot access memory at address 0xdeadbeef
+  */
+  no_shared_libraries (NULL, from_tty);
+
   invalidate_target_mem_regions ();
 
   target_clear_description ();
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/config/nacl.exp gdb-6.8/gdb/testsuite/config/nacl.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/config/nacl.exp	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/gdb/testsuite/config/nacl.exp	2009-04-21 00:34:48.000000000 -0700
@@ -0,0 +1,30 @@
+#   Copyright 2009
+#   Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Set a default timeout to be used for the tests under UNIX, rather than
+# accepting whatever default dejagnu gives us (apparently 10 seconds).
+# When running the tests over NFS, under somewhat heavy load, 10 seconds
+# does not seem to be enough.
+set timeout 30
+verbose "Timeout is now $timeout seconds" 2
+
+# load support libraries
+load_lib gdb.exp
+
+set gdb_prompt "\\((nc|sr)-gdb\\)"
+verbose "gdb_prompt is now \"$gdb_prompt\"" 2
+# Crap, we need to set both?  See ../lib/gdb.exp.
+set_board_info gdb_prompt $gdb_prompt
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-gnu-cfi.exp gdb-6.8/gdb/testsuite/gdb.arch/i386-gnu-cfi.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-gnu-cfi.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.arch/i386-gnu-cfi.exp	2009-04-21 00:34:48.000000000 -0700
@@ -34,6 +34,12 @@
     return
 }
 
+# There is assembler code in the test that is not valid for nacl.
+if [istarget "i?86-*-nacl"] then {
+    verbose "Skipping i386 unwinder tests."
+    return
+}
+
 set testfile "i386-gnu-cfi"
 set srcfilec ${testfile}.c
 set srcfileasm ${testfile}-asm.S
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-prologue.exp gdb-6.8/gdb/testsuite/gdb.arch/i386-prologue.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-prologue.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.arch/i386-prologue.exp	2009-04-21 00:34:48.000000000 -0700
@@ -32,6 +32,12 @@
     return
 }
 
+# There is assembler code in the test that is not valid for nacl.
+if [istarget "i?86-*-nacl"] then {
+    verbose "Skipping i386 prologue tests."
+    return
+}
+
 set testfile "i386-prologue"
 set srcfile ${testfile}.c
 set binfile ${objdir}/${subdir}/${testfile}
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-signal.exp gdb-6.8/gdb/testsuite/gdb.arch/i386-signal.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-signal.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.arch/i386-signal.exp	2009-04-21 00:34:48.000000000 -0700
@@ -20,6 +20,12 @@
     return
 }
 
+# There is assembler code in the test that is not valid for nacl.
+if [istarget "i?86-*-nacl"] then {
+    verbose "Skipping i386 unwinder tests."
+    return
+}
+
 set testfile "i386-signal"
 set srcfile ${testfile}.c
 set binfile ${objdir}/${subdir}/${testfile}
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-size-overlap.exp gdb-6.8/gdb/testsuite/gdb.arch/i386-size-overlap.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-size-overlap.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.arch/i386-size-overlap.exp	2009-04-21 00:34:48.000000000 -0700
@@ -22,7 +22,13 @@
 # Test that GDB can handle overlapping sizes of symbols.
 
 if ![istarget "i?86-*-*"] then {
-    verbose "Skipping i386 unwinder tests."
+    verbose "Skipping i386 overlapping size tests."
+    return
+}
+
+# There is assembler code in the test that is not valid for nacl.
+if [istarget "i?86-*-nacl"] then {
+    verbose "Skipping i386 overlapping size tests."
     return
 }
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-size.exp gdb-6.8/gdb/testsuite/gdb.arch/i386-size.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-size.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.arch/i386-size.exp	2009-04-21 00:34:48.000000000 -0700
@@ -25,7 +25,13 @@
 # Test that GDB can see the sizes of symbols.
 
 if ![istarget "i?86-*-*"] then {
-    verbose "Skipping i386 unwinder tests."
+    verbose "Skipping i386 symbol size tests."
+    return
+}
+
+# There is assembler code in the test that is not valid for nacl.
+if [istarget "i?86-*-nacl"] then {
+    verbose "Skipping i386 symbol size tests."
     return
 }
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-sse.exp gdb-6.8/gdb/testsuite/gdb.arch/i386-sse.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-sse.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.arch/i386-sse.exp	2009-04-21 00:34:48.000000000 -0700
@@ -30,6 +30,12 @@
     return
 }
 
+# There is assembler code in the test that is not valid for nacl.
+if [istarget "i?86-*-nacl"] then {
+    verbose "Skipping i386 SSE tests."
+    return
+}
+
 set testfile "i386-sse"
 set srcfile ${testfile}.c
 set binfile ${objdir}/${subdir}/${testfile}
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-unwind.exp gdb-6.8/gdb/testsuite/gdb.arch/i386-unwind.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.arch/i386-unwind.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.arch/i386-unwind.exp	2009-04-21 00:34:48.000000000 -0700
@@ -32,6 +32,12 @@
     return
 }
 
+# There is assembler code in the test that is not valid for nacl.
+if [istarget "i?86-*-nacl"] then {
+    verbose "Skipping i386 unwinder tests."
+    return
+}
+
 set testfile "i386-unwind"
 set srcfile ${testfile}.c
 set binfile ${objdir}/${subdir}/${testfile}
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/attach.exp gdb-6.8/gdb/testsuite/gdb.base/attach.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/attach.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.base/attach.exp	2009-04-21 00:34:48.000000000 -0700
@@ -38,8 +38,12 @@
 }
 
 # are we on a target board
-if [is_remote target] then {
-    return 0
+# This test fails for Native Client because target != host, but we are native.
+
+if { ![istarget "*-*-nacl"] } {
+    if [is_remote target] then {
+	return 0
+    }
 }
 
 set testfile "attach"
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/attach2.c gdb-6.8/gdb/testsuite/gdb.base/attach2.c
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/attach2.c	1999-06-28 16:02:40.000000000 -0700
+++ gdb-6.8/gdb/testsuite/gdb.base/attach2.c	2009-04-21 00:34:48.000000000 -0700
@@ -10,6 +10,23 @@
 
 int  should_exit = 0;
 
+#ifdef __native_client__
+
+/* Hack replacement for sleep().  */
+
+unsigned
+sleep (unsigned n)
+{
+  time_t now = time (NULL);
+  time_t t;
+  do {
+    t = time (NULL);
+  } while (t < now + n);
+  return 0;
+}
+
+#endif
+
 int main ()
 {
   int  local_i = 0;
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/break.exp gdb-6.8/gdb/testsuite/gdb.base/break.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/break.exp	2008-02-26 00:14:11.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.base/break.exp	2009-04-21 00:34:48.000000000 -0700
@@ -461,7 +461,7 @@
   timeout {fail "(timeout) set to-be-silent break bp_location1"}
 }
 
-send_gdb "commands $expect_out(1,string)\n"
+send_gdb "commands \$bpnum\n"
 send_gdb "silent\n"
 send_gdb "end\n"
 gdb_expect {
@@ -470,7 +470,7 @@
   timeout {fail "(timeout) set silent break bp_location1"}
 }
 
-send_gdb "info break $expect_out(1,string)\n"
+send_gdb "info break \$bpnum\n"
 gdb_expect {
   -re "\[0-9\]*\[ \t\]*breakpoint.*:$bp_location1\r\n\[ \t\]*silent.*$gdb_prompt $"\
           {pass "info silent break bp_location1"}
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/completion.exp gdb-6.8/gdb/testsuite/gdb.base/completion.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/completion.exp	2008-01-01 14:53:18.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.base/completion.exp	2009-04-21 00:34:48.000000000 -0700
@@ -591,7 +591,7 @@
 	    -re "(There are $decimal possibilities\\.  Do you really\r\nwish to see them all.|Display all $decimal possibilities.) \\(y or n\\)$" {
 		send_gdb "n"
 		gdb_expect {
-		    -re "\\(gdb\\) p no_var_named_this-$" {
+		    -re "$gdb_prompt p no_var_named_this-$" {
 			send_gdb "\n"
 			gdb_expect {
 			    -re "No symbol \"no_var_named_this\" in current context\\..*$gdb_prompt $" {
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/maint.exp gdb-6.8/gdb/testsuite/gdb.base/maint.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.base/maint.exp	2008-01-28 10:06:59.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.base/maint.exp	2009-04-21 00:34:48.000000000 -0700
@@ -483,9 +483,9 @@
 
 send_gdb "maint info breakpoints\n"
 gdb_expect {
-    -re "Num\[ \t\]+Type\[ \t\]+Disp\[ \t\]+Enb\[ \t\]+Address\[ \t\]+What\r\n1\[ \t\]+breakpoint\[ \t\]+keep\[ \t\]+y\[ \t\]+$hex\[ \t\]+in main at.*break.c:$bp_location6\r\n\[ \t\]+breakpoint already hit 1 time\r\n.*$gdb_prompt $"\
+    -re "Num\[ \t\]+Type\[ \t\]+Disp\[ \t\]+Enb\[ \t\]+Address\[ \t\]+What\r\n1\[ \t\]+breakpoint\[ \t\]+keep\[ \t\]+y\[ \t\]+$aspace_hex_addr\[ \t\]+in main at.*break.c:$bp_location6\r\n\[ \t\]+breakpoint already hit 1 time\r\n.*$gdb_prompt $"\
 		{ pass "maint info breakpoints" }
-	-re "Num\[ \t\]+Type\[ \t\]+Disp\[ \t\]+Enb\[ \t\]+Address\[ \t\]+What\r\n1\[ \t\]+breakpoint\[ \t\]+keep\[ \t\]+y\[ \t\]+$hex in main at.*break.c:$bp_location6\r\n\[ \t\]+breakpoint already hit 1 time\r\n-1\[ \t\]+shlib events\[ \t\]+keep\[ \t\]+y\[ \t\]+$hex.*breakpoint already hit.*$gdb_prompt $"\
+	-re "Num\[ \t\]+Type\[ \t\]+Disp\[ \t\]+Enb\[ \t\]+Address\[ \t\]+What\r\n1\[ \t\]+breakpoint\[ \t\]+keep\[ \t\]+y\[ \t\]+$aspace_hex_addr in main at.*break.c:$bp_location6\r\n\[ \t\]+breakpoint already hit 1 time\r\n-1\[ \t\]+shlib events\[ \t\]+keep\[ \t\]+y\[ \t\]+$aspace_hex_addr.*breakpoint already hit.*$gdb_prompt $"\
 		{ pass "maint info breakpoints (with shlib events)" }
 	-re ".*$gdb_prompt $"       { fail "maint info breakpoints" }
 	timeout         { fail "(timeout) maint info breakpoints" }
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-break.exp gdb-6.8/gdb/testsuite/gdb.mi/mi-break.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-break.exp	2008-02-01 08:24:47.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi-break.exp	2009-04-21 00:34:48.000000000 -0700
@@ -62,6 +62,7 @@
     global mi_gdb_prompt
     global srcfile
     global hex
+    global aspace_hex_addr
     global line_callee4_head line_callee4_body
     global line_callee3_head line_callee3_body
     global line_callee2_head line_callee2_body
@@ -79,24 +80,24 @@
     # -break-list
 
     mi_gdb_test "222-break-insert -t main" \
-             "222\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}" \
+             "222\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}" \
              "break-insert -t operation"
 
     mi_gdb_test "333-break-insert -t basics.c:callee2" \
-            "333\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"callee2\",file=\".*basics.c\",${fullname},line=\"$line_callee2_body\",times=\"0\"\}" \
+            "333\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee2\",file=\".*basics.c\",${fullname},line=\"$line_callee2_body\",times=\"0\"\}" \
              "insert temp breakpoint at basics.c:callee2"
 
     mi_gdb_test "444-break-insert -t basics.c:$line_callee3_head" \
-            "444\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"callee3\",file=\".*basics.c\",${fullname},line=\"$line_callee3_head\",times=\"0\"\}" \
+            "444\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee3\",file=\".*basics.c\",${fullname},line=\"$line_callee3_head\",times=\"0\"\}" \
              "insert temp breakpoint at basics.c:\$line_callee3_body"
 
     # Getting the quoting right is tricky.  That is "\"<file>\":$line_callee4_head"
     mi_gdb_test "555-break-insert -t \"\\\"${srcfile}\\\":$line_callee4_head\"" \
-            "555\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"callee4\",file=\".*basics.c\",${fullname},line=\"$line_callee4_head\",times=\"0\"\}" \
+            "555\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee4\",file=\".*basics.c\",${fullname},line=\"$line_callee4_head\",times=\"0\"\}" \
              "insert temp breakpoint at \"<fullfilename>\":\$line_callee4_head"
 
     mi_gdb_test "666-break-list" \
-     	    "666\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}.*\\\]\}" \
+     	    "666\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}.*\\\]\}" \
                 "list of breakpoints"
 
     mi_gdb_test "777-break-delete" \
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-cli.exp gdb-6.8/gdb/testsuite/gdb.mi/mi-cli.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-cli.exp	2008-01-22 11:43:10.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi-cli.exp	2009-04-21 00:34:48.000000000 -0700
@@ -84,7 +84,7 @@
   "-interpreter-exec console \"break callee4\""
 
 mi_gdb_test "-interpreter-exec console \"info break\"" \
-  {\~"Num[ \t]*Type[ \t]*Disp[ \t]*Enb[ \t]*Address[ \t]*What\\n".*~"2[ \t]*breakpoint[ \t]*keep[ \t]*y[ \t]*0x[0-9A-Fa-f]+[ \t]*in callee4 at .*basics.c:[0-9]+\\n".*\^done} \
+    [join [list {\~"Num[ \t]*Type[ \t]*Disp[ \t]*Enb[ \t]*Address[ \t]*What\\n".*~"2[ \t]*breakpoint[ \t]*keep[ \t]*y[ \t]*} $aspace_hex_addr {[ \t]*in callee4 at .*basics.c:[0-9]+\\n".*\^done}] ""] \
   "-interpreter-exec console \"info break\""
 
 mi_gdb_test "-interpreter-exec console \"set listsize 1\"" \
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-simplerun.exp gdb-6.8/gdb/testsuite/gdb.mi/mi-simplerun.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-simplerun.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi-simplerun.exp	2009-04-21 00:34:48.000000000 -0700
@@ -49,7 +49,7 @@
 proc test_breakpoints_creation_and_listing {} {
     global mi_gdb_prompt
     global srcfile
-    global hex
+    global aspace_hex_addr
 
     set line_callee4_head  [gdb_get_line_number "callee4 ("]
     set line_callee3_head  [gdb_get_line_number "callee3 ("]
@@ -67,23 +67,23 @@
     # -break-info
 
     mi_gdb_test "200-break-insert main" \
-             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\}" \
+             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\}" \
              "break-insert operation"
 
     mi_gdb_test "201-break-insert basics.c:callee2" \
-             "201\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"callee2\",file=\".*basics.c\",line=\"$line_callee2_body\",times=\"0\"\}" \
+             "201\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee2\",file=\".*basics.c\",line=\"$line_callee2_body\",times=\"0\"\}" \
              "insert breakpoint at basics.c:callee2"
 
     mi_gdb_test "202-break-insert basics.c:$line_callee3_head" \
-             "202\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"callee3\",file=\".*basics.c\",line=\"$line_callee3_head\",times=\"0\"\}" \
+             "202\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee3\",file=\".*basics.c\",line=\"$line_callee3_head\",times=\"0\"\}" \
              "insert breakpoint at basics.c:\$line_callee3_head"
 
     mi_gdb_test "203-break-insert \"\\\"${srcfile}\\\":$line_callee4_head\"" \
-             "203\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"callee4\",file=\".*basics.c\",line=\"$line_callee4_head\",times=\"0\"\}" \
+             "203\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee4\",file=\".*basics.c\",line=\"$line_callee4_head\",times=\"0\"\}" \
              "insert breakpoint at \"<fullfilename>\":\$line_callee4_head"
 
     mi_gdb_test "204-break-list" \
-	    "204\\^done,BreakpointTable=\{.*,hdr=\\\[.*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\},.*\}\\\]\}" \
+	    "204\\^done,BreakpointTable=\{.*,hdr=\\\[.*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\},.*\}\\\]\}" \
                 "list of breakpoints"
 
     mi_gdb_test "205-break-disable 2 3 4" \
@@ -112,7 +112,7 @@
     # The following is equivalent to a send_gdb "000-exec-run\n"
     mi_run_cmd
     gdb_expect {
-	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",line=\"$line_main_body\"\}\r\n$mi_gdb_prompt$" {
+	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",line=\"$line_main_body\"\}\r\n$mi_gdb_prompt$" {
 	    pass "run to main"
 	}
 	-re ".*$mi_gdb_prompt$" {
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-stack.exp gdb-6.8/gdb/testsuite/gdb.mi/mi-stack.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-stack.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi-stack.exp	2009-04-21 00:34:48.000000000 -0700
@@ -175,7 +175,7 @@
 # step until A, B, C, D have some reasonable values.
 send_gdb "-exec-next 4\n"
 gdb_expect {
-    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"callee4\",args=\\\[\\\],file=\".*${srcfile}\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_callee4_return_0\"\}\r\n$mi_gdb_prompt$" {
+    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"callee4\",args=\\\[\\\],file=\".*${srcfile}\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_callee4_return_0\"\}\r\n$mi_gdb_prompt$" {
 	pass "next's in callee4"
     }
     timeout { fail "next in callee4 (timeout)" }
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-stepi.exp gdb-6.8/gdb/testsuite/gdb.mi/mi-stepi.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-stepi.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi-stepi.exp	2009-04-21 00:34:48.000000000 -0700
@@ -49,7 +49,7 @@
 
     send_gdb "111-exec-step-instruction\n"
     gdb_expect {
-	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
+	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
 	    set line $expect_out(2,string)
 	    if { $line >= $line_main_body && $line <= $line_main_hello } {
 		pass "step-instruction at main"
@@ -63,7 +63,7 @@
     }
     send_gdb "222-exec-next-instruction\n"
     gdb_expect {
-	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
+	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
 	    set line $expect_out(2,string)
 	    if { $line >= $line_main_body && $line <= $line_main_hello } {
 		pass "next-instruction at main"
@@ -77,7 +77,7 @@
     }
     send_gdb "333-exec-next-instruction\n"
     gdb_expect {
-	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
+	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
 	    set line $expect_out(2,string)
 	    if { $line >= $line_main_body && $line <= $line_main_hello } {
 		pass "next-instruction at main"
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-until.exp gdb-6.8/gdb/testsuite/gdb.mi/mi-until.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-until.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi-until.exp	2009-04-21 00:34:48.000000000 -0700
@@ -49,15 +49,16 @@
 proc test_running_to_foo {} {
     global mi_gdb_prompt
     global hex
+    global aspace_hex_addr
 
     mi_gdb_test "200-break-insert 10" \
-             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"foo\",file=\".*until.c\",line=\"10\",times=\"0\"\}" \
+             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"foo\",file=\".*until.c\",line=\"10\",times=\"0\"\}" \
              "break-insert operation"
 
     mi_run_cmd
 
     gdb_expect {
-	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",line=\"10\"\}\r\n$mi_gdb_prompt$" {
+	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",line=\"10\"\}\r\n$mi_gdb_prompt$" {
 	    pass "run to main"
 	}
 	-re ".*$mi_gdb_prompt$" {
@@ -78,10 +79,10 @@
 
     send_gdb "111-exec-until\n"
     gdb_expect {
-	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"12\"\}\r\n$mi_gdb_prompt$" {
+	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"12\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until after while loop"
 	}
-	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"9\"\}\r\n$mi_gdb_prompt$" {
+	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"9\"\}\r\n$mi_gdb_prompt$" {
 	    kfail gdb/2104 "until after while loop (went backwards)"
 	}
 	timeout {
@@ -91,7 +92,7 @@
 
     send_gdb "222-exec-until 15\n"
     gdb_expect {
-	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"location-reached\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"15\"\}\r\n$mi_gdb_prompt$" {
+	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"location-reached\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"15\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until line number"
 	}
 	timeout {
@@ -101,7 +102,7 @@
 
     send_gdb "333-exec-until until.c:17\n"
     gdb_expect {
-	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"location-reached\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"17\"\}\r\n$mi_gdb_prompt$" {
+	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"location-reached\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"17\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until line number:file"
 	}
 	timeout {
@@ -113,7 +114,7 @@
 
     send_gdb "444-exec-until until.c:25\n"
     gdb_expect {
-	-re "444\\^running\r\n${mi_gdb_prompt}444\\*stopped,reason=\"location-reached\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(23|24)\"\}\r\n$mi_gdb_prompt$" {
+	-re "444\\^running\r\n${mi_gdb_prompt}444\\*stopped,reason=\"location-reached\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(23|24)\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until after current function"
 	}
 	timeout {
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-var-display.exp gdb-6.8/gdb/testsuite/gdb.mi/mi-var-display.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi-var-display.exp	2008-01-22 22:20:57.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi-var-display.exp	2009-04-21 00:34:48.000000000 -0700
@@ -43,13 +43,13 @@
 set line_dct_end [gdb_get_line_number "{int a = 0;}"]
 
 mi_gdb_test "200-break-insert $srcfile:$line_dct_end" \
-	"200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"do_children_tests\",file=\".*var-cmd.c\",line=\"$line_dct_end\",times=\"0\"\}" \
+	"200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"do_children_tests\",file=\".*var-cmd.c\",line=\"$line_dct_end\",times=\"0\"\}" \
 	"break-insert operation"
 
 mi_run_cmd
 # The running part has been checked already by mi_run_cmd
 gdb_expect {
-    -re "\[\r\n\]*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"do_children_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dct_end\"\}\r\n$mi_gdb_prompt$" {
+    -re "\[\r\n\]*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"do_children_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dct_end\"\}\r\n$mi_gdb_prompt$" {
 	pass "run to do_children_tests"
     }
     -re ".*$mi_gdb_prompt$" {fail "run to do_children_tests (2)"}
@@ -328,12 +328,12 @@
 set line_dst_a_1 [gdb_get_line_number "a = 1;"]
 
 mi_gdb_test "200-break-insert do_special_tests" \
-	"200\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"do_special_tests\",file=\".*var-cmd.c\",line=\"$line_dst_a_1\",times=\"0\"\}" \
+	"200\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"do_special_tests\",file=\".*var-cmd.c\",line=\"$line_dst_a_1\",times=\"0\"\}" \
 	"break-insert operation"
 
 send_gdb "-exec-continue\n"
 gdb_expect {
-    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"2\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"do_special_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dst_a_1\"\}\r\n$mi_gdb_prompt$" {
+    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"2\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"do_special_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dst_a_1\"\}\r\n$mi_gdb_prompt$" {
 	pass "continue to do_special_tests"
     }
     timeout {
@@ -589,14 +589,14 @@
 set line_incr_a_b_a [gdb_get_line_number "b = a;"]
 
 mi_gdb_test "200-break-insert incr_a" \
-	"200\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"incr_a\",file=\".*var-cmd.c\",line=\"$line_incr_a_b_a\",times=\"0\"\}" \
+	"200\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"incr_a\",file=\".*var-cmd.c\",line=\"$line_incr_a_b_a\",times=\"0\"\}" \
 	"break-insert operation"
 send_gdb "-exec-continue\n"
 gdb_expect {
-    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"3\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"incr_a\",args=\\\[\{name=\"a\",value=\"2\.*\"\}\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_incr_a_b_a\"\}\r\n$mi_gdb_prompt$" {
+    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"3\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"incr_a\",args=\\\[\{name=\"a\",value=\"2\.*\"\}\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_incr_a_b_a\"\}\r\n$mi_gdb_prompt$" {
 	pass "continue to incr_a"
     }
-    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"3\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"incr_a\",args=\\\[\{name=\"a\",value=\"\.*\"\}\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"([expr $line_incr_a_b_a - 2]|[expr $line_incr_a_b_a - 1]|$line_incr_a_b_a)\"\}\r\n$mi_gdb_prompt$" {
+    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"3\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"incr_a\",args=\\\[\{name=\"a\",value=\"\.*\"\}\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"([expr $line_incr_a_b_a - 2]|[expr $line_incr_a_b_a - 1]|$line_incr_a_b_a)\"\}\r\n$mi_gdb_prompt$" {
 	fail "continue to incr_a (compiler debug info incorrect)"
     }
     -re "\\^running\r\n${mi_gdb_prompt}.*\r\n$mi_gdb_prompt$" {
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-break.exp gdb-6.8/gdb/testsuite/gdb.mi/mi2-break.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-break.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi2-break.exp	2009-04-21 00:34:48.000000000 -0700
@@ -63,6 +63,7 @@
     global mi_gdb_prompt
     global srcfile
     global hex
+    global aspace_hex_addr
     global line_callee4_head line_callee4_body
     global line_callee3_head line_callee3_body
     global line_callee2_head line_callee2_body
@@ -80,24 +81,24 @@
     # -break-list
 
     mi_gdb_test "222-break-insert -t main" \
-             "222\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}" \
+             "222\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}" \
              "break-insert -t operation"
 
     mi_gdb_test "333-break-insert -t basics.c:callee2" \
-             "333\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"callee2\",file=\".*basics.c\",${fullname},line=\"$line_callee2_body\",times=\"0\"\}" \
+             "333\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee2\",file=\".*basics.c\",${fullname},line=\"$line_callee2_body\",times=\"0\"\}" \
              "insert temp breakpoint at basics.c:callee2"
 
     mi_gdb_test "444-break-insert -t basics.c:$line_callee3_head" \
-             "444\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"callee3\",file=\".*basics.c\",${fullname},line=\"$line_callee3_head\",times=\"0\"\}" \
+             "444\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee3\",file=\".*basics.c\",${fullname},line=\"$line_callee3_head\",times=\"0\"\}" \
              "insert temp breakpoint at basics.c:\$line_callee3_body"
 
     # Getting the quoting right is tricky.  That is "\"<file>\":$line_callee4_head"
     mi_gdb_test "555-break-insert -t \"\\\"${srcfile}\\\":$line_callee4_head\"" \
-             "555\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"callee4\",file=\".*basics.c\",${fullname},line=\"$line_callee4_head\",times=\"0\"\}" \
+             "555\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee4\",file=\".*basics.c\",${fullname},line=\"$line_callee4_head\",times=\"0\"\}" \
              "insert temp breakpoint at \"<fullfilename>\":\$line_callee4_head"
 
     mi_gdb_test "666-break-list" \
-	    "666\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}.*\\\]\}" \
+	    "666\\\^done,BreakpointTable=\{nr_rows=\".\",nr_cols=\".\",hdr=\\\[\{width=\".*\",alignment=\".*\",col_name=\"number\",colhdr=\"Num\"\}.*colhdr=\"Type\".*colhdr=\"Disp\".*colhdr=\"Enb\".*colhdr=\"Address\".*colhdr=\"What\".*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",${fullname},line=\"$line_main_body\",times=\"0\"\}.*\\\]\}" \
                 "list of breakpoints"
 
     mi_gdb_test "777-break-delete" \
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-cli.exp gdb-6.8/gdb/testsuite/gdb.mi/mi2-cli.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-cli.exp	2008-01-22 11:43:10.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi2-cli.exp	2009-04-21 00:34:48.000000000 -0700
@@ -84,7 +84,7 @@
   "-interpreter-exec console \"break callee4\""
 
 mi_gdb_test "-interpreter-exec console \"info break\"" \
-  {\~"Num[ \t]*Type[ \t]*Disp[ \t]*Enb[ \t]*Address[ \t]*What\\n".*~"2[ \t]*breakpoint[ \t]*keep[ \t]*y[ \t]*0x[0-9A-Fa-f]+[ \t]*in callee4 at .*basics.c:[0-9]+\\n".*\^done} \
+    [join [list {\~"Num[ \t]*Type[ \t]*Disp[ \t]*Enb[ \t]*Address[ \t]*What\\n".*~"2[ \t]*breakpoint[ \t]*keep[ \t]*y[ \t]*} $aspace_hex_addr {[ \t]*in callee4 at .*basics.c:[0-9]+\\n".*\^done}] ""] \
   "-interpreter-exec console \"info break\""
 
 mi_gdb_test "-interpreter-exec console \"set listsize 1\"" \
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-simplerun.exp gdb-6.8/gdb/testsuite/gdb.mi/mi2-simplerun.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-simplerun.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi2-simplerun.exp	2009-04-21 00:34:48.000000000 -0700
@@ -50,6 +50,7 @@
     global mi_gdb_prompt
     global srcfile
     global hex
+    global aspace_hex_addr
 
     set line_callee4_head  [gdb_get_line_number "callee4 ("]
     set line_callee3_head  [gdb_get_line_number "callee3 ("]
@@ -67,23 +68,23 @@
     # -break-info
 
     mi_gdb_test "200-break-insert main" \
-             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\}" \
+             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\}" \
              "break-insert operation"
 
     mi_gdb_test "201-break-insert basics.c:callee2" \
-             "201\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"callee2\",file=\".*basics.c\",line=\"$line_callee2_body\",times=\"0\"\}" \
+             "201\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee2\",file=\".*basics.c\",line=\"$line_callee2_body\",times=\"0\"\}" \
              "insert breakpoint at basics.c:callee2"
 
     mi_gdb_test "202-break-insert basics.c:$line_callee3_head" \
-             "202\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"callee3\",file=\".*basics.c\",line=\"$line_callee3_head\",times=\"0\"\}" \
+             "202\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee3\",file=\".*basics.c\",line=\"$line_callee3_head\",times=\"0\"\}" \
              "insert breakpoint at basics.c:\$line_callee3_head"
 
     mi_gdb_test "203-break-insert \"\\\"${srcfile}\\\":$line_callee4_head\"" \
-             "203\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"callee4\",file=\".*basics.c\",line=\"$line_callee4_head\",times=\"0\"\}" \
+             "203\\^done,bkpt=\{number=\"4\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"callee4\",file=\".*basics.c\",line=\"$line_callee4_head\",times=\"0\"\}" \
              "insert breakpoint at \"<fullfilename>\":\$line_callee4_head"
 
     mi_gdb_test "204-break-list" \
-	    "204\\^done,BreakpointTable=\{.*,hdr=\\\[.*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\},.*\}\\\]\}" \
+	    "204\\^done,BreakpointTable=\{.*,hdr=\\\[.*\\\],body=\\\[bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"main\",file=\".*basics.c\",line=\"$line_main_body\",times=\"0\"\},.*\}\\\]\}" \
                 "list of breakpoints"
 
     mi_gdb_test "205-break-disable 2 3 4" \
@@ -112,7 +113,7 @@
     # The following is equivalent to a send_gdb "000-exec-run\n"
     mi_run_cmd
     gdb_expect {
-	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",line=\"$line_main_body\"\}\r\n$mi_gdb_prompt$" {
+	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",line=\"$line_main_body\"\}\r\n$mi_gdb_prompt$" {
 	    pass "run to main"
 	}
 	-re ".*$mi_gdb_prompt$" {
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-stack.exp gdb-6.8/gdb/testsuite/gdb.mi/mi2-stack.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-stack.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi2-stack.exp	2009-04-21 00:34:48.000000000 -0700
@@ -175,7 +175,7 @@
 # step until A, B, C, D have some reasonable values.
 send_gdb "-exec-next 4\n"
 gdb_expect {
-    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"callee4\",args=\\\[\\\],file=\".*${srcfile}\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_callee4_return_0\"\}\r\n$mi_gdb_prompt$" {
+    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"callee4\",args=\\\[\\\],file=\".*${srcfile}\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_callee4_return_0\"\}\r\n$mi_gdb_prompt$" {
 	pass "next's in callee4"
     }
     timeout { fail "next in callee4 (timeout)" }
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-stepi.exp gdb-6.8/gdb/testsuite/gdb.mi/mi2-stepi.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-stepi.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi2-stepi.exp	2009-04-21 00:34:48.000000000 -0700
@@ -49,7 +49,7 @@
 
     send_gdb "111-exec-step-instruction\n"
     gdb_expect {
-	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
+	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
 	    set line $expect_out(2,string)
 	    if { $line >= $line_main_body && $line <= $line_main_hello } {
 		pass "step-instruction at main"
@@ -63,7 +63,7 @@
     }
     send_gdb "222-exec-next-instruction\n"
     gdb_expect {
-	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
+	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
 	    set line $expect_out(2,string)
 	    if { $line >= $line_main_body && $line <= $line_main_hello } {
 		pass "next-instruction at main"
@@ -77,7 +77,7 @@
     }
     send_gdb "333-exec-next-instruction\n"
     gdb_expect {
-	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
+	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*basics.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(\[0-9\]+)\"\}\r\n$mi_gdb_prompt$" {
 	    set line $expect_out(2,string)
 	    if { $line >= $line_main_body && $line <= $line_main_hello } {
 		pass "next-instruction at main"
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-until.exp gdb-6.8/gdb/testsuite/gdb.mi/mi2-until.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-until.exp	2008-01-01 14:53:20.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi2-until.exp	2009-04-21 00:34:48.000000000 -0700
@@ -50,15 +50,16 @@
 proc test_running_to_foo {} {
     global mi_gdb_prompt
     global hex
+    global aspace_hex_addr
 
     mi_gdb_test "200-break-insert 10" \
-             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"foo\",file=\".*until.c\",line=\"10\",times=\"0\"\}" \
+             "200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"foo\",file=\".*until.c\",line=\"10\",times=\"0\"\}" \
              "break-insert operation"
 
     mi_run_cmd
 
     gdb_expect {
-	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",line=\"10\"\}\r\n$mi_gdb_prompt$" {
+	-re "000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",line=\"10\"\}\r\n$mi_gdb_prompt$" {
 	    pass "run to main"
 	}
 	-re ".*$mi_gdb_prompt$" {
@@ -79,10 +80,10 @@
 
     send_gdb "111-exec-until\n"
     gdb_expect {
-	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"12\"\}\r\n$mi_gdb_prompt$" {
+	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"12\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until after while loop"
 	}
-	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"9\"\}\r\n$mi_gdb_prompt$" {
+	-re "111\\^running\r\n${mi_gdb_prompt}111\\*stopped,reason=\"end-stepping-range\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"9\"\}\r\n$mi_gdb_prompt$" {
 	    kfail gdb/2104 "until after while loop (went backwards)"
 	}
 	timeout {
@@ -92,7 +93,7 @@
 
     send_gdb "222-exec-until 15\n"
     gdb_expect {
-	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"location-reached\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"15\"\}\r\n$mi_gdb_prompt$" {
+	-re "222\\^running\r\n${mi_gdb_prompt}222\\*stopped,reason=\"location-reached\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"15\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until line number"
 	}
 	timeout {
@@ -102,7 +103,7 @@
 
     send_gdb "333-exec-until until.c:17\n"
     gdb_expect {
-	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"location-reached\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"17\"\}\r\n$mi_gdb_prompt$" {
+	-re "333\\^running\r\n${mi_gdb_prompt}333\\*stopped,reason=\"location-reached\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"foo\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"17\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until line number:file"
 	}
 	timeout {
@@ -114,7 +115,7 @@
 
     send_gdb "444-exec-until until.c:25\n"
     gdb_expect {
-	-re "444\\^running\r\n${mi_gdb_prompt}444\\*stopped,reason=\"location-reached\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(23|24)\"\}\r\n$mi_gdb_prompt$" {
+	-re "444\\^running\r\n${mi_gdb_prompt}444\\*stopped,reason=\"location-reached\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"main\",args=\\\[\\\],file=\".*until.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"(23|24)\"\}\r\n$mi_gdb_prompt$" {
 	    pass "until after current function"
 	}
 	timeout {
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-var-display.exp gdb-6.8/gdb/testsuite/gdb.mi/mi2-var-display.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.mi/mi2-var-display.exp	2008-01-23 13:05:16.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.mi/mi2-var-display.exp	2009-04-21 00:34:48.000000000 -0700
@@ -43,13 +43,13 @@
 set line_dct_end [gdb_get_line_number "{int a = 0;}"]
 
 mi_gdb_test "200-break-insert $srcfile:$line_dct_end" \
-	"200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"do_children_tests\",file=\".*var-cmd.c\",line=\"$line_dct_end\",times=\"0\"\}" \
+	"200\\^done,bkpt=\{number=\"1\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"do_children_tests\",file=\".*var-cmd.c\",line=\"$line_dct_end\",times=\"0\"\}" \
 	"break-insert operation"
 
 mi_run_cmd
 # The running part has been checked already by mi_run_cmd
 gdb_expect {
-    -re "\[\r\n\]*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"do_children_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dct_end\"\}\r\n$mi_gdb_prompt$" {
+    -re "\[\r\n\]*000\\*stopped,reason=\"breakpoint-hit\",bkptno=\"1\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"do_children_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dct_end\"\}\r\n$mi_gdb_prompt$" {
 	pass "run to do_children_tests"
     }
     -re ".*$mi_gdb_prompt$" {fail "run to do_children_tests (2)"}
@@ -328,12 +328,12 @@
 set line_dst_a_1 [gdb_get_line_number "a = 1;"]
 
 mi_gdb_test "200-break-insert do_special_tests" \
-	"200\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"do_special_tests\",file=\".*var-cmd.c\",line=\"$line_dst_a_1\",times=\"0\"\}" \
+	"200\\^done,bkpt=\{number=\"2\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"do_special_tests\",file=\".*var-cmd.c\",line=\"$line_dst_a_1\",times=\"0\"\}" \
 	"break-insert operation"
 
 send_gdb "-exec-continue\n"
 gdb_expect {
-    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"2\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"do_special_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dst_a_1\"\}\r\n$mi_gdb_prompt$" {
+    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"2\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"do_special_tests\",args=\\\[\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_dst_a_1\"\}\r\n$mi_gdb_prompt$" {
 	pass "continue to do_special_tests"
     }
     timeout {
@@ -589,11 +589,11 @@
 set line_incr_a_b_a [gdb_get_line_number "b = a;"]
 
 mi_gdb_test "200-break-insert incr_a" \
-	"200\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$hex\",func=\"incr_a\",file=\".*var-cmd.c\",line=\"$line_incr_a_b_a\",times=\"0\"\}" \
+	"200\\^done,bkpt=\{number=\"3\",type=\"breakpoint\",disp=\"keep\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"incr_a\",file=\".*var-cmd.c\",line=\"$line_incr_a_b_a\",times=\"0\"\}" \
 	"break-insert operation"
 send_gdb "-exec-continue\n"
 gdb_expect {
-    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"3\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"incr_a\",args=\\\[\{name=\"a\",value=\"2\.*\"\}\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_incr_a_b_a\"\}\r\n$mi_gdb_prompt$" {
+    -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"3\",thread-id=\"\[012\]\",frame=\{addr=\"$hex\",func=\"incr_a\",args=\\\[\{name=\"a\",value=\"2\.*\"\}\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"$line_incr_a_b_a\"\}\r\n$mi_gdb_prompt$" {
 	pass "continue to incr_a"
     }
     -re "\\^running\r\n${mi_gdb_prompt}\\*stopped,reason=\"breakpoint-hit\",bkptno=\"3\",thread-id=\"\[01\]\",frame=\{addr=\"$hex\",func=\"incr_a\",args=\\\[\{name=\"a\",value=\"\.*\"\}\\\],file=\".*var-cmd.c\",fullname=\"${fullname_syntax}${srcfile}\",line=\"([expr $line_incr_a_b_a - 2]|[expr $line_incr_a_b_a - 1]|$line_incr_a_b_a)\"\}\r\n$mi_gdb_prompt$" {
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.threads/schedlock.exp gdb-6.8/gdb/testsuite/gdb.threads/schedlock.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/gdb.threads/schedlock.exp	2008-01-01 14:53:22.000000000 -0800
+++ gdb-6.8/gdb/testsuite/gdb.threads/schedlock.exp	2009-04-21 00:34:48.000000000 -0700
@@ -116,6 +116,9 @@
   stop_process "stop all threads ($msg)"
 
   # Make sure we're in one of the non-main looping threads.
+  # In Native Client, we could wind up in the main thread.
+  gdb_test "thread 2" ""
+
   gdb_breakpoint [concat [gdb_get_line_number "schedlock.exp: main loop"] " if arg != 0"]
   gdb_continue_to_breakpoint "return to loop ($msg)"
   delete_breakpoints
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/lib/gdb.exp gdb-6.8/gdb/testsuite/lib/gdb.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/lib/gdb.exp	2008-01-22 22:20:34.000000000 -0800
+++ gdb-6.8/gdb/testsuite/lib/gdb.exp	2009-04-21 00:34:48.000000000 -0700
@@ -87,6 +87,9 @@
 
 set octal "\[0-7\]+"
 
+# An address with an address space.  E.g. "nc:0x1234".
+set aspace_hex_addr "(\[a-z\]*:)?$hex"
+
 ### Only procedures should come after this point.
 
 #
@@ -1154,7 +1157,7 @@
 	perror "Spawning $GDB failed."
 	return 1;
     }
-    gdb_expect 360 {
+    gdb_expect $timeout {
 	-re "\[\r\n\]$gdb_prompt $" {
 	    verbose "GDB initialized."
 	}
@@ -1163,7 +1166,7 @@
 	    return -1
 	}
 	timeout	{
-	    perror "(timeout) GDB never initialized after 10 seconds."
+	    perror "(timeout) GDB never initialized after $timeout seconds."
 	    remote_close host;
 	    return -1
 	}
@@ -2371,7 +2374,7 @@
     # Don't bother to check the output of the program, that may be
     # extremely tough for some remote systems.
     gdb_test "continue"\
-      "Continuing.\[\r\n0-9\]+(... EXIT code 0\[\r\n\]+|Program exited normally\\.).*"\
+      "Continuing.*(... EXIT code 0\[\r\n\]+|Program exited normally\\.).*"\
       "continue until exit at $mssg"
   }
 }
diff -Naur ../PRISTINE/gdb-6.8/gdb/testsuite/lib/mi-support.exp gdb-6.8/gdb/testsuite/lib/mi-support.exp
--- ../PRISTINE/gdb-6.8/gdb/testsuite/lib/mi-support.exp	2008-01-29 11:36:58.000000000 -0800
+++ gdb-6.8/gdb/testsuite/lib/mi-support.exp	2009-04-21 00:34:48.000000000 -0700
@@ -864,10 +864,11 @@
 
   global mi_gdb_prompt expect_out
   global hex decimal fullname_syntax
+  global aspace_hex_addr
 
   set test "mi runto $func"
   mi_gdb_test "200-break-insert -t $func" \
-    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$hex\",func=\"$func\(\\\(.*\\\)\)?\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}" \
+    "200\\^done,bkpt=\{number=\"\[0-9\]+\",type=\"breakpoint\",disp=\"del\",enabled=\"y\",addr=\"$aspace_hex_addr\",func=\"$func\(\\\(.*\\\)\)?\",file=\".*\",line=\"\[0-9\]*\",times=\"0\"\}" \
     "breakpoint at $func"
 
   if {![regexp {number="[0-9]+"} $expect_out(buffer) str]
diff -Naur ../PRISTINE/gdb-6.8/gdb/thread.c gdb-6.8/gdb/thread.c
--- ../PRISTINE/gdb-6.8/gdb/thread.c	2008-03-12 15:22:06.000000000 -0700
+++ gdb-6.8/gdb/thread.c	2009-04-21 00:34:48.000000000 -0700
@@ -40,6 +40,10 @@
 #include <signal.h>
 #include "ui-out.h"
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 /* Definition of struct thread_info exported to gdbthread.h */
 
 /* Prototypes for exported functions. */
@@ -471,6 +475,10 @@
   reinit_frame_cache ();
   registers_changed ();
   stop_pc = read_pc ();
+
+#ifdef NATIVE_CLIENT
+  set_nacl_gdb_state_for_ptid (ptid);
+#endif
 }
 
 static void
diff -Naur ../PRISTINE/gdb-6.8/gdb/top.c gdb-6.8/gdb/top.c
--- ../PRISTINE/gdb-6.8/gdb/top.c	2008-01-01 14:53:13.000000000 -0800
+++ gdb-6.8/gdb/top.c	2009-04-21 00:34:48.000000000 -0700
@@ -63,6 +63,10 @@
 #include "ui-out.h"
 #include "cli-out.h"
 
+#ifdef NATIVE_CLIENT
+#include "i386-nacl-tdep.h"
+#endif
+
 /* Default command line prompt.  This is overriden in some configs. */
 
 #ifndef DEFAULT_PROMPT
@@ -1179,7 +1183,11 @@
 char *
 get_prompt (void)
 {
+#ifdef NATIVE_CLIENT
+  return get_nacl_prompt ();
+#else
   return PROMPT (0);
+#endif
 }
 
 void
diff -Naur ../PRISTINE/gdb-6.8/gdb/ui-out.c gdb-6.8/gdb/ui-out.c
--- ../PRISTINE/gdb-6.8/gdb/ui-out.c	2008-01-11 05:34:15.000000000 -0800
+++ gdb-6.8/gdb/ui-out.c	2009-04-21 00:34:48.000000000 -0700
@@ -507,6 +507,35 @@
   ui_out_field_string (uiout, fldname, addstr);
 }
 
+#ifdef NATIVE_CLIENT
+
+void
+ui_out_field_aspace_core_addr (struct ui_out *uiout,
+			       const char *fldname,
+			       const char *aspace,
+			       CORE_ADDR address)
+{
+  char addstr[10 + 20];
+  int addr_bit = gdbarch_addr_bit (current_gdbarch);
+  int width;
+
+  if (addr_bit < (sizeof (CORE_ADDR) * HOST_CHAR_BIT))
+    address &= ((CORE_ADDR) 1 << addr_bit) - 1;
+
+  /* FIXME: cagney/2002-05-03: Need local_address_string() function
+     that returns the language localized string formatted to a width
+     based on gdbarch_addr_bit.  */
+  if (addr_bit <= 32)
+    width = 8;
+  else
+    width = 16;
+  sprintf (addstr, "%s:%s", aspace, hex_string_custom (address, width));
+
+  ui_out_field_string (uiout, fldname, addstr);
+}
+
+#endif
+
 void
 ui_out_field_stream (struct ui_out *uiout,
 		     const char *fldname,
diff -Naur ../PRISTINE/gdb-6.8/gdb/ui-out.h gdb-6.8/gdb/ui-out.h
--- ../PRISTINE/gdb-6.8/gdb/ui-out.h	2008-01-01 14:53:13.000000000 -0800
+++ gdb-6.8/gdb/ui-out.h	2009-04-21 00:34:48.000000000 -0700
@@ -117,6 +117,11 @@
 extern void ui_out_field_core_addr (struct ui_out *uiout, const char *fldname,
 				    CORE_ADDR address);
 
+#ifdef NATIVE_CLIENT
+extern void ui_out_field_aspace_core_addr (struct ui_out *uiout, const char *fldname,
+					   const char *aspace, CORE_ADDR address);
+#endif
+
 extern void ui_out_field_string (struct ui_out * uiout, const char *fldname,
 				 const char *string);
 
diff -Naur ../PRISTINE/gdb-6.8/gdb/version.in gdb-6.8/gdb/version.in
--- ../PRISTINE/gdb-6.8/gdb/version.in	2008-03-27 11:06:49.000000000 -0700
+++ gdb-6.8/gdb/version.in	2009-04-21 00:34:48.000000000 -0700
@@ -1 +1 @@
-6.8
+6.8-nacl-beta1
diff -Naur ../PRISTINE/gdb-6.8/include/elf/common.h gdb-6.8/include/elf/common.h
--- ../PRISTINE/gdb-6.8/include/elf/common.h	2008-01-16 14:01:42.000000000 -0800
+++ gdb-6.8/include/elf/common.h	2009-04-21 00:34:48.000000000 -0700
@@ -75,6 +75,7 @@
 #define ELFOSABI_NSK	     14	/* Hewlett-Packard Non-Stop Kernel */
 #define ELFOSABI_AROS	     15	/* Amiga Research OS */
 #define ELFOSABI_ARM	     97	/* ARM */
+#define ELFOSABI_NACL	    123	/* x86 NativeClient */
 #define ELFOSABI_STANDALONE 255	/* Standalone (embedded) application */
 
 #define EI_ABIVERSION	8	/* ABI version */
diff -Naur ../PRISTINE/gdb-6.8/include/elf/nacl.h gdb-6.8/include/elf/nacl.h
--- ../PRISTINE/gdb-6.8/include/elf/nacl.h	1969-12-31 16:00:00.000000000 -0800
+++ gdb-6.8/include/elf/nacl.h	2009-04-21 00:34:48.000000000 -0700
@@ -0,0 +1,33 @@
+/* ix86 ELF support for BFD.
+   Copyright 1998, 1999, 2000, 2002, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_NACL_H
+#define _ELF_NACL_H
+
+/* e_flags settings for NativeClient. */
+#define EF_NACL_ALIGN_MASK  0x300000	/* bits indicating alignment */
+#define EF_NACL_ALIGN_16    0x100000	/* aligned zero mod 16 */
+#define EF_NACL_ALIGN_32    0x200000	/* aligned zero mod 32 */ 
+#define EF_NACL_ALIGN_LIB   0x000000	/* aligned to pass either way */
+
+/* ABI version number -- increment when ABI changes are incompatible. */
+#define EF_NACL_ABIVERSION  6
+
+#endif
diff -Naur ../PRISTINE/gdb-6.8/opcodes/i386-opc.tbl gdb-6.8/opcodes/i386-opc.tbl
--- ../PRISTINE/gdb-6.8/opcodes/i386-opc.tbl	2008-02-23 09:29:17.000000000 -0800
+++ gdb-6.8/opcodes/i386-opc.tbl	2009-04-21 00:34:48.000000000 -0700
@@ -205,6 +205,12 @@
 or, 2, 0xc, None, 1, 0, W|No_sSuf|No_ldSuf, { Imm8|Imm16|Imm32|Imm32S, Acc|Byte|Word|Dword|Qword }
 or, 2, 0x80, 0x1, 1, 0, W|Modrm|No_sSuf|No_ldSuf, { Imm8|Imm16|Imm32|Imm32S, Reg8|Reg16|Reg32|Reg64|Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 
+// Native client support instructions.
+nacland, 2, 0x81, 0x4, 1, 0, D|W|Modrm|No_sSuf|No_ldSuf, { Imm32, Reg32 }
+naclor, 2, 0x81, 0x1, 1, 0, D|W|Modrm|No_sSuf|No_ldSuf, { Imm32, Reg32 }
+naclcall, 1, 0xff, 0x2, 1, 0, Modrm|DefaultSize|No_bSuf|No_lSuf|No_qSuf|No_sSuf|No_ldSuf, { Reg32 }
+nacljmp, 1, 0xff, 0x4, 1, 0, Modrm|DefaultSize|No_bSuf|No_lSuf|No_qSuf|No_sSuf|No_ldSuf, { Reg32 }
+
 xor, 2, 0x30, None, 1, 0, D|W|Modrm|No_sSuf|No_ldSuf, { Reg8|Reg16|Reg32|Reg64, Reg8|Reg16|Reg32|Reg64|Byte|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 xor, 2, 0x83, 0x6, 1, 0, Modrm|No_bSuf|No_sSuf|No_ldSuf, { Imm8S, Reg16|Reg32|Reg64|Word|Dword|Qword|Unspecified|BaseIndex|Disp8|Disp16|Disp32|Disp32S }
 xor, 2, 0x34, None, 1, 0, W|No_sSuf|No_ldSuf, { Imm8|Imm16|Imm32|Imm32S, Acc|Byte|Word|Dword|Qword }
diff -Naur ../PRISTINE/gdb-6.8/opcodes/i386-tbl.h gdb-6.8/opcodes/i386-tbl.h
--- ../PRISTINE/gdb-6.8/opcodes/i386-tbl.h	2008-02-23 09:29:17.000000000 -0800
+++ gdb-6.8/opcodes/i386-tbl.h	2009-04-21 00:34:48.000000000 -0700
@@ -1432,6 +1432,48 @@
       { { 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
 	  1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 
 	  1, 0, 0 } } } },
+  { "nacland", 2, 0x81, 0x4, 1,
+    { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
+      0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+      0, 0 },
+    { { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0 } },
+      { { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0 } } } },
+  { "naclor", 2, 0x81, 0x1, 1,
+    { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
+      0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+      0, 0 },
+    { { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0 } },
+      { { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0 } } } },
+  { "naclcall", 1, 0xff, 0x2, 1,
+    { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 
+      1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+      0, 0 },
+    { { { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0 } } } },
+  { "nacljmp", 1, 0xff, 0x4, 1,
+    { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 
+      1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+      0, 0 },
+    { { { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+	  0, 0, 0 } } } },
   { "xor", 2, 0x30, None, 1,
     { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
