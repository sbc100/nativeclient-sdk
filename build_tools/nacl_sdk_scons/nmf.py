#!/usr/bin/python
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

'''Utilities to create nmf (Native Client Manifest File) files'''

import json
import os
import subprocess
import sys

class Error(Exception):
  pass

# Here is the code from NaCl's SConstruct file that generates nmf files
# TODO(mball): This will be massaged into working code.
"""
def ParseLibInfoInRunnableLdLog(line):
  '''runnable-ld.so log has following format:

  lib_name => path_to_lib (0x....address)'''

  pos = line.find(' => ')
  if pos < 0:
    return None
  lib_name = line[:pos].strip()
  lib_path = line[pos+4:]
  pos1 = lib_path.rfind(' (')
  if pos1 < 0:
    return None
  lib_path = lib_path[:pos1]
  return lib_name, lib_path


def CopyLibsForExtensionCommand(target, source, env):
  '''Copy libs and manifest to the target directory.
  source[0] is a manifest file
  source[1] is a .libs file with a list of libs generated by runnable-ld.so'''

  source_manifest = str(source[0])
  target_manifest = str(target[0])
  shutil.copyfile(source_manifest, target_manifest)
  target_dir = os.path.dirname(target_manifest)
  libs_file = open(str(source[1]), 'r')
  for line in libs_file.readlines():
    lib_info = ParseLibInfoInRunnableLdLog(line)
    if lib_info:
      lib_name, lib_path = lib_info
      shutil.copyfile(lib_path, os.path.join(target_dir, lib_name))
  shutil.copyfile(env.subst('${NACL_SDK_LIB}/runnable-ld.so'),
                  os.path.join(target_dir, 'runnable-ld.so'))
  libs_file.close()


def CopyLibsForExtension(env, target_dir, manifest):
  '''Extensions are loaded from directory on disk and so all dynamic libraries
  they use must be copied to extension directory. The option --extra_serving_dir
  does not help us in this case.'''

  if not env.Bit('nacl_glibc'):
    return env.Install(target_dir, manifest)
  manifest_base_name = os.path.basename(str(env.subst(manifest)))
  lib_list_node = env.File('${STAGING_DIR}/' + manifest_base_name + '.libs')
  nmf_node = env.Command(
      target_dir + '/' + manifest_base_name,
      [manifest, lib_list_node],
      CopyLibsForExtensionCommand)
  return nmf_node

pre_base_env.AddMethod(CopyLibsForExtension)


def GenerateManifestFunc(target, source, env):
  '''Generate manifest from newlib manifest and the list of libs generated by
  runnable-ld.so.'''

  source_file = open(str(source[0]), 'r')
  obj = json.load(source_file)
  source_file.close()
  libs_file = open(str(source[1]), 'r')
  lib_names = []
  arch = env.subst('${TARGET_FULLARCH}')
  for line in libs_file.readlines():
    lib_info = ParseLibInfoInRunnableLdLog(line)
    if lib_info:
      lib_name, _ = lib_info
      lib_names.append(lib_name)
  libs_file.close()
  if 'files' not in obj:
    obj['files'] = {}
  for lib_name in lib_names:
    obj['files']['lib/' + lib_name] = {}
    obj['files']['lib/' + lib_name][arch] = {}
    obj['files']['lib/' + lib_name][arch]['url'] = lib_name
  obj['files']['main.nexe'] = {}
  for k, v in obj['program'].items():
    obj['files']['main.nexe'][k] = v.copy()
    v['url'] = 'runnable-ld.so'
  target_file = open(str(target[0]), 'w')
  json.dump(obj, target_file)
  target_file.close()
  return 0


def GetNexeFromManifest(env, manifest):
  '''Returns nexe specified in manifest file.'''
  manifest_file = open(str(env.File(manifest)), 'r')
  obj = json.load(manifest_file)
  manifest_file.close()
  nexe = obj['program'][env.subst('${TARGET_FULLARCH}')]['url']
  return nexe

manifest_map = {}


def GenerateManifestCommands(env, manifest):
  '''Returns command line arguments for browser tester that add generated
  manifest to a list of files to serve.'''
  manifest = env.subst(manifest)
  manifest_base_name = os.path.basename(manifest)
  nexe = GetNexeFromManifest(env, manifest)
  result = ['--file', env.File('${STAGING_DIR}/' + manifest_base_name)]
  if not env.Bit('nacl_glibc'):
    if manifest_base_name not in manifest_map:
      env.Install('${STAGING_DIR}', manifest)
      manifest_map[manifest_base_name] = nexe
    # fall through
  if manifest_base_name in manifest_map:
    if manifest_map[manifest_base_name] != nexe:
      print nexe
      print manifest_map[manifest_base_name]
      raise Exception("Two manifest files with the same name")
    return result
  manifest_map[manifest_base_name] = nexe
  lib_list_node = env.Command(
      '${STAGING_DIR}/' + manifest_base_name + '.libs',
      [GetSelLdr(env),
       '${NACL_SDK_LIB}/runnable-ld.so',
       env.File('${STAGING_DIR}/' + os.path.basename(nexe)),
       '${SCONSTRUCT_DIR}/DEPS'],
      '${SOURCES[0]} -a -E LD_TRACE_LOADED_OBJECTS=1 ${SOURCES[1]} '
      '--library-path ${NACL_SDK_LIB}:${LIB_DIR} ${SOURCES[2].posix} '
      '> ${TARGET}')
  nmf_node = env.Command(
      '${STAGING_DIR}/' + manifest_base_name,
      [manifest, lib_list_node],
      GenerateManifestFunc)
  return result
"""

class Nmf(object):
  '''Utilities to handle Native Client .nmf manifest files'''

  def __init__(self, toolchain_root, nexe, bits, sel_ldr=None,
               runnable_ld=None, library_path=None):
    '''Constructor for Nmf class

    Args:
      sel_ldr: (optional) path to sel_ldr executable.  If not provided, use
        $NACL_TOOLCHAIN_ROOT/bin/sel_ldr_x86_32 or ..._64
      runnable_ld: location of runnable-ld.so
      nexe: location of nexe
    '''
    self._toolchain_root = toolchain_root
    self._nexe = nexe.replace('\\', '/')
    self._bits = bits
    self._sel_ldr = (sel_ldr or os.path.join(toolchain_root,
                                             'bin',
                                             'sel_ldr_x86_%s' % bits))
    self._library_path = (library_path or
                          os.path.join(toolchain_root,
                                       'x86_64-nacl',
                                       'lib32' if bits == 32 else 'lib'))
    self._runnable_ld = (runnable_ld or
                         os.path.join(self._library_path, 'runnable-ld.so'))

  def GetLibraryDependencies(self):
    '''Returns a list of the library dependencies for a given nexe'''
    command = [self._sel_ldr,
               '-a', '-E', 'LD_TRACE_LOADED_OBJECTS=1',
               self._runnable_ld,
               '--library-path', self._library_path,
               self._nexe]
    print "Running ", command
    sys.stdout.flush()
    process = subprocess.Popen(command, stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    output, std_error = process.communicate()
    if process.poll() != 0:
      print 'stdout: %s\nstderr: %s' % (output, std_error)
      sys.stdout.flush()
      raise Error('%s returned an error' % self._sel_ldr)
    return output


def main(argv):
  '''Main entry for nmf utility'''
  print "Command-line interface currently not implemented."
  return 1


if __name__ == '__main__':
  sys.exit(main(sys.argv[1:]))
