#! -*- python -*-
#
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

""" Main scons script for Native Client SDK builds.

Do not invoke this script directly, but instead use the scons or scons.bat
wrapper function.  E.g.

Linux or Mac:
  ./scons [Options...]

Windows:
  scons.bat [Options...]
"""

from __future__ import with_statement

import os
import platform
import subprocess
import sys
import toolchainbinaries
from build_tools import build_utils

#------------------------------------------------------------------------------
HELP_STRING = """
===============================================================================
Help for NaCl SDK
===============================================================================

* cleaning:            ./scons -c
* build a target:      ./scons <target>

Supported targets:
  * bot               Runs everything that the build and try bots run.
  * debugger          Build the debugging library code and tests.
  * docs              Build all of the Doxygen documentation.
  * examples          Build the examples.
  * experimental      Build the experimental projects.
  * installer         Build the SDK installer.
  * toolchain         Update the toolchain's headers and libraries.
  * vsx_build         Build the Visual Studio Plugin.

Flags:
  * USE_EXISTING_INSTALLER=1        Do not rebuild the installer if it exists.
  * chrome_browser_path=<full_path> Download Chrome to <full_path>.

More targets are listed below in the automatically generated help section.

===============================================================================
Automatically generated help follows:
===============================================================================
"""

#------------------------------------------------------------------------------
# Perform some environment checks before running.
# Note that scons should set NACL_SDK_ROOT before this script runs.

if os.getenv('NACL_SDK_ROOT') is None:
  sys.stderr.write('NACL_SDK_ROOT must be defined as the root directory'
                   ' of NaCl SDK.\n')
  sys.exit(1)


# By default, run with a parallel build (i.e. '-j num_jobs').
# Use a default value proportional to the number of cpu cores on the system.
# To run a serial build, explicitly type '-j 1' on the command line.
try:
  import multiprocessing
  CORE_COUNT = multiprocessing.cpu_count()
except (ImportError, NotImplementedError):
  CORE_COUNT = 2  # Our buildbots seem to be dual-core typically

SetOption('num_jobs', CORE_COUNT * 2)
print 'Building with', GetOption('num_jobs'), 'parallel jobs'

#-----------------------------------------------------------------------------
# The environment_list contains all the build environments that we want to
# specify.  Selecting a particular environment is done using the --mode option.
# Each environment that we support gets appended to this list.
environment_list = []

#-----------------------------------------------------------------------------
# Create the base environment, from which all other environments are derived.
base_env = Environment(
    tools = ['component_setup'],
    CPPPATH = ['$MAIN_DIR'],
    CPPDEFINES = [
      'BOOST_ALL_NO_LIB',
    ],
    NACL_TOOLCHAIN_ROOTS = {
        ('x86', 'newlib'):
          build_utils.NormalizeToolchain(arch='x86', variant='newlib'),
        ('x86', 'glibc'):
          build_utils.NormalizeToolchain(arch='x86', variant='glibc'),
    },
    ROOT_DIR = os.path.abspath(os.getcwd()),
    IS_WINDOWS = sys.platform in ['cygwin', 'win32'],
    IS_LINUX = sys.platform == 'linux2',
    IS_MAC = sys.platform == 'darwin',
    JOB_COUNT = GetOption('num_jobs')
)

# It is possible to override these values on the command line by typing
# something like this:
#   PYTHON=/path/to/my/python
base_env.SetDefault(
    PYTHON = ARGUMENTS.get('PYTHON', 'python'),
    USE_EXISTING_INSTALLER = ARGUMENTS.get('USE_EXISTING_INSTALLER', False),
)

base_env.Append(
    BUILD_SCONSCRIPTS = [
        # Keep in alphabetical order
        'build_tools/build.scons',
        'debugger/build.scons',
        'documentation/build.scons',
        'experimental/visual_studio_plugin/build.scons',
        'project_templates/test.scons',
    ],
)

base_env.Help(HELP_STRING)

KNOWN_SUITES = frozenset([
    'bot',
    ])


def CheckSuiteName(suite, node_name):
  '''Check whether a given test suite or alias name is a known name.

  If the suite name is not in the approved list, then this function throws
  an exception, with the node_name within the error message.

  Args:
    suite: a name of a suite that must be in the KNOWN_SUITES set
    node_name: The name of the node.  This is used for error messages
  '''
  if suite not in KNOWN_SUITES:
    raise Exception('Testsuite/Alias "%s" for target "%s" is unknown' %
                    (suite, node_name))


def AddNodeToTestSuite(env, node, suite_names, node_name, test_size='all'):
  '''Adds a test node to a given set of suite names

  These tests are automatically added to the run_all_tests target and are
  listed in the help screen.

  This function is loosely based on a function of the same name in the
  Native Client repository

  Args:
    env - The environment from which this function was called
    node - A scons node (e.g., file, command, etc) to be added to set suite
    suite_names - A list of test suite names.  For none, pass an empty list
    node_name - The target name used for running this test
    test_size - The relative run-time of this test: small, medium, or large
  '''

  # CommandTest can return an empty list when it silently discards a test
  if not node:
    return

  AlwaysBuild(node)

  for s in suite_names:
    CheckSuiteName(s, node_name)
    env.Alias(s, node)

  if test_size not in ['small', 'medium', 'large', 'all']:
    raise Exception('Invalid test size for %s' % node_name)

  # Note that COMPONENT_TEST_SIZE is set to 'large' by default, which
  # populates a largely redundant list of 'large' tests.  Note that all
  # tests are added to 'all', so setting test_size='all' is a no-op
  env.ComponentTestOutput(node_name, node, COMPONENT_TEST_SIZE=test_size)

base_env.AddMethod(AddNodeToTestSuite)

def ShouldBeCleaned(env, targets, suite_names, node_name):
  '''Determines whether a given set of targets require cleaning.

  Args:
    env - The calling environment.
    targets - Any build artifacts to which a cleaning step might apply.
              Any false object indicates that this check is skipped.
    suite_names - Any suites that might produce |targets|
    node_name - A node that might produce |targets|
  '''
  if not env.GetOption('clean'):
    return False

  if len(COMMAND_LINE_TARGETS) > 0:
    clean_this = False
    for cl_target in COMMAND_LINE_TARGETS:
      if cl_target in suite_names or cl_target == node_name:
        clean_this = True
        break
    if not clean_this:
      return False

  if not targets:
    return True
  for target in targets:
    if os.path.exists(target):
      return True
  return False

def AddCleanAction(env, targets, action, suite_names, node_name):
  '''Adds a cleanup action that scons cannot detect automatically.

  Cleaning will only occur if there is a match between the suite or nodes
  specified on the command line, and suite_names or node_name or if no
  suite or nodes are specified on the command line.  Also, at least one of the
  targets must exist on the file system.

  Args:
    env - The calling environment
    targets - Artifacts to be cleaned.
    action - The action to be performed.  It is up to the caller to ensure
             that |action| will actually remove |targets|
    suite_names - Any suites to which this cleanup target applies.
    node_name - Any nodes to which this cleanup target applies.
  '''
  if ShouldBeCleaned(env, targets, suite_names, node_name):
    env.Execute(action)

base_env.AddMethod(AddCleanAction)

def AddNodeAliases(env, node, suite_names, node_name):
  '''Allow a given node to be built under a different name or as a suite

  Args:
    env - The calling environment
    node - A target node to add to a known build alias (e.g., 'bot')
    suite_names - A list of suite names.  For none, pass an empty list.  This
                  node will be run whenever any of these suites are invoked.
                  Each suite name must match a string in KNOWN_SUITES.
    node_name - The name of this node, when run by itself
  '''

  if not node:
    return

  for s in suite_names:
    CheckSuiteName(s, node_name)
    env.Alias(s, node)

  env.Alias(node_name, node)

base_env.AddMethod(AddNodeAliases)


def CreatePythonUnitTest(env, filename, dependencies=[], disabled=False,
                         params=[], buffered=True, banner=None):
  """Returns a new build command that will run a unit test with a given file.

  Args:
    env: SCons environment
    filename: The python file that contains the unit test
    dependencies: An optional list of other files that this unit test uses
    disabled: Setting this to True will prevent the test from running
    params: Optional additional parameters for python command
    buffered: True=stdout is buffered until entirely complete;
              False=stdout is immediately displayed as it occurs.
    banner: (optional) annotation banner for build/try bots

  Returns:
    A SCons command node
  """

  basename = os.path.splitext(os.path.basename(filename))[0]
  outfilename = "%s_output.txt" % basename

  def RunPythonUnitTest(env, target, source):
    """Runs unit tests using the given target as a command.

    The argument names of this test are not very intuitive but match what is
    used conventionally throughout scons.  If the string "PASSED" does not
    occur in target when this exits, the test has failed; also a scons
    convention.

    Args:
      env: SCons's current environment.
      target: Where to write the result of the test.
      source: The command to run as the test.

    Returns:
      None for good status
      An error string for bad status
    """
    if banner:
      bot = build_utils.BotAnnotator()
      bot.BuildStep(banner)

    if disabled:
      sys.stdout.write("Test %s is disabled.\n" % basename)
      sys.stdout.flush()
      return None   # return with good status

    import subprocess

    app = [str(env['PYTHON']), str(source[0].abspath)] + params
    app_env = os.environ.copy()
    # We have to do this because scons overrides PYTHONPATH and does
    # not preserve what is provided by the OS.
    python_path = [env['ROOT_DIR'], app_env['PYMOX'], app_env['PYTHONPATH']]
    app_env['PYTHONPATH'] = os.pathsep.join(python_path)
    ret_val = 'Error: General Test Failure'  # Indicates failure, by default
    target_str = str(target[0])
    with open(target_str, 'w') as outfile:
      def Write(str):
        if buffered:
          outfile.write(str)
          outfile.flush()
        else:
          sys.stdout.write(str)
          sys.stdout.flush()
      Write('\n-----Begin output for Test: %s\n' % basename)
      if subprocess.call(app, env=app_env,
                         stdout=outfile if buffered else None,
                         stderr=outfile if buffered else None):
        Write('-----Error: unit test failed\n')
        ret_val = 'Error: Test Failure in %s' % basename
      else:
        ret_val = None  # Indicates success

      Write('-----End output for Test: %s\n' % basename)
    if buffered:
      with open(target_str, 'r') as resultfile:
        sys.stdout.write(resultfile.read())
      sys.stdout.flush()

    return ret_val

  cmd = env.Command(outfilename, filename, RunPythonUnitTest)
  env.Depends(cmd, dependencies)

  return cmd

base_env.AddMethod(CreatePythonUnitTest)


# ----------------------------------------------------------
# Support for running Chrome.  These functions access the construction
# Environment() to produce a path to Chrome.

# A Dir object representing the directory where the Chrome binaries are kept.
# You can use chrome_binaries_dir= to set this on the command line.  Defaults
# to chrome_binaries.
base_env['CHROME_DOWNLOAD_DIR'] = \
    base_env.Dir(ARGUMENTS.get('chrome_binaries_dir', '#chrome_binaries'))


def ChromeArchitectureSpec(env):
  '''Determine the architecture spec for the Chrome binary.

  The architecture spec is a string that represents the host architecture.
  Possible values are:
    x86-32
    x86-64
  On Mac and Windows, the architecture spec is always x86-32, because there are
  no 64-bit version available.

  Returns: An architecture spec string for the host CPU.
  '''
  arch, _ = platform.architecture();
  # On Mac and Windows, always use a 32-bit version of Chrome (64-bit versions
  # are not available).
  if env['IS_WINDOWS'] or env['IS_MAC']:
    arch = 'x86-32'
  else:
    arch = 'x86-64' if '64' in arch else 'x86-32'
  return arch

base_env.AddMethod(ChromeArchitectureSpec)


def GetDefaultChromeBinary(env):
  '''Get a File object that represents a Chrome binary.

  By default, the test infrastructure will download a copy of Chrome that can
  be used for testing.  This method returns a File object that represents the
  downloaded Chrome binary that can be run by tests.  Note that the path to the
  binary is specific to the host platform, for example the path on Linux
  is <chrome_dir>/linux/<arch>/chrome, while on Mac it's
    <chrome_dir>/mac/<arch>/Chromium.app/Contents.MacOS/Chromium.

  Returns: A File object representing the Chrome binary.
  '''
  if env.get('IS_LINUX'):
    os_name = 'linux'
    binary = 'chrome'
  elif env.get('IS_WINDOWS'):
    os_name = 'windows'
    binary = 'chrome.exe'
  elif env.get('IS_MAC'):
    os_name = 'mac'
    binary = 'Chromium.app/Contents/MacOS/Chromium'
  else:
    raise Exception('Unsupported OS')

  return env.File(os.path.join('${CHROME_DOWNLOAD_DIR}',
                               os_name,
                               env.ChromeArchitectureSpec(),
                               binary))

base_env.AddMethod(GetDefaultChromeBinary)


def GetChromeBinary(env):
  '''Return a File object that represents the downloaded Chrome binary.

  If chrome_browser_path is specified on the command line, then return a File
  object that represents that path.  Otherwise, return a File object
  representing the default downloaded Chrome (see GetDefaultChromeBinary(),
  above).

  Returns: A File object representing a Chrome binary.
  '''
  return env.File(ARGUMENTS.get('chrome_browser_path',
                                env.GetDefaultChromeBinary()))

base_env.AddMethod(GetChromeBinary)


def DependsOnChrome(env, dependency):
  '''Create a dependency on the download of Chrome.

  Creates a dependency in |env| such that Chrome gets downloaded (if necessary)
  whenever |dependency| changes.  Uses the Chrome downloader scripts built
  into NaCl; this script expects NaCl to be DEPS'ed into
  third_party/native_client/native_client.

  The Chrome binary is added as a precious node to the build Environment.
  '''
  chrome_binary = env.GetDefaultChromeBinary()
  download_chrome_script = build_utils.JoinPathToNaClRepo(
      'native_client', 'build', 'download_chrome.py',
      root_dir=env['ROOT_DIR'])
  download_chrome_node = env.Command(
      chrome_binary,
      [],
      '${PYTHON} %s --arch=%s --dst=${CHROME_DOWNLOAD_DIR}' %
          (download_chrome_script, env.ChromeArchitectureSpec()))
  # This stops Scons from deleting the file before running the step above.
  env.NoClean(chrome_binary)
  env.Precious(chrome_binary)
  env.Depends(dependency, download_chrome_node)

base_env.AddMethod(DependsOnChrome)


# ----------------------------------------------------------
# Targets for updating sdk headers and libraries
# NACL_SDK_XXX vars are defined by  site_scons/site_tools/naclsdk.py
# NOTE: Our task here is complicated by the fact that there might already be
#       some (outdated) headers/libraries at the new location
#       One of the hacks we employ here is to make every library depend
#       on the installation on ALL headers (sdk_headers)

# Contains all the headers to be installed
sdk_headers = base_env.Alias('extra_sdk_update_header', [])
# Contains all the libraries and .o files to be installed
libs_platform = base_env.Alias('extra_sdk_libs_platform', [])
libs = base_env.Alias('extra_sdk_libs', [])
base_env.Alias('extra_sdk_update', [libs, libs_platform])

AlwaysBuild(sdk_headers)

toolchain_node = base_env.Alias('toolchain', [])


def GetToolchainNode(env):
  '''Returns the node associated with the toolchain build target'''
  return toolchain_node

base_env.AddMethod(GetToolchainNode)


def GetHeadersNode(env):
  return sdk_headers

base_env.AddMethod(GetHeadersNode)


def AddHeaderToSdk(env, nodes, subdir = 'nacl/', base_dirs = None):
  """Add a header file to the toolchain.  By default, Native Client-specific
  headers go under nacl/, but there are non-specific headers, such as
  the OpenGLES2 headers, that go under their own subdir.

  Args:
    env: Environment in which we were called.
    nodes: A list of node objects to add to the toolchain
    subdir: This is appended to each base_dir
    base_dirs: A list of directories to install the node to"""
  if not base_dirs:
    # TODO(mball): This won't work for PNaCl:
    base_dirs = [os.path.join(dir, 'x86_64-nacl', 'include')
                 for dir in env['NACL_TOOLCHAIN_ROOTS'].values()]

  for base_dir in base_dirs:
    node = env.Replicate(os.path.join(base_dir, subdir), nodes)
    env.Depends(sdk_headers, node)
    env.Depends(toolchain_node, node)
  return node

base_env.AddMethod(AddHeaderToSdk)

def AddLibraryToSdkHelper(env, nodes, is_lib, is_platform):
  """"Helper function to install libs/objs into the toolchain
  and associate the action with the extra_sdk_update.

  Args:
    env: Environment in which we were called.
    nodes: list of libc/objs
    is_lib: treat nodes as libs
    is_platform: nodes are truly platform specific
  """
  env.Requires(nodes, sdk_headers)

  dir = ARGUMENTS.get('extra_sdk_lib_destination')
  if not dir:
    dir = '${NACL_SDK_LIB}/'

  if is_lib:
    n = env.ReplicatePublished(dir, nodes, 'link')
  else:
    n = env.Replicate(dir, nodes)

  if is_platform:
    env.Alias('extra_sdk_libs_platform', n)
  else:
    env.Alias('extra_sdk_libs', n)
  return n


def AddLibraryToSdk(env, nodes, is_platform=False):
  return AddLibraryToSdkHelper(env, nodes, True, is_platform)

base_env.AddMethod(AddLibraryToSdk)


#-----------------------------------------------------------------------------
# This is a simple environment that is primarily for targets that aren't built
# directly by scons, and therefore don't need any special environment setup
build_env = base_env.Clone(
    BUILD_TYPE = 'build',
    BUILD_GROUPS = ['default', 'all'],
    BUILD_TYPE_DESCRIPTION = 'Default build environment',
    HOST_PLATFORMS = '*',
    )

environment_list.append(build_env)

#-----------------------------------------------------------------------------
# Get the appropriate build command depending on the environment.

def SconsBuildCommand(env):
  '''Return the build command used to run separate scons instances.
  Args:
    env: The construction Environment() that is building using scons.
  Returns:
    A string representing the platform-specific build command that will run the
    scons instances.
  '''
  if env.get('IS_WINDOWS'):
    return 'scons.bat --jobs=%s' % GetOption('num_jobs')
  else:
    return './scons --jobs=%s' % GetOption('num_jobs')

#-----------------------------------------------------------------------------
# Add a builder for examples.  This adds an Alias() node named 'examples' that
# is always built.  There is some special handling for the clean mode, since
# SCons relies on actual build products for its clean processing and will not
# run Alias() actions during clean unless they actually produce something.

def BuildExamples(env, target, source):
  '''Build the examples.

  This runs the build command in the 'examples' directory.

  Args:
    env: The construction Environment that is building the examples.
    target: The target that triggered this build.  Not used.
    source: The sources used for this build.  Not used.
  '''
  subprocess.check_call(SconsBuildCommand(env),
                        cwd='examples',
                        shell=True)


def CleanExamples(env, target, source):
  '''Clean the examples.

  This runs the clean command in the 'examples' directory.

  Args:
    env: The construction Environment that is building the examples.
  '''
  subprocess.check_call(SconsBuildCommand(env) + ' --clean',
                        cwd='examples',
                        shell=True)


examples_builder = build_env.Alias('examples', [toolchain_node], BuildExamples)
build_env.AlwaysBuild(examples_builder)
build_env.AddCleanAction(['examples'], CleanExamples, ['bot'],
                         examples_builder)


#-----------------------------------------------------------------------------
# Add a builder for experimental projects.  This adds an Alias() node named
# 'experimental' that is always built.  There is some special handling for the
# clean mode, since SCons relies on actual build products for its clean
# processing and will not run Alias() actions during clean unless they actually
# produce something.

def BuildExperimental(env, target, source):
  '''Build the experimental projects.

  This runs the build command in the 'experimental' directory.

  Args:
    env: The construction Environment that is building the experimental
    projects.
    target: The target that triggered this build.  Not used.
    source: The sources used for this build.  Not used.
  '''
  subprocess.check_call(SconsBuildCommand(env),
                        cwd='experimental',
                        shell=True)


def CleanExperimental(env, target, source):
  '''Clean the experimental projects.

  This runs the clean command in the 'experimental' directory.

  Args:
    env: The construction Environment that is building the experimental
    projects.
  '''
  subprocess.check_call(SconsBuildCommand(env) + ' --clean',
                        cwd='experimental',
                        shell=True)


experimental_builder = build_env.Alias('experimental', [toolchain_node],
                                       BuildExperimental)
build_env.AlwaysBuild(experimental_builder)
build_env.AddCleanAction(['experimental'], CleanExperimental, ['bot'],
                         experimental_builder)

# -----------------------------------------------------------------------------
BuildComponents(environment_list)

# Require specifying an explicit target only when not cleaning
if not GetOption('clean'):
  Default(None)
