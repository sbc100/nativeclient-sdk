#! -*- python -*-
#
# Copyright (c) 2011 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

""" Main scons script for Native Client SDK builds.

Do not invoke this script directly, but instead use the scons or scons.bat
wrapper function.  E.g.

Linux or Mac:
  ./scons [Options...]

Windows:
  scons.bat [Options...]
"""

from __future__ import with_statement

import os
import subprocess
import sys

#------------------------------------------------------------------------------
HELP_STRING = """
===============================================================================
Help for NaCl SDK
===============================================================================

* cleaning:            ./scons -c
* build a target:      ./scons <target>

Supported targets:
  * examples          Build all of the examples
  * docs              Build all of the Doxygen documentation
  * installer         Build the SDK installer
  * bot               Runs everything that the build and try bots run

Supported flags:
  * DEVELOPMENT=1     Runs with development options for the installer build
                      (currently this suppresses unneeded downloads)

More targets are listed below in the automatically generated help section.

===============================================================================
Automatically generated help follows:
===============================================================================
"""

#------------------------------------------------------------------------------
# Perform some environment checks before running.
# Note that scons should set NACL_SDK_ROOT before this script runs.

if os.getenv('NACL_SDK_ROOT') is None:
  sys.stderr.write('NACL_SDK_ROOT must be defined as the root directory'
                   ' of NaCl SDK.\n')
  sys.exit(1)


def GetToolchainRoot(sdk_root=None):
  '''Build a string representing the NaCl toolchain root.
  This root points at the platform-specific directory.
  '''
  if sdk_root is None:
    sdk_root = os.getenv('NACL_SDK_ROOT', '')
  if sys.platform == 'cygwin' or sys.platform.startswith('win'):
    variant = 'win_x86'
  elif sys.platform in ['darwin', 'macos']:
    variant = 'mac_x86'
  elif sys.platform in ['linux', 'linux2']:
    variant = 'linux_x86'
  else:
    sys.stderr.write('Unrecognized build platform: %s\n' % sys.platform)
    return ''

  return os.path.join(sdk_root, 'toolchain', variant)


# By default, run with a parallel build (i.e. '-j num_jobs').
# Use a default value proportional to the number of cpu cores on the system.
# To run a serial build, explicitly type '-j 1' on the command line.
try:
  import multiprocessing
  CORE_COUNT = multiprocessing.cpu_count()
except (ImportError, NotImplementedError):
  CORE_COUNT = 1

SetOption('num_jobs', CORE_COUNT + 1)
print 'Building with', GetOption('num_jobs'), 'parallel jobs'

#-----------------------------------------------------------------------------
# The environment_list contains all the build environments that we want to
# specify.  Selecting a particular environment is done using the --mode option.
# Each environment that we support gets appended to this list.
environment_list = []

#-----------------------------------------------------------------------------
# Create the base environment, from which all other environments are derived.
base_env = Environment(
    tools = ['component_setup'],
    CPPPATH = ['$MAIN_DIR'],
    CPPDEFINES = [
      'BOOST_ALL_NO_LIB',
    ],
    NACL_TOOLCHAIN_ROOT = GetToolchainRoot(os.getenv('NACL_SDK_ROOT')),
    ROOT_DIR = os.path.abspath(os.getcwd()),
    IS_WINDOWS = sys.platform in ['cygwin', 'win32'],
    IS_LINUX = sys.platform in ['linux', 'linux2'],
    IS_MAC = sys.platform in ['darwin', 'macos'],
)

# It is possible to override these values on the command line by typing
# something like this:
#   PYTHON=/path/to/my/python
#   DEVELOPMENT=1
base_env.SetDefault(
    PYTHON = ARGUMENTS.get('PYTHON', 'python'),
    DEVELOPMENT = ARGUMENTS.get('DEVELOPMENT', ''),
    MAKE = ARGUMENTS.get('MAKE', 'make'),
)

# The list of .scons files is order-dependent.  Scons will build their targets
# in the order they appear.
base_env.Append(
    BUILD_SCONSCRIPTS = [
        'examples/build.scons',
        'documentation/build.scons',
        'build_tools/build.scons',
        'project_templates/test.scons',
    ],
)

base_env.Help(HELP_STRING)

KNOWN_SUITES = frozenset([
    'bot',
    ])


def CheckSuiteName(suite, node_name):
  '''Check whether a given test suite or alias name is a known name.

  If the suite name is not in the approved list, then this function throws
  an exception, with the node_name within the error message.

  Args:
    suite: a name of a suite that must be in the KNOWN_SUITES set
    node_name: The name of the node.  This is used for error messages
  '''
  if suite not in KNOWN_SUITES:
    raise Exception('Testsuite/Alias "%s" for target "%s" is unknown' %
                    (suite, node_name))


def AddNodeToTestSuite(env, node, suite_names, node_name, test_size='all'):
  '''Adds a test node to a given set of suite names

  These tests are automatically added to the run_all_tests target and are
  listed in the help screen.

  This function is loosely based on a function of the same name in the
  Native Client repository

  Args:
    env - The environment from which this function was called
    node - A scons node (e.g., file, command, etc) to be added to set suite
    suite_names - A list of test suite names.  For none, pass an empty list
    node_name - The target name used for running this test
    test_size - The relative run-time of this test: small, medium, or large
  '''

  # CommandTest can return an empty list when it silently discards a test
  if not node:
    return

  AlwaysBuild(node)

  for s in suite_names:
    CheckSuiteName(s, node_name)
    env.Alias(s, node)

  if test_size not in ['small', 'medium', 'large', 'all']:
    raise Exception('Invalid test size for %s' % node_name)

  # Note that COMPONENT_TEST_SIZE is set to 'large' by default, which
  # populates a largely redundant list of 'large' tests.  Note that all
  # tests are added to 'all', so setting test_size='all' is a no-op
  env.ComponentTestOutput(node_name, node, COMPONENT_TEST_SIZE=test_size)

base_env.AddMethod(AddNodeToTestSuite)


def AddNodeAliases(env, node, suite_names, node_name):
  '''Allow a given node to be built under a different name or as a suite

  Args:
    env - The calling environment
    node - A target node to add to a known build alias (e.g., 'bot')
    suite_names - A list of suite names.  For none, pass an empty list.  This
                  node will be run whenever any of these suites are invoked.
                  Each suite name must match a string in KNOWN_SUITES.
    node_name - The name of this node, when run by itself
  '''

  if not node:
    return

  for s in suite_names:
    CheckSuiteName(s, node_name)
    env.Alias(s, node)

  env.Alias(node_name, node)

base_env.AddMethod(AddNodeAliases)


def CreatePythonUnitTest(env, filename, dependencies=[], disabled=False):
  """Returns a new build command that will run a unit test with a given file.

  Args:
    env: SCons environment
    filename: The python file that contains the unit test
    dependencies: An optional list of other files that this unit test uses
    disabled: Setting this to True will prevent the test from running

  Returns:
    A SCons command node
  """

  basename = os.path.splitext(os.path.basename(filename))[0]
  outfilename = "%s_output.txt" % basename

  def RunPythonUnitTest(env, target, source):
    """Runs unit tests using the given target as a command.

    The argument names of this test are not very intuitive but match what is
    used conventionally throughout scons.  If the string "PASSED" does not
    occur in target when this exits, the test has failed; also a scons
    convention.

    Args:
      env: SCons's current environment.
      target: Where to write there result of the test.
      source: The command to run as the test.

    Returns:
      None for good status
      An error string for bad status
    """
    if disabled:
      sys.stdout.write("Test %s is disabled.\n" % basename)
      sys.stdout.flush()
      return None   # return with good status

    import subprocess

    app = [str(env['PYTHON']), str(source[0].abspath)]
    app_env = os.environ.copy()
    # We have to do this because scons overrides PYTHONPATH and does
    # not preserve what is provided by the OS.
    python_path = [env['ROOT_DIR'], app_env['PYMOX']]
    app_env['PYTHONPATH'] = os.pathsep.join(python_path)
    ret_val = 'Error: General Test Failure'  # Indicates failure, by default
    target_str = str(target[0])
    with open(target_str, 'w') as outfile:
      outfile.write('\n-----Begin output for Test: %s\n' % basename)
      outfile.flush()
      if subprocess.call(app, env=app_env, stdout=outfile, stderr=outfile):
        outfile.write('-----Error: unit test failed\n')
        ret_val = 'Error: Test Failure in %s' % basename
      else:
        ret_val = None  # Indicates success

      outfile.write('-----End output for Test: %s\n' % basename)
    with open(target_str, 'r') as resultfile:
      sys.stdout.write(resultfile.read())

    sys.stdout.flush()
    return ret_val

  cmd = env.Command(outfilename, filename, RunPythonUnitTest)
  env.Depends(cmd, dependencies)

  return cmd

base_env.AddMethod(CreatePythonUnitTest)

#-----------------------------------------------------------------------------
# This is a simple environment that primarily for targets that aren't built
# directly by scons, and therefore don't need any special environment setup
build_env = base_env.Clone(
    BUILD_TYPE = 'build',
    BUILD_GROUPS = ['default', 'all'],
    BUILD_TYPE_DESCRIPTION = 'Default build environment',
    HOST_PLATFORMS = '*',
    )

environment_list.append(build_env)


# -----------------------------------------------------------------------------
BuildComponents(environment_list)

# Require specifying an explicit target
Default(None)
