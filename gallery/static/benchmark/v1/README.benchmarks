BENCHMARK FRAMEWORK AND MODIFICATIONS

These benchmarks (both the Javascript and C/C++ implementations) are derived
from the Computer Language Benchmarks Game (http://shootout.alioth.debian.org),
which contains implementations of the tasks in many different langauges.
All of the implementations are required to take their parameters from the
command line, read their input (one line at a time) from standard input,
and print their output to standard output. Additionally, the driver script
is written in Python and has Linux and Windows system-specific code to manage
the processes. These two properties mean that neither the benchmarks nor the
driver script can be used unmodified in Native Client on a web page.

RUNNING AND SCORING THE BENCHMARKS
Instead of using the Python script from shootout.alioth.debian.org to run all 
the benchmarks in each language from the command line, this implementation uses 
driver framework code written in the same language as the benchmarks, and each
language is run separately from the web page. The Javascript framework is
derived from the V8 benchmark suite (http://code.google.com/p/v8, and see 
js/base.js in this package), and the Native Client framework is hand-written
in C to call the benchmarks in a similar way (see nacl/bench-framework.c).
Because Javascript runs on the browser's man UI thread by default, the V8 suite
attempts to avoid blocking it for long periods of time by using very small
inputs and running them repeatedly, yielding the thread between each run.
This limits the size of the benchmark that can be run, and does not match well
with the kind of usage model expected for Native Client applications. For this
implementation we run larger inputs to get longer-running tests, and run them
only once. In both Native Client and Javascript, the tests are run on a
background thread (using pthreads and Web Workers, respectively) to avoid
blocking the browser UI thread.

The V8 suite calculates scores for each benchmarks by determining the number 
of runs per unit time, and normalizing such that a reference system gets a score
of 100. This means that scores represent speeds, and e.g. a score that is twice
as large represents a benchmark that runs twice as fast.  This implementation
operates simiarly, normalizing the scores such that a command-line Javascript 
scores 1000 on a reference system. (The normalizing constants can be found
in nacl/bench-framework.c and in js/setup_benchmarks.js)


BENCHMARK CODE MODIFICATIONS
The benchmarks themselves are designed to use standard input and standard output
but this is not possible in the browser. The Fasta, Revcomp, and
Knucleotide benchmarks use large text strings as their input or output 
(specifically a string generated by Fasta is used as the input
for Revcomp and Knucleotide). Instead of using file or console I/O, Fasta's
output is written to a memory buffer, and Revcomp and Knucleotide read from
this buffer for their input. The implementation of the buffer is implemented
similarly in Javascript (js/io_replacement.js) and Native Client 
(nacl/benchstringio.c)
The Fannkuchredux, Nbody, Spectralnorm, Binarytrees, and Pidigits benchmarks
are essentially unmodifed (they do very little I/O compared to the amount of
computation required).
The input sizes of the benchmarks are also somewhat smaller than the default
sizes used by the Computer Language Benchmarks Game. There are two reasons for
this; first, the default size takes about 15 minutes to run in Javascript,
which is longer than most people will want to sit and wait for a web page
(with the current size, the Javascript suite runs in about 2.5 minutes on
the reference machine). Secondly, the use of the memory buffer for Fasta,
Revcomp and Knucleotide means that the size of that input is limited by
Javascript heap size.